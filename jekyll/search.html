<!DOCTYPE html>
<html>
<head>
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],     j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= 'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-W4CBFKS');
  </script>
    <meta charset="utf-8">
    <title> | Документация Эвотор</title>
    <base target="_self">
    <meta name="description" content="           ... " />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google" value="notranslate">
    <link rel="icon"  type="image/x-icon" href="favicon.ico">



    <!--stylesheets / link tags loaded here-->
    <link rel="stylesheet" type="text/css" href="assets/css/font-awesome.min.css">
    <link rel="stylesheet" href="assets/css/sidebar.css" />
    <link rel="stylesheet" href="assets/css/bootstrap.min.css" />
    <link rel="stylesheet" href="assets/css/darkly.css" />
    <link rel="stylesheet" href="assets/css/lighttheme-evoblue.css" />
    <link rel="stylesheet" href="assets/css/customstyles.css" />
    <link rel="stylesheet" href="assets/css/magnific-popup.css">

    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/navgoco.jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/clipboard@1/dist/clipboard.min.js"></script>

</head>
<body data-spy="scroll" data-target="nav#toc" data-offset="20">
<div class="page-container">


    <!-- Navigation -->

<nav class="navbar navbar-default navbar-fixed-top">
    <div class="container topnavlinks">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle topnav</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <button type="button" class="navbar-toggle toggle-sidebar-button"  data-toggle="offcanvas" data-target=".sidebar-nav">
                <span class="sr-only">Toggle sidebar</span>
                <span class="sidebarToggle fa fa-columns fa-2x"></span>
            </button>
                <a class="navbar-brand" href="index.html">
                <img class="navbar-logo" src="images/logo_white.png"/>
            </a>
        </div>

        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-left">
                <!-- entries without drop-downs appear here -->
                
                
                
                
                <li><a href="https://api.evotor.ru/" class="noCrossRef">REST API Облака</a></li>
                
                
                
                <!-- entries with drop-downs appear here -->

                
                
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">SDK cмарт-терминала<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        
                        
                        <li><a href="java_introduction.html">Java SDK</a></li>
                        
                        
                        
                        <li><a href="rn_gettingstarted.html">React Native SDK</a></li>
                        
                        
                    </ul>
                </li>
                
                

</ul>


<ul class="nav navbar-nav navbar-right">

                    <li>
                        <!--start search-->
                        <div id="search-demo-container">
                 <form action="search.html" method="get">
                <input type="text" id="search-input" placeholder="Поиск по сайту ..." name="query">
                </form>
                </div>
                        <!--end search-->
                    </li>
                </ul>
            </div>
            </div>
            <!-- /.container -->
    </nav>
    <div class="container">
        <div class="row row-offcanvas row-offcanvas-left">

            <!-- sidebar -->
            <div class="col-xs-6 col-sm-3 sidebar-offcanvas" id="sidebar" role="navigation">
                <!--<ul class="nav">-->
                    <!--<li class="active"><a href="#">Home</a></li>-->
                    <!--<li><a href="#">Link 1</a></li>-->
                    <!--<li><a href="#">Link 2</a></li>-->
                    <!--<li><a href="#">Link 3</a></li>-->
                <!--</ul>-->
                

<div class="mydocsidebar">
<div class="sidebar-inner">
<div class="productTitle"></div>
<!-- search bar -->

<!-- end search bar -->
<ul id="docnavsidebar" class="docnav">
    

    </li>
</ul>

<hr class="resourceSeparator"></hr>
<div class="relatedResources"></div>
<ul id="entrypages">
        
    </li>
</ul>
</div>
</div>
<script>$("li.open").parents('li').toggleClass("open");</script>

            </div>

            <!-- main area -->
            <div class="col-xs-12 col-sm-7">
                
                <h1> Результаты поиска</h1>
                  
                 <div class="toc-main-column">
                 

               </div>
                <div style="display: none">
<form action="search.html" method="get">
  <div class="input-group search">
    <input type="text" id="search-box" name="query" class="form-control" placeholder="">
    <div class="input-group-btn">
      <button class="btn btn-default" type="submit" value="search">
        <i class="glyphicon glyphicon-search"></i>
      </button>
    </div>
  </div>
</form>
</div>

<div id="search-results"></div>

<script>
  window.store = {
      
          
          
      "doc-app-grants-html": {
        "title": "Права приложения",
        "tags": "[]",
        "content": "О правах приложенияС помощью прав (grants), назначенных различным компонентам приложения, вы можете ограничить функциональность приложения для пользователей с определёнными ролями. Чтобы узнать список прав той или иной роли, используйте Users API. Примечание: Чтобы приложение было доступно пользователю, список заданных прав приложения должен точно соответствовать списку прав роли пользователя. Пользователи создают и редактируют роли в Личном  кабинете. Права предустановленных ролей “Кассир” и “Администратор” изменять нельзя.Если оставить список прав пустым, приложение будет доступно любому пользоваетлю, независимо от роли.Java-приложениеЧтобы наделить java-приложение необходимыми правами, выполните следующие действия:  По адресу res/values создайте файл &lt;Название&gt;_grants.xml, где &lt;Название&gt; – имя требуемого плагина, демона или экрана.      В файле &lt;Название&gt;_grants.xml укажите массив строк с правами следующим образом:    &lt;resources&gt;&lt;string-array name=\"&lt;Название&gt;_grants\"&gt;    &lt;item&gt;CASH_OPERATIONS_SELL&lt;/item&gt;    &lt;item&gt;CASH_OPERATIONS_PAYBACK &lt;/item&gt;&lt;/string-array&gt;&lt;/resources&gt;            В манифесте приложения, для соответствующей операции (activity), добавьте элемент meta-data со следующими атрибутами:    &lt;meta-data android:name=\"ru.evotor.launcher.GRANTS\" android:resource=\"@array/&lt;Название&gt;_grants\" /&gt;      ПримерыМанифест приложения:&lt;activity android:name=\".app.SomeJSWrappedActivity\" android:theme=\"@style/JSWrappedTheme\" android:icon=\"@drawable/icon\" android:label=\"&lt;Название плитки&gt;\"&gt;    &lt;intent-filter&gt;        &lt;action android:name=\"android.intent.action.MAIN\" /&gt;        &lt;category android:name=\"android.intent.category.EVOTOR\" /&gt;    &lt;/intent-filter&gt;    &lt;meta-data android:name=\"ru.evotor.launcher.BACKGROUND_COLOR\" android:value=\"#133788\" /&gt;    &lt;meta-data android:name=\"ru.evotor.launcher.GRANTS\" android:resource=\"@array/&lt;Название&gt;_grants\" /&gt;&lt;/activity&gt;Список прав в файле res/values/&lt;Название&gt;_grants.xml:&lt;resources&gt;&lt;string-array name=\"&lt;Название&gt;_grants\"&gt;    &lt;item&gt;CASH_OPERATIONS_SELL&lt;/item&gt;    &lt;item&gt;CASH_OPERATIONS_PAYBACK &lt;/item&gt;&lt;/string-array&gt;&lt;/resources&gt;Список правВ таблице ниже представлены права, которыми вы можете наделить компоненты приложения.  CASH_OPERATIONS_SELL    CASH_OPERATIONS_SELL_ADDITIONAL_CHANGE_ZERO_PRICE    CASH_OPERATIONS_SELL_ADDITIONAL_POSITION_DISCOUNT    CASH_OPERATIONS_SELL_ADDITIONAL_DOCUMENT_DISCOUNT    CASH_OPERATIONS_SELL_ADDITIONAL_REGISTER_POSITION_FREE    CASH_OPERATIONS_PAYBACK    CASH_OPERATIONS_PAYBACK_BY_SUM    CASH_OPERATIONS_PAYBACK_BY_SUM_ADDITIONAL_CHANGE_PRICE    CASH_OPERATIONS_PAYBACK_BY_SUM_ADDITIONAL_CHANGE_ZERO_PRICE    CASH_OPERATIONS_PAYBACK_BY_SUM_ADDITIONAL_POSITION_DISCOUNT    CASH_OPERATIONS_PAYBACK_BY_SUM_ADDITIONAL_DOCUMENT_DISCOUNT    CASH_OPERATIONS_PAYBACK_BY_SUM_ADDITIONAL_REGISTER_POSITION_FREE    CASH_OPERATIONS_CASH_DRAWER_CASH_INCOME    CASH_OPERATIONS_CASH_DRAWER_CASH_OUTCOME    CASH_REPORTS_X_REPORT    CASH_REPORTS_Z_REPORT    MANAGEMENT_REPORTS_STOCK_REPORT    MANAGEMENT_REPORTS_PROCUREMENT_REPORT    MANAGEMENT_REPORTS_SALES_REPORT    MANAGEMENT_REPORTS_CONSOLIDATED_SALES_REPORT    MANAGEMENT_REPORTS_GROSS_PROFIT_REPORT    MANAGEMENT_REPORTS_COMMODITIES_MOVEMENTS_REPORT    MANAGEMENT_REPORTS_ALCOHOL_REPORT    DOCUMENTS_JOURNAL    OPERATIONS_JOURNAL    SERVICE_EXCHANGE    SETTINGS_MENU    APPLICATIONS_MERCHANDISER  ",
        "url": "doc_app_grants.html",
        "product": ""
      }
      ,
      
    
          
      "doc-app-integration-points-html": {
        "title": "Точки интеграции",
        "tags": "[]",
        "content": "Точки интеграции необходимы для взаимодействия приложения и смарт-терминала. Точки интеграции представляют собой события, которые распространяет смарт-терминал и команды, которые может передавать приложение. В ответ на события смарт-терминал может ожидать (в этом случае на событие требуется подписать службу) или не ожидать ответа от приложения (на такие события требуется подписывать приёмники широковещательных сообщений). События, требующие ответа, похожи на команды, но передаёт их терминал. Примечание: О том, что представляют из себя службы и приёмники сообщений вы можете узнать в документации для Android ОС.Схема ниже показывает процесс обмена событием, которое требует ответа. Первое приложение, которое получает событие, смарт-терминал выбирает случайным образом.Обмен событиями, которые требуют ответаПодготовка манифеста приложенияВ зависимости от типа точки интеграции, вам потребуется соответствующим образом изменить манифест приложения. Так, если вы используете службы или приёмники сообщений, вам необходимо объявить их в манифесте приложения. Примечание: Если ваше приложение передаёт в смарт-терминал команды, манифест изменять не требуется.Объявление службы в манифесте приложения&lt;service            android:name=\".YourService\"            android:enabled=\"true\"            android:exported=\"true\"&gt;            &lt;intent-filter&gt;                &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;                &lt;action android:name=\"&lt;Событие, которое требуют ответа&gt;\" /&gt;            &lt;/intent-filter&gt;        &lt;/service&gt;Объявление приёмника широковещательных сообщений в манифесте приложения&lt;receiver android:name=\".YourBroadcastReceiver\" android:enabled=\"true\" android:exported=\"true\"&gt;    &lt;intent-filter&gt;        &lt;action android:name=\"&lt;Событие, которое не требует ответа&gt;\" /&gt;        &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;Список точек интеграцииНиже приведены таблицы с описанием всех точек интеграции приложения и смарт-терминала.Команды приложенияПример объявленной команды:new OpenSellReceiptCommand(positionAddList, extra).process(context, callback);Команда открытия чека продажиevo.v2.receipt.sell.openReceiptOpenSellReceiptCommandnew OpenSellReceiptCommand(positionAddList, extra).process(context, callback);Команда открытия чека возврата проданного товараevo.v2.receipt.payback.openReceiptOpenPaybackReceiptCommand new OpenPaybackReceiptCommand(positionAddList, extra).process(context, callback);Команда открытия чека покупкиevo.v2.receipt.buy.openReceiptOpenBuyReceiptCommandnew OpenBuyReceiptCommand(positionAddList, extra).process(context, callback);Команда открытия чека возврата купленного товараevo.v2.receipt.buyback.openReceiptOpenBuybackReceiptCommand new OpenBuybackReceiptCommand(positionAddList, extra).process(context, callback);Команда печати чека продажиevo.v2.receipt.sell.printReceiptPrintSellReceiptCommandPrintSellReceiptCommand command = new PrintSellReceiptCommand(positionsList, payments, clientPhone, clientEmail);Команда печати чека возвратаevo.v2.receipt.payback.printReceiptPrintPaybackReceiptCommandКоманда печати Z-отчётаevo.v2.receipt.payback.printReceiptPrintZReportCommandnew PrintZReportCommand().process(context, callback);События, которые не требуют ответаНа события, которые не требуют ответа, следует подписывать приёмники широковещательных сообщений (демоны в JS-приложении).Пример подписанного приёмника широковещательных сообщений в Java-приложении:public class MyBroadcastReceiver extends BroadcastReceiver {    @Override public void onReceive(Context context, Intent intent) {        CashDrawerOpenEvent event = CashDrawerOpenEvent.create(intent.getExtras());        // TODO insert your code here }}Событие открытия денежного ящикаevotor.intent.action.cashDrawer.OPENCashDrawerOpenEvent.javaВнесение денегevotor.intent.action.cashOperation.CASH_INCashInEvent.javaВыплата денегevotor.intent.action.cashOperation.CASH_OUTCashOutEvent.java Обновление базы товаровevotor.intent.action.inventory.PRODUCTS_UPDATEDInventoryApi.ktОткрытие карточки товара\\товарной группыevotor.intent.action.inventory.CARD_OPENProductCardOpenedEvent.javaПозиция была отредактирована в чеке продажиevotor.intent.action.receipt.sell.POSITION_EDITEDPositionEditedEvent.javaПозиция была отредактирована в чеке возврата проданного товараevotor.intent.action.receipt.payback.POSITION_EDITEDPositionEditedEvent.java Позиция была отредактирована в чеке покупкиevotor.intent.action.receipt.buy.POSITION_EDITEDPositionEditedEvent.javaПозиция была отредактирована в чеке возврата купленного товараevotor.intent.action.receipt.buyback.POSITION_EDITEDPositionEditedEvent.java Позиция была добавлена в чек продажиevotor.intent.action.receipt.sell.POSITION_ADDEDPositionAddedEvent.java Позиция была добавлена в чек возврата проданного товараevotor.intent.action.receipt.payback.POSITION_ADDEDPositionAddedEvent.java Позиция была добавлена в чек покупкиevotor.intent.action.receipt.buy.POSITION_ADDEDPositionAddedEvent.java Позиция была добавлена в чек возврата купленного товараevotor.intent.action.receipt.buyback.POSITION_ADDEDPositionAddedEvent.java Позиция была удалена из чека продажиevotor.intent.action.receipt.sell.POSITION_REMOVEDPositionRemovedEvent.java Позиция была удалена из чека возврата проданного товараevotor.intent.action.receipt.payback.POSITION_REMOVEDPositionRemovedEvent.java Позиция была удалена из чека покупкиevotor.intent.action.receipt.buy.POSITION_REMOVEDPositionRemovedEvent.java Позиция была удалена из чека возврата купленного товараevotor.intent.action.receipt.buyback.POSITION_REMOVEDPositionRemovedEvent.java Чек продажи был очищенevotor.intent.action.receipt.sell.CLEAREDReceiptClearedEvent.javaЧек возврата проданного товара был очищенevotor.intent.action.receipt.payback.CLEAREDReceiptClearedEvent.java Чек покупки был очищенevotor.intent.action.receipt.buy.CLEAREDReceiptClearedEvent.javaЧек возврата купленного товара был очищенevotor.intent.action.receipt.buyback.CLEAREDReceiptClearedEvent.java Чек продажи был успешно закрытevotor.intent.action.receipt.sell.RECEIPT_CLOSEDReceiptClosedEvent.javaЧек возврата проданного товара был успешно закрытevotor.intent.action.receipt.payback.RECEIPT_CLOSEDReceiptClosedEvent.java Чек покупки был успешно закрытevotor.intent.action.receipt.buy.RECEIPT_CLOSEDReceiptClosedEvent.javaЧек возврата купленного товара был успешно закрытevotor.intent.action.receipt.buyback.RECEIPT_CLOSEDReceiptClosedEvent.java Чек продажи был успешно открытevotor.intent.action.receipt.sell.OPENEDReceiptOpenedEvent.javaЧек возврата проданного товара был успешно открытevotor.intent.action.receipt.payback.OPENEDReceiptOpenedEvent.java Чек покупки был успешно открытevotor.intent.action.receipt.buy.OPENEDReceiptOpenedEvent.javaЧек возврата купленного товара был успешно открытevotor.intent.action.receipt.buyback.OPENEDReceiptOpenedEvent.java Печатные группы были изменены для чека продажиevotor.intent.action.receipt.sell.printGroup.EDITEDReceiptPrintGroupEditedEvent.javaПечатные группы были изменены для чека возвратаevotor.intent.action.receipt.payback.printGroup.EDITEDReceiptPrintGroupEditedEvent.java Оплаты по чеку продажи были разделеныevotor.intent.action.receipt.sell.paymentParts.EDITEDReceiptPaymentPartsEditedEvent.javaОплаты по чеку возврата были разделеныevotor.intent.action.receipt.payback.paymentParts.EDITEDReceiptPaymentPartsEditedEvent.javaСобытия, которые требуют ответаНа события, которые требуют ответа, следует подписывать службы (плагины в JS-приложении).Намерение изменить позицию в чеке продажиevo.v2.receipt.sell.beforePositionsEditedBeforePositionsEditedEvent.javaНамерение изменить позицию в чеке возврата проданного товараevo.v2.receipt.payback.beforePositionsEditedBeforePositionsEditedEvent.javaНамерение изменить позицию в чеке покупкиevo.v2.receipt.buy.beforePositionsEditedBeforePositionsEditedEvent.javaНамерение изменить позицию в чеке возврата купленного товараevo.v2.receipt.buyback.beforePositionsEditedBeforePositionsEditedEvent.javaРазделение платежей в чеке продажиevo.v2.receipt.sell.payment.SELECTEDPaymentSelectedEvent.javaРазделение чека продажи на несколько печатных группevo.v2.receipt.sell.printGroup.REQUIREDPrintGroupRequiredEvent.javaНачисление скидки на чек продажиevo.v2.receipt.sell.receiptDiscountReceiptDiscountEvent.javaНачисление скидки на чек возвратаevo.v2.receipt.payback.receiptDiscountReceiptDiscountEvent.javaОплата в сторонней платёжной системеevo.v2.receipt.paymentSystemPaymentSystemEvent.kt",
        "url": "doc_app_integration_points.html",
        "product": ""
      }
      ,
      
    
          
      "doc-drivers-cashdrawer-html": {
        "title": "SDK для денежного ящика",
        "tags": "[]",
        "content": "Определение внешнего сервиса в AndroidManifest.xmlУкажите хотя бы один Intent filter: INTENT_FILTER_DRIVER_MANAGER или INTENT_FILTER_VIRTUAL_DRIVER_MANAGER.Пример объявленного сервиса:&lt;service    android:name=\"ru.mycompany.drivers.MyDeviceService\"    android:enabled=\"true\"    android:exported=\"true\"    android:icon=\"@drawable/logo\"    android:label=\"@string/service_name\"&gt;    &lt;intent-filter&gt;        &lt;action android:name=\"ru.evotor.devices.drivers.DriverManager\" /&gt;        &lt;action android:name=\"ru.evotor.devices.drivers.CashDrawer\" /&gt;    &lt;/intent-filter&gt;    &lt;meta-data        android:name=\"vendor_name\"        android:value=\"CAS\" /&gt;    &lt;meta-data        android:name=\"model_name\"        android:value=\"AD\" /&gt;    &lt;meta-data        android:name=\"usb_device\"        android:value=\"VID_1659PID_8963\" /&gt;    &lt;meta-data        android:name=\"settings_activity\"        android:value=\"\" /&gt;    &lt;meta-data        android:name=\"device_categories\"        android:value=\"CASHDRAWER\" /&gt;&lt;/service&gt;Где:vendor_name – наименование производителя, которое будет отображаться при подключении устройства.model_name – наименование модели устройства.INTENT_FILTER_DRIVER_MANAGER – используется для драйверов, требующих подключения USB- оборудования. Помимо Intent filter в meta-data необходимо указать характеристики VendorID и ProductID целевого устройства (десятичными числами):&lt;meta-data    android:name=\"usb_device\"    android:value=\"VID_1659PID_8963\" /&gt; Совет: Можно указать несколько устройств: VID_1659PID_8963|VID_123PID_456|VID_1659PID_8964.Экземпляр драйвера будет автоматически создан/удалён при подключении/отключении указанного оборудования к смарт-терминалу. При наличии нескольких подходящих драйверов, пользователю будет предложен выбор.INTENT_FILTER_VIRTUAL_DRIVER_MANAGER – используется для драйверов, не требующих подключения USB-оборудования (сетевое, bluetooth и др.). В meta-data необходимо указать, что драйвер является виртуальным:&lt;meta-data    android:name=\"virtual_device\"    android:value=\"true\" /&gt; Важно: Экземпляр такого драйвера пользователь может создать исключительно вручную через настройки оборудования. В этом случае, все работы по подключению к нужному устройству берёт на себя производитель драйвера.Определение роли и категории устройстваЧтобы устройство было распознано как денежный ящик, используйте Intent filter:INTENT_FILTER_CASH_DRAWERВместе с этим необходимо указать в meta-data категорию устройства:&lt;meta-data    android:name=\"device_categories\"    android:value=\"CASHDRAWER\" /&gt; Совет: Можно указать сразу несколько ролей устройству: SCALES|PRICEPRINTER|CASHDRAWER|OTHER(весы | принтер чеков | денежный ящик | другое оборудование).Присвоение картинки для драйвераУкажите в манифесте приложения у сервиса:android:icon – картинка устройства, которая будет отображаться пользователю при инициализации устройства;android:label – имя драйвера, которое будет отображаться пользователю при инициализации устройства.Пример отображения иконки и имени драйвераМожно задать activity настроек:&lt;meta-data    android:name=\"settings_activity\"    android:value=\"ru.mycompany.drivers.MySettingsActivity\" /&gt;Указанная activity должна находиться в текущем package и будет вызвана при первом подключении устройства или при выборе устройства в меню настроек оборудования.Версия драйвера (versionCode и versionName) берётся из build.gradle:defaultConfig {    applicationId \"ru.mycompany.drivers.mycashdrawer\"    minSdkVersion 22    targetSdkVersion 24    versionCode 2    versionName \"1.0.1\"} Важно: MinSdkVersion должна быть не выше версии 22.Подключение к сервису всех actionВ реализации метода подключения к сервису для всех action, указанных в интент-фильтрах укажите соответствующие Binder’ы:для INTENT_FILTER_DRIVER_MANAGER – класс наследник ru.evotor.devices.drivers.IUsbDriverManagerService.Stub;для INTENT_FILTER_VIRTUAL_DRIVER_MANAGER – класс наследник ru.evotor.devices.drivers.IVirtualDriverManagerService.Stub;для INTENT_FILTER_CASHDRAWER – класс наследник ru.evotor.devices.drivers.ICashDrawerDriverService.Stub;Пример:public class MyDeviceService extends Service {    private final Map&lt;Integer, MyDevice&gt; instances = new HashMap&lt;&gt;();    private volatile AtomicInteger newDeviceIndex = new AtomicInteger(0);    @Nullable    @Override    public IBinder onBind(Intent intent) {        String action = intent.getAction();        switch (action) {            case Constants.INTENT_FILTER_DRIVER_MANAGER:                return new MyDriverManagerStub(MyDeviceService.this);            case Constants.INTENT_FILTER_CASHDRAWER:                return new MyCashDrawerStub(MyDeviceService.this);            default:                return null;        }    }    public int createNewDevice(UsbDevice usbDevice) {        int currentIndex = newDeviceIndex.getAndIncrement();        instances.put(currentIndex, new MyDevice(getApplicationContext(), usbDevice));        return currentIndex;    }    public MyDevice getMyDevice(int instanceId) {        return instances.get(instanceId);    }    public void destroy(int instanceId) {\t\tgetMyDevice(instanceId).destroy();        instances.remove(instanceId);    }}В этом же сервисе можно определить Map для хранения списка нескольких активных экземпляров драйверов, т.к. обращаться к нему придётся из всех указанных Stub’ов.Описание указанных Binder’овЕсли нельзя выполнить действие, используйте исключение (Exception) одного из следующих типов:  BadParcelableException;  IllegalArgumentException;  IllegalStateException;  NullPointerException;  SecurityException;  NetworkOnMainThreadException.Пример:throw new IllegalStateException();IUsbDriverManagerService.Stub – класс для управления драйверами usb-устройств: подключение и отключение устройств происходят здесь. Требуется реализовать методы addUsbDevice и destroy.import ru.evotor.devices.drivers.IUsbDriverManagerService;public class MyDriverManagerStub extends IUsbDriverManagerService.Stub {    private MyDeviceService myDeviceService;    public MyDriverManagerStub(MyDeviceService myDeviceService) {        this.myDeviceService = myDeviceService;    }    @Override    public int addUsbDevice(UsbDevice usbDevice, String usbPortPath) throws RemoteException {        return myDeviceService.createNewDevice(usbDevice);    }    @Override    public void destroy(int instanceId) throws RemoteException {        myDeviceService.destroy(instanceId);    }}Метод addUsbDevice в IUsbDriverManagerService принимает на вход:      UsbDevice, для которого он создан;        некоторый строковый идентификатор номера физического usb-порта для сохранения настроек оборудования и восстановления их после перезагрузки терминала. В этот момент у приложения-драйвера уже есть permission для работы с этим устройством.  Метод addUsbDevice возвращает номер экземпляра драйвера внутри приложения. По этому номеру будет происходить обращение к конкретному драйверу.Метод destroy в IUsbDriverManagerService принимает на вход номер экземпляра драйвера. Вызов этого метода уведомляет об отключении от устройства. В этот момент у приложения-драйвера уже нет permission для работы с этим устройством, само устройство уже может быть удалено из смарт-терминала.IVirtualDriverManagerService.Stub – класс для управления драйверами виртуальных устройств:подключение и отключение устройств происходят здесь. Требуется реализовать методы addNewVirtualDevice, recreateNewVirtualDevice и destroy.import ru.evotor.devices.drivers.IVirtualDriverManagerService;public class MyDriverManagerStub extends IVirtualDriverManagerService.Stub {    private MyDeviceService myDeviceService;    public MyDriverManagerStub(MyDeviceService myDeviceService) {        this.myDeviceService = myDeviceService;    }    @Override    public int addNewVirtualDevice() throws RemoteException {            return myDeviceService.createNewDevice(usbDevice);    }    @Override    public void recreateNewVirtualDevice(int instanceId) throws RemoteException {        myDeviceService.recreateNewVirtualDevice(instanceId);    }    @Override    public void destroy(int i) throws RemoteException {        myDeviceService.destroy(instanceId);    }}addNewVirtualDevice возвращает номер экземпляра драйвера внутри приложения. По этому номеру происходит обращение к конкретному драйверу.Метод recreateNewVirtualDevice принимает на вход номер экземпляра драйвера внутри приложения.Метод destroy принимает на вход номер экземпляра драйвера. Вызов этого метода уведомляет приложение об отключении от устройства.Для вновь созданного экземпляра драйвера (виртуальные устройства могут создаваться только вручную пользователем через меню настроек оборудования) будет вызван метод addNewVirtualDevice.Метод recreateNewVirtualDevice будет вызван для тех устройств, которые уже создавались пользователем ранее, но в данный момент подключения к таким драйверам нет. Например, после перезагрузки смарт-терминала, перезапуска сервиса работы с оборудованием или обновления приложения-драйвера.Метод destroy будет вызван для устройства, которое пользователь вручную удалил из списка оборудования.ICashDrawerDriverService.Stub – класс для работы с конкретными экземплярами денежных ящиков.public class MyCashDrawerStub extends ICashDrawerDriverService.Stub {    private MyDeviceService myDeviceService;    public MyCashDrawerStub(MyDeviceService myDeviceService) {        this.myDeviceService = myDeviceService;    }    @Override    public void openCashDrawer(int instanceId) throws RemoteException {        myDeviceService.getCashDrawer(instanceId).openCashDrawer();    }}Метод openCashDrawer принимает на вход номер экземпляра драйвера и открывает указанный денежный ящик.Описание класса для работы с оборудованиемПример для денежного ящика с USB-подключением:import ru.evotor.devices.drivers.cashdrawer.ICashDrawer;public class MyDevice implements ICashDrawer {    private Context context;    public MyDevice(Context context, UsbDevice usbDevice) {        super();        this.context = context;    }    @Override    public void openCashDrawer() {        //TODO Ваш код открытия денежного ящика    }}Для устройств других категорий реализуйте соответствующие интерфейсы:Весы – ru.evotor.devices.drivers.cashdrawer.IScales;Принтер ценников – ru.evotor.devices.drivers.priceprinter.IPricePrinter;Банковский терминал – ru.evotor.devices.drivers.paysystem.IPaySystem.Завершение работыЗагрузите приложение на смарт-терминал, чтобы работать с драйвером.",
        "url": "doc_drivers_cashdrawer.html",
        "product": ""
      }
      ,
      
    
          
      "doc-drivers-library-connection-html": {
        "title": "Подготовка к разработке",
        "tags": "[]",
        "content": "Для начала разработки подключите библиотеку для работы с оборудованием.Добавьте ссылку на репозиторий на репозиторий jitpack в build.gradle проекта.     allprojects {repositories {    jcenter()    maven { url 'https://jitpack.io' }    }}В модуле build.gradle добавьте зависимость и укажите точную версию:    dependencies {    compile 'com.github.evotor:device-drivers:v2.0.1+'    } Примечание: Все имена констант указаны из ru.evotor.devices.drivers.Constants.",
        "url": "doc_drivers_library_connection.html",
        "product": ""
      }
      ,
      
    
          
      "doc-drivers-other-html": {
        "title": "SDK для подключаемого USB-оборудования",
        "tags": "[]",
        "content": "Определение внешнего сервиса в AndroidManifest.xmlУкажите фильтр Intent filter: INTENT_FILTER_DRIVER_MANAGER.Пример объявленного сервиса:&lt;service    android:name=\"ru.mycompany.drivers.MyDeviceService\"    android:enabled=\"true\"    android:exported=\"true\"    android:icon=\"@drawable/logo\"    android:label=\"@string/service_name\"&gt;    &lt;intent-filter&gt;        &lt;action android:name=\"ru.evotor.devices.drivers.DriverManager\" /&gt;    &lt;/intent-filter&gt;    &lt;meta-data        android:name=\"vendor_name\"        android:value=\"SHTRIH-M\" /&gt;    &lt;meta-data        android:name=\"model_name\"        android:value=\"SHTRIH-T\" /&gt;    &lt;meta-data        android:name=\"usb_device\"        android:value=\"VID_1659PID_8963\" /&gt;    &lt;meta-data        android:name=\"settings_activity\"        android:value=\"\" /&gt;    &lt;meta-data        android:name=\"device_categories\"        android:value=\"OTHER\" /&gt;&lt;/service&gt;Где:vendor_name – наименование производителя, которое будет отображаться при подключении устройства.model_name – наименование модели устройства.INTENT_FILTER_DRIVER_MANAGER – используется для драйверов, требующих подключения USB-оборудования. Помимо Intent filter в meta-data необходимо указать характеристики VendorID и ProductID целевого устройства (десятичными числами):&lt;meta-data    android:name=\"usb_device\"    android:value=\"VID_1659PID_8963\" /&gt;Можно указать несколько устройств: VID_1659PID_8963|VID_123PID_456|VID_1659PID_8964.Экземпляр драйвера будет автоматически создан/удалён при подключении/отключении указанного оборудования к смарт-терминалу. При наличии нескольких подходящих драйверов, пользователю будет предложен выбор.Определение роли и категории устройстваЕсли ваше устройство не относится к заданным категориям, используйте Intent filter:INTENT_FILTER_OTHERВместе с этим необходимо указать в meta-data категорию устройства:&lt;meta-data    android:name=\"device_categories\"    android:value=\"OTHER\" /&gt;Только ваше приложение получит разрешение (permission) для работы с подключённым оборудованием. Совет: Можно указать сразу несколько ролей устройству: SCALES|PRICEPRINTER|CASHDRAWER|OTHER(весы | принтер чеков | денежный ящик | другое оборудование).Присвоение картинки для драйвераУкажите в манифесте приложения у сервиса:android:icon – картинка устройства, которая будет отображаться пользователю при инициализации устройства;android:label – имя драйвера, которое будет отображаться пользователю при инициализации устройстваМожно задать activity настроек:&lt;meta-data    android:name=\"settings_activity\"    android:value=\"ru.mycompany.drivers.MySettingsActivity\" /&gt;Указанная activity должна находиться в текущем package и будет вызвана при первом подключении устройства или при выборе устройства в меню настроек оборудования.Версия драйвера (versionCode и versionName) берётся из build.gradle:defaultConfig {    applicationId \"ru.mycompany.drivers.mydevice\"    minSdkVersion 22    targetSdkVersion 24    versionCode 2    versionName \"1.0.1\"} Важно: MinSdkVersion должна быть не выше версии 22.Подключение к сервису всех actionВ реализации метода подключения к сервису для всех action, указанных в интент-фильтрах укажите соответствующие Binder’ы:для INTENT_FILTER_DRIVER_MANAGER - класс наследник ru.evotor.devices.drivers.IUsbDriverManagerService.Stub;Пример:public class MyDeviceService extends Service {    private final Map&lt;Integer, MyDevice&gt; instances = new HashMap&lt;&gt;();    private volatile AtomicInteger newDeviceIndex = new AtomicInteger(0);    @Nullable    @Override    public IBinder onBind(Intent intent) {        String action = intent.getAction();        switch (action) {            case Constants.INTENT_FILTER_DRIVER_MANAGER:                return new MyDriverManagerStub(MyDeviceService.this);            default:                return null;        }    }    public int createNewDevice(UsbDevice usbDevice) {        int currentIndex = newDeviceIndex.getAndIncrement();        instances.put(currentIndex, new MyDevice(getApplicationContext(), usbDevice));        return currentIndex;    }    public MyDevice getMyDevice(int instanceId) {        return instances.get(instanceId);    }    public void destroy(int instanceId) {\t\tgetMyDevice(instanceId).destroy();        instances.remove(instanceId);    }}Описание указанных Binder’овЕсли нельзя выполнить действие, используйте исключение (Exception) одного из следующих типов:  BadParcelableException;  IllegalArgumentException;  IllegalStateException;  NullPointerException;  SecurityException;  NetworkOnMainThreadException.Пример:throw new IllegalStateException();IUsbDriverManagerService.Stub – класс для управления драйверами usb-устройств: подключение и отключение устройств происходят здесь. Требуется реализовать методы addUsbDevice и destroy.import ru.evotor.devices.drivers.IUsbDriverManagerService;public class MyDriverManagerStub extends IUsbDriverManagerService.Stub {    private MyDeviceService myDeviceService;    public MyDriverManagerStub(MyDeviceService myDeviceService) {        this.myDeviceService = myDeviceService;    }    @Override    public int addUsbDevice(UsbDevice usbDevice, String usbPortPath) throws RemoteException {        return myDeviceService.createNewDevice(usbDevice);    }    @Override    public void destroy(int instanceId) throws RemoteException {        myDeviceService.destroy(instanceId);    }}Метод addUsbDevice в IUsbDriverManagerService принимает на вход:      UsbDevice, для которого он создан;        некоторый строковый идентификатор номера физического usb-порта для сохранения настроек оборудования и восстановления их после перезагрузки терминала. В этот момент у приложения-драйвера уже есть permission для работы с этим устройством.  Метод addUsbDevice возвращает номер экземпляра драйвера внутри приложения. По этому номеру будет происходить обращение к конкретному драйверу.Метод destroy в IUsbDriverManagerService принимает на вход номер экземпляра драйвера. Вызов этого метода уведомляет об отключении от устройства. В этот момент у приложения-драйвера уже нет permission для работы с этим устройством, само устройство уже может быть удалено из смарт-терминала.Завершение работыЗагрузите приложение на смарт-терминал, чтобы работать с драйвером.",
        "url": "doc_drivers_other.html",
        "product": ""
      }
      ,
      
    
          
      "doc-drivers-pinpads-html": {
        "title": "SDK для банковский терминалов",
        "tags": "[]",
        "content": "Определение внешнего сервиса в AndroidManifest.xmlУкажите хотя бы один Intent filter: INTENT_FILTER_DRIVER_MANAGER или INTENT_FILTER_VIRTUAL_DRIVER_MANAGER.Пример объявленного сервиса:&lt;service      android:name=\"ru.mycompany.drivers.MyPaySystemService\"      android:enabled=\"true\"      android:exported=\"true\"      android:icon=\"@drawable/logo\"      android:label=\"@string/service_name\"&gt;            &lt;intent-filter&gt;                &lt;action android:name=\"ru.evotor.devices.drivers.DriverManager\" /&gt;                &lt;action android:name=\"ru.evotor.devices.drivers.PaySystemService\" /&gt;            &lt;/intent-filter&gt;            &lt;meta-data                android:name=\"vendor_name\"                android:value=\"Ingenico\" /&gt;            &lt;meta-data                android:name=\"model_name\"                android:value=\"IPP320\" /&gt;            &lt;meta-data                android:name=\"usb_device\"                android:value=\"VID_1947PID_40\" /&gt;            &lt;meta-data                android:name=\"virtual_device\"                android:value=\"false\" /&gt;            &lt;meta-data                android:name=\"settings_activity\"                android:value=\"\" /&gt;            &lt;meta-data                android:name=\"device_categories\"                android:value=\"PAYSYSTEM\" /&gt;        &lt;/service&gt;Где:vendor_name – наименование производителя, которое будет отображаться при подключении устройства.model_name – наименование модели устройства.INTENT_FILTER_DRIVER_MANAGER - используется для драйверов, требующих подключения USB- оборудования. Помимо Intent filter в meta-data необходимо указать характеристики VendorID и ProductID целевого устройства (десятичными числами):&lt;meta-data    android:name=\"usb_device\"    android:value=\"VID_1659PID_8963\" /&gt; Совет: Можно указать несколько устройств: VID_1659PID_8963|VID_123PID_456|VID_1659PID_8964.Экземпляр драйвера будет автоматически создан/удалён при подключении/отключении указанного оборудования к смарт-терминалу. При наличии нескольких подходящих драйверов, пользователю будет предложен выбор.INTENT_FILTER_VIRTUAL_DRIVER_MANAGER– используется для драйверов, не требующих подключения USB-оборудования (сетевое, bluetooth и др.). В meta-data необходимо указать, что драйвер является виртуальным:&lt;meta-data    android:name=\"virtual_device\"    android:value=\"true\" /&gt;Экземпляр такого драйвера пользователь может создать исключительно вручную через настройки оборудования. В этом случае, все работы по подключению к нужному устройству берёт на себя производитель драйвера.Определение роли и категории устройстваЧтобы устройство было распознано как банковский терминал, используйте Intent filter:INTENT_FILTER_PAY_SYSTEMВместе с этим необходимо указать в meta-data категорию устройства:&lt;meta-data    android:name=\"device_categories\"    android:value=\"PAYSYSTEM\" /&gt; Совет: Можно указать сразу несколько ролей устройству: SCALES|PRICEPRINTER|CASHDRAWER|OTHER(весы | принтер чеков | денежный ящик | другое оборудование).Присвоение картинки для драйвераУкажите в манифесте приложения у сервиса:android:icon – картинка устройства, которая будет отображаться пользователю при инициализации устройства;android:label – имя драйвера, которое будет отображаться пользователю при инициализации устройстваПример отображения иконки и имени драйвераМожно задать activity настроек:&lt;meta-data    android:name=\"settings_activity\"    android:value=\"ru.mycompany.drivers.MySettingsActivity\" /&gt;Указанная activity должна находиться в текущем package и будет вызвана при первом подключении устройства или при выборе устройства в меню настроек оборудования.Версия драйвера (versionCode и versionName) берётся из build.gradle:defaultConfig {    applicationId \"ru.mycompany.drivers.mypaysystem\"    minSdkVersion 22    targetSdkVersion 24    versionCode 2    versionName \"1.0.1\"} Важно: MinSdkVersion должна быть не выше версии 22.Подключение к сервису всех actionВ реализации метода подключения к сервису для всех action, указанных в интент-фильтрах укажите соответствующие Binder’ы:для INTENT_FILTER_DRIVER_MANAGER – класс наследник ru.evotor.devices.drivers.IUsbDriverManagerService.Stub;для INTENT_FILTER_VIRTUAL_DRIVER_MANAGER – класс наследник ru.evotor.devices.drivers.IVirtualDriverManagerService.Stub;для INTENT_FILTER_PAY_SYSTEM – класс наследник ru.evotor.devices.drivers.IPaySystemDriverService.Stub;Пример:public class MyDeviceService extends Service {    private final Map&lt;Integer, MyDevice&gt; instances = new HashMap&lt;&gt;();    private volatile AtomicInteger newDeviceIndex = new AtomicInteger(0);    @Nullable    @Override    public IBinder onBind(Intent intent) {        String action = intent.getAction();        switch (action) {            case Constants.INTENT_FILTER_DRIVER_MANAGER:                return new MyDriverManagerStub(MyDeviceService.this);            case Constants.INTENT_FILTER_PAY_SYSTEM:                return new MyScalesStub(MyDeviceService.this);            default:                return null;        }    }    public int createNewDevice(UsbDevice usbDevice) {        int currentIndex = newDeviceIndex.getAndIncrement();        instances.put(currentIndex, new MyDevice(getApplicationContext(), usbDevice));        return currentIndex;    }    public MyDevice getMyDevice(int instanceId) {        return instances.get(instanceId);    }    public void destroy(int instanceId) {\t\tgetMyDevice(instanceId).destroy();        instances.remove(instanceId);    }}В этом же сервисе можно определить Map для хранения списка нескольких активных экземпляров драйверов, т.к. обращаться к нему придётся из всех указанных Stub’ов.Описание указанных Binder’овЕсли нельзя выполнить действие, используйте исключение (Exception) одного из следующих типов:  BadParcelableException;  IllegalArgumentException;  IllegalStateException;  NullPointerException;  SecurityException;  NetworkOnMainThreadException.Пример:throw new IllegalStateException();IUsbDriverManagerService.Stub – класс для управления драйверами usb-устройств: подключение и отключение устройств происходят здесь. Требуется реализовать методы addUsbDevice и destroy.import ru.evotor.devices.drivers.IUsbDriverManagerService;public class MyDriverManagerStub extends IUsbDriverManagerService.Stub {    private MyDeviceService myDeviceService;    public MyDriverManagerStub(MyDeviceService myDeviceService) {        this.myDeviceService = myDeviceService;    }    @Override    public int addUsbDevice(UsbDevice usbDevice, String usbPortPath) throws RemoteException {        return myDeviceService.createNewDevice(usbDevice);    }    @Override    public void destroy(int instanceId) throws RemoteException {        myDeviceService.destroy(instanceId);    }}Метод addUsbDevice в IUsbDriverManagerService принимает на вход:      UsbDevice, для которого он создан;        некоторый строковый идентификатор номера физического usb-порта для сохранения настроек оборудования и восстановления их после перезагрузки терминала. В этот момент у приложения-драйвера уже есть permission для работы с этим устройством.  Метод addUsbDevice возвращает номер экземпляра драйвера внутри приложения. По этому номеру будет происходить обращение к конкретному драйверу.Метод destroy в IUsbDriverManagerService принимает на вход номер экземпляра драйвера. Вызов этого метода уведомляет об отключении от устройства. В этот момент у приложения-драйвера уже нет permission для работы с этим устройством, само устройство уже может быть удалено из смарт-терминала.IVirtualDriverManagerService.Stub – класс для управления драйверами виртуальных устройств:подключение и отключение устройств происходят здесь. Требуется реализовать методы addNewVirtualDevice, recreateNewVirtualDevice и destroy.import ru.evotor.devices.drivers.IVirtualDriverManagerService;public class MyDriverManagerStub extends IVirtualDriverManagerService.Stub {    private MyDeviceService myDeviceService;    public MyDriverManagerStub(MyDeviceService myDeviceService) {        this.myDeviceService = myDeviceService;    }    @Override    public int addNewVirtualDevice() throws RemoteException {            return myDeviceService.createNewDevice(usbDevice);    }    @Override    public void recreateNewVirtualDevice(int instanceId) throws RemoteException {        myDeviceService.recreateNewVirtualDevice(instanceId);    }    @Override    public void destroy(int i) throws RemoteException {        myDeviceService.destroy(instanceId);    }}addNewVirtualDevice возвращает номер экземпляра драйвера внутри приложения. По этому номеру будет происходить обращение к конкретному драйверу.Метод recreateNewVirtualDevice принимает на вход номер экземпляра драйвера внутри приложения.Метод destroy принимает на вход номер экземпляра драйвера. Вызов этого метода уведомляет приложение об отключении от устройства.Для вновь созданного экземпляра драйвера (а виртуальные устройства могут создаваться только вручную пользователем через меню настроек оборудования) будет вызван метод addNewVirtualDevice.Метод recreateNewVirtualDevice будет вызван для тех устройств, которые уже создавались пользователем ранее, но в данный момент подключения к таким драйверам нет. Например, после перезагрузки смарт-терминала, перезапуска сервиса работы с оборудованием или обновления приложения-драйвера.Метод destroy будет вызван для устройства, которое пользователь вручную удалил из списка оборудования.IPaySystemDriverService.Stub – класс для работы с конкретными экземплярами банковских терминалов.import ru.evotor.devices.drivers.IPaySystemDriverService;import ru.evotor.devices.drivers.paysystem.PayResult;import ru.evotor.devices.drivers.paysystem.PayInfo;public class MyPaySystemStub extends IPaySystemDriverService.Stub {    private MyPaySystemService paySystemService;    public MyPaySystemStub(MyPaySystemService paySystemService) {        this.paySystemService = paySystemService;    }    @Override    public PayResult payment(int instanceId, PayInfo payInfo) throws RemoteException {        return paySystemService.getPaySystem(instanceId).payment(payInfo);    }    @Override    public PayResult cancelPayment(int instanceId, PayInfo payInfo, String rrn) throws RemoteException {        return paySystemService.getPaySystem(instanceId).cancelPayment(payInfo, rrn);    }    @Override    public PayResult payback(int instanceId, PayInfo payInfo, String rrn) throws RemoteException {        return paySystemService.getPaySystem(instanceId).payback(payInfo, rrn);    }    @Override    public PayResult cancelPayback(int instanceId, PayInfo payInfo, String rrn) throws RemoteException {        return paySystemService.getPaySystem(instanceId).cancelPayback(payInfo, rrn);    }    @Override    public PayResult closeSession(int instanceId) throws RemoteException {        return paySystemService.getPaySystem(instanceId).closeSession();    }    @Override    public void openServiceMenu(int instanceId) throws RemoteException {        paySystemService.getPaySystem(instanceId).openServiceMenu();    }    @Override    public String getBankName(int instanceId) throws RemoteException {        return paySystemService.getPaySystem(instanceId).getBankName();    }    @Override    public int getTerminalNumber(int instanceId) throws RemoteException {        return paySystemService.getPaySystem(instanceId).getTerminalNumber();    }    @Override    public String getTerminalID(int instanceId) throws RemoteException {        return paySystemService.getPaySystem(instanceId).getTerminalID();    }    @Override    public String getMerchNumber(int instanceId) throws RemoteException {        return paySystemService.getPaySystem(instanceId).getMerchEngName();    }    @Override    public String getMerchCategoryCode(int instanceId) throws RemoteException {        return paySystemService.getPaySystem(instanceId).getMerchCategoryCode();    }    @Override    public String getMerchEngName(int instanceId) throws RemoteException {        return paySystemService.getPaySystem(instanceId).getMerchEngName();    }    @Override    public String getCashier(int instanceId) throws RemoteException {        return paySystemService.getPaySystem(instanceId).getCashier();    }    @Override    public String getServerIP(int instanceId) throws RemoteException {        return paySystemService.getPaySystem(instanceId).getServerIP();    }    @Override    public boolean isNotNeedRRN(int instanceId) throws RemoteException {        return paySystemService.getPaySystem(instanceId).isNotNeedRRN();    }}Все методы принимают на вход номер экземпляра драйвера.Метод оплаты принимает на вход информацию об оплате (сумму), методы возврата и отмены дополнительно к этому принимают на вход РРН прошлой операции.Описание класса для работы с оборудованиемПример для банковских терминалов, работающих через USB:public class MyDevice implements IPaySystem {    @Override    public PayResult payment(PayInfo payInfo) {        //TODO Ваш код    }    @Override    public PayResult cancelPayment(PayInfo payInfo, String s) {        //TODO Ваш код    }    @Override    public PayResult payback(PayInfo payInfo, String s) {        //TODO Ваш код    }    @Override    public PayResult cancelPayback(PayInfo payInfo, String s) {        //TODO Ваш код    }    @Override    public PayResult closeSession() {        //TODO Ваш код    }    @Override    public void openServiceMenu() {        //TODO Ваш код    }    @Override    public String getBankName() {        //TODO Ваш код    }    @Override    public int getTerminalNumber() {        //TODO Ваш код    }    @Override    public String getTerminalID() {        //TODO Ваш код    }    @Override    public String getMerchNumber() {        //TODO Ваш код    }    @Override    public String getMerchCategoryCode() {        //TODO Ваш код    }    @Override    public String getMerchEngName() {        //TODO Ваш код    }    @Override    public String getCashier() {        //TODO Ваш код    }    @Override    public String getServerIP() {        //TODO Ваш код    }    @Override    public boolean isNotNeedRRN() {        //TODO Ваш код    }}Для устройств других категорий реализуйте соответствующие интерфейсы.Завершение работыЗагрузите приложение на смарт-терминал, чтобы работать с драйвером.",
        "url": "doc_drivers_pinpads.html",
        "product": ""
      }
      ,
      
    
          
      "doc-drivers-scales-html": {
        "title": "SDK для весов",
        "tags": "[]",
        "content": "Определение внешнего сервиса в AndroidManifest.xmlУкажите хотя бы один Intent filter: INTENT_FILTER_DRIVER_MANAGER или INTENT_FILTER_VIRTUAL_DRIVER_MANAGER.Пример объявленного сервиса:&lt;service    android:name=\"ru.mycompany.drivers.MyDeviceService\"    android:enabled=\"true\"    android:exported=\"true\"    android:icon=\"@drawable/logo\"    android:label=\"@string/service_name\"&gt;    &lt;intent-filter&gt;        &lt;action android:name=\"ru.evotor.devices.drivers.DriverManager\" /&gt;        &lt;action android:name=\"ru.evotor.devices.drivers.ScalesService\" /&gt;    &lt;/intent-filter&gt;    &lt;meta-data        android:name=\"vendor_name\"        android:value=\"CAS\" /&gt;    &lt;meta-data        android:name=\"model_name\"        android:value=\"AD\" /&gt;    &lt;meta-data        android:name=\"usb_device\"        android:value=\"VID_1659PID_8963\" /&gt;    &lt;meta-data        android:name=\"settings_activity\"        android:value=\"\" /&gt;    &lt;meta-data        android:name=\"device_categories\"        android:value=\"SCALES\" /&gt;&lt;/service&gt;Где:vendor_name – наименование производителя, которое будет отображаться при подключении устройства.model_name – наименование модели устройства.INTENT_FILTER_DRIVER_MANAGER – используется для драйверов, требующих подключения USB-оборудования. Помимо Intent filter в meta-data необходимо указать характеристики VendorID и ProductID целевого устройства (десятичными числами):&lt;meta-data    android:name=\"usb_device\"    android:value=\"VID_1659PID_8963\" /&gt;Можно указать несколько устройств: VID_1659PID_8963|VID_123PID_456|VID_1659PID_8964.Экземпляр драйвера будет автоматически создан/удалён при подключении/отключении указанного оборудования к смарт-терминалу. При наличии нескольких подходящих драйверов, пользователю будет предложен выбор.INTENT_FILTER_VIRTUAL_DRIVER_MANAGER – используется для драйверов, не требующих подключения USB-оборудования (сетевое, bluetooth и др.). В meta-data необходимо указать, что драйвер является виртуальным:&lt;meta-data    android:name=\"virtual_device\"    android:value=\"true\" /&gt;Экземпляр такого драйвера пользователь может создать исключительно вручную через настройки оборудования. В этом случае, все работы по подключению к нужному устройству берёт на себя производитель драйвера.Определение роли и категории устройстваЧтобы устройство было распознано как весы, используйте Intent filter:INTENT_FILTER_SCALESВместе с этим необходимо указать в meta-data категорию устройства:&lt;meta-data    android:name=\"device_categories\"    android:value=\"SCALES\" /&gt; Совет: Можно указать сразу несколько ролей устройству: SCALES|PRICEPRINTER|CASHDRAWER|OTHER(весы | принтер чеков | денежный ящик | другое оборудование).Присвоение картинки для драйвераУкажите в манифесте приложения у сервиса:android:icon – картинка устройства, которая будет отображаться пользователю при инициализации устройства;android:label – имя драйвера, которое будет отображаться пользователю при инициализации устройстваПример отображения иконки и имени драйвераМожно задать activity настроек:&lt;meta-data    android:name=\"settings_activity\"    android:value=\"ru.mycompany.drivers.MySettingsActivity\" /&gt;Указанная activity должна находиться в текущем package и будет вызвана при первом подключении устройства или при выборе устройства в меню настроек оборудования.Версия драйвера (versionCode и versionName) берётся из build.gradle:defaultConfig {    applicationId \"ru.mycompany.drivers.myscales\"    minSdkVersion 22    targetSdkVersion 24    versionCode 2    versionName \"1.0.1\"} Важно: MinSdkVersion должна быть не выше версии 22.Подключение к сервису всех actionВ реализации метода подключения к сервису для всех action, указанных в интент-фильтрах укажите соответствующие Binder’ы:для INTENT_FILTER_DRIVER_MANAGER - класс наследник ru.evotor.devices.drivers.IUsbDriverManagerService.Stub;для INTENT_FILTER_VIRTUAL_DRIVER_MANAGER - класс наследник ru.evotor.devices.drivers.IVirtualDriverManagerService.Stub;для INTENT_FILTER_SCALES - класс наследник ru.evotor.devices.drivers.IScalesDriverService.Stub;Пример:public class MyDeviceService extends Service {    private final Map&lt;Integer, MyDevice&gt; instances = new HashMap&lt;&gt;();    private volatile AtomicInteger newDeviceIndex = new AtomicInteger(0);    @Nullable    @Override    public IBinder onBind(Intent intent) {        String action = intent.getAction();        switch (action) {            case Constants.INTENT_FILTER_DRIVER_MANAGER:                return new MyDriverManagerStub(MyDeviceService.this);            case Constants.INTENT_FILTER_SCALES:                return new MyScalesStub(MyDeviceService.this);            default:                return null;        }    }    public int createNewDevice(UsbDevice usbDevice) {        int currentIndex = newDeviceIndex.getAndIncrement();        instances.put(currentIndex, new MyDevice(getApplicationContext(), usbDevice));        return currentIndex;    }    public MyDevice getMyDevice(int instanceId) {        return instances.get(instanceId);    }    public void destroy(int instanceId) {\t\tgetMyDevice(instanceId).destroy();        instances.remove(instanceId);    }}В этом же сервисе можно определить Map для хранения списка нескольких активных экземпляров драйверов, т.к. обращаться к нему придётся из всех указанных Stub’ов.Описание указанных Binder’овЕсли нельзя выполнить действие, например, взвесить для метода getWeight,  используйте исключение (Exception) одного из следующих типов:  BadParcelableException;  IllegalArgumentException;  IllegalStateException;  NullPointerException;  SecurityException;  NetworkOnMainThreadException.Пример:throw new IllegalStateException();IUsbDriverManagerService.Stub – класс для управления драйверами usb-устройств: подключение и отключение устройств происходят здесь. Требуется реализовать методы addUsbDevice и destroy.import ru.evotor.devices.drivers.IUsbDriverManagerService;public class MyDriverManagerStub extends IUsbDriverManagerService.Stub {    private MyDeviceService myDeviceService;    public MyDriverManagerStub(MyDeviceService myDeviceService) {        this.myDeviceService = myDeviceService;    }    @Override    public int addUsbDevice(UsbDevice usbDevice, String usbPortPath) throws RemoteException {        return myDeviceService.createNewDevice(usbDevice);    }    @Override    public void destroy(int instanceId) throws RemoteException {        myDeviceService.destroy(instanceId);    }}Метод addUsbDevice в IUsbDriverManagerService принимает на вход:      UsbDevice, для которого он создан;        некоторый строковый идентификатор номера физического usb-порта для сохранения настроек оборудования и восстановления их после перезагрузки терминала. В этот момент у приложения-драйвера уже есть permission для работы с этим устройством.  Метод addUsbDevice возвращает номер экземпляра драйвера внутри приложения. По этому номеру будет происходить обращение к конкретному драйверу.Метод destroy в IUsbDriverManagerService принимает на вход номер экземпляра драйвера. Вызов этого метода уведомляет об отключении от устройства. В этот момент у приложения-драйвера уже нет permission для работы с этим устройством, само устройство уже может быть удалено из смарт-терминала.IVirtualDriverManagerService.Stub - класс для управления драйверами виртуальных устройств:подключение и отключение устройств происходят здесь. Требуется реализовать методы addNewVirtualDevice, recreateNewVirtualDevice и destroy.import ru.evotor.devices.drivers.IVirtualDriverManagerService;public class MyDriverManagerStub extends IVirtualDriverManagerService.Stub {    private MyDeviceService myDeviceService;    public MyDriverManagerStub(MyDeviceService myDeviceService) {        this.myDeviceService = myDeviceService;    }    @Override    public int addNewVirtualDevice() throws RemoteException {            return myDeviceService.createNewDevice(usbDevice);    }    @Override    public void recreateNewVirtualDevice(int instanceId) throws RemoteException {        myDeviceService.recreateNewVirtualDevice(instanceId);    }    @Override    public void destroy(int i) throws RemoteException {        myDeviceService.destroy(instanceId);    }}addNewVirtualDevice возвращает номер экземпляра драйвера внутри приложения. По этому номеру будет происходить обращение к конкретному драйверу.Метод recreateNewVirtualDevice принимает на вход номер экземпляра драйвера внутри приложения.Метод destroy принимает на вход номер экземпляра драйвера. Вызов этого метода уведомляет приложение об отключении от устройства.Для вновь созданного экземпляра драйвера (а виртуальные устройства могут создаваться только вручную пользователем через меню настроек оборудования) будет вызван метод addNewVirtualDevice.Метод recreateNewVirtualDevice будет вызван для тех устройств, которые уже создавались пользователем ранее, но в данный момент подключения к таким драйверам нет. Например, после перезагрузки смарт-терминала, перезапуска сервиса работы с оборудованием или обновления приложения-драйвера.Метод destroy будет вызван для устройства, которое пользователь вручную удалил из списка оборудования.IScalesDriverService.Stub – класс для работы с конкретными экземплярами весов. Требуется реализовать метод getWeight.import ru.evotor.devices.drivers.IScalesDriverService;import ru.evotor.devices.drivers.scales.Weight;public class MyScalesStub extends IScalesDriverService.Stub {    private MyDeviceService myDeviceService;    public MyScalesStub(MyDeviceService myDeviceService) {        this.myDeviceService = myDeviceService;    }    @Override    public Weight getWeight(int instanceId) throws RemoteException {        return myDeviceService.getMyDevice(instanceId).getWeight();    }}Метод getWeight принимает на вход номер экземпляра драйвера (тот, который вернул addUsbDevice на прошлом шаге).Метод getWeight возвращает объект класса ru.evotor.devices.drivers.scales.Weight.В конструкторе требуется указать:      originalWeight – вес, в единицах измерения весов;        multiplierToGrams – коэффициент для приведения веса в граммы;        supportStable – поддерживают ли весы флаг стабильности;        stable – флаг стабильности взвешивания, если поддерживается. Иначе - любое значение.  Все методы принимают на вход номер экземпляра драйвера.Описание класса для работы с оборудованиемПример для USB-весов:import ru.evotor.devices.drivers.scales.IScales;import ru.evotor.devices.drivers.scales.Weight;public class MyDevice implements IScales {    private Context context;    private UsbDevice usbDevice;    public MyDevice(Context context, UsbDevice usbDevice) {        super();        this.context = context;        this.usbDevice = usbDevice;    }\tpublic void destroy(){\t}    @Override    public Weight getWeight() {        //TODO Ваш код запроса веса    }}Для устройств других категорий реализуйте соответствующие интерфейсы:Денежный ящик – ru.evotor.devices.drivers.cashdrawer.ICashDrawer;Принтер ценников – ru.evotor.devices.drivers.priceprinter.IPricePrinter;Банковский терминал – ru.evotor.devices.drivers.paysystem.IPaySystem.Завершение работыЗагрузите приложение на смарт-терминал, чтобы работать с драйвером.",
        "url": "doc_drivers_scales.html",
        "product": ""
      }
      ,
      
    
          
      "doc-egais-clientsettingsquery-html": {
        "title": "Получение параметров пользователя из УТМ",
        "tags": "[]",
        "content": "Для получения параметров пользователя из УТМ в egais-api реализован класс ClientSettingsQuery. С помощью метода класса вы можете получить FSRAR ID.Получение FSRAR IDFSRAR ID – уникальный идентификатор организации в ФСРАР. FSRAR ID хранится в УТМ и необходим для всех документов, которые УТМ передаёт в ЕГАИС.Ваше приложение может получить идентификатор с помощью метода getFsRarId.Для этого вы можете создать операцию, которая реализует метод.Ниже приводится пример операции, которая выводит FSRAR ID на экран смарт-терминала.  Java  Kotlin    private fun getFsRarId() {        val fsRarId = ClientSettingsQuery().getFsRarId(this)        //Выведите FSRAR ID на экран смарт-терминала.        Toast.makeText(this, \"fsrarid = \\\"$fsRarId\\\"\", Toast.LENGTH_SHORT).show()    }    private void getFsRarId(){        String fsRarId = new ClientSettingsQuery().getFsRarId(this);        //Выведите FSRAR ID на экран смарт-терминала.        Toast.makeText(this, \"FSRAR ID = \" + fsRarId, Toast.LENGTH_SHORT).show();    }Пример в демонстрационном приложенииПример реализации метода getFsRarId в демонстрационном приложении.",
        "url": "doc_egais_clientsettingsquery.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-egais-data-reading-access-html": {
        "title": "Получение данных из ЕГАИС",
        "tags": "[]",
        "content": "С помощью egais-api ваше приложение может получать данные из ЕГАИС.Получение необходимых данных осуществляется с помощью запросов к базе данных смарт-терминала.В таблице ниже представленны классы запросов к egais-api, а также соответствующие им классы данных, поля которых вы можете использовать для фильтрации выдачи запросов.            Класс запроса      Класс данных      Описание                  ActChargeOnShopPositionQuery.kt      ActChargeOnShopPosition      Позиция в акте постановки на баланс              ActChargeOnShopQuery.kt      ActChargeOnShop      Акт постановки на баланс в торговый зал              ActWriteOffPositionQuery.kt      ActWriteOffPosition      Позиция в акте списания со склада              ActWriteOffQuery.kt      ActWriteOff      Акт списания со склада              ActWriteOffShopPositionQuery.kt      ActWriteOffShopPosition      Позиция в акте списания из магазина              ActWriteOffShopQuery.kt      ActWriteOffShop      Акт списания из магазина              ClientSettingsQuery.kt             Параметры клиента в УТМ              ConfirmTicketQuery.kt      ConfirmTicket      Квитанция подтверждения на акт разногласия к товарно-транспортной накладной              CursorExt.kt                           FieldNameExt.kt                           OrgInfoQuery.kt      OrgInfo      Информация о контрагенте              ProductInfoFilter.kt                           ProductInfoQuery.kt      ProductInfo      Информация о продукции ЕГАИС              ProductRestQuery.kt      ProductRest      Общая загрегированная информация об остатках продукции (включая количество) на складе и в магазине              ShopCommodityQuery.kt      ShopCommodity      Остатки продукции в магазине              StockCommodityQuery.kt      StockCommodity      Остатки продукции на складе              TicketQuery.kt      Ticket      Квитанция              TransferFromShopPositionQuery.kt      TransferFromShopPosition                     TransferFromShopQuery.kt      TransferFromShop      Акт передачи продукции из торгового зала на склад              TransferToShopPositionQuery.kt      TransferToShopPosition                     TransferToShopQuery.kt      TransferToShop      Акт передачи продукции со склада в торговый зал              TtnInformF2RegPositionQuery.kt      TtnInformF2RegPosition      Позиция в справке 2              TtnInformF2RegQuery.kt      TtnInformF2Reg      Справка 2 к ТТН              WayBillActPositionMarkQuery.kt      WayBillActPositionMark      Марка позиций акта ТТН              WayBillActPositionQuery.kt      WayBillActPosition      Позиция акта расхождения с товарно-транспортной накладной              WayBillActQuery.kt      WayBillAct      Акт расхождения с товарно-транспортной накладной              WayBillPositionMarkQuery.kt      WayBillPositionMark      Марка позиций ТТН              WayBillPositionQuery.kt      WayBillPosition      Позиция в товарно-транспортной накладной (ТТН)              WayBillQuery.kt      WayBill      Товарно-транспортная накладная      ПримерПример приложения, которое получает данные ЕГАИС с помощью запросов к базе данных смарт-терминала.",
        "url": "doc_egais_data_reading_access.html",
        "product": ""
      }
      ,
      
    
          
      "doc-egais-project-creation-html": {
        "title": "Подготовка проекта для работы с egais-api",
        "tags": "[]",
        "content": "Чтобы подготовить проект для работы с egais-api:      Создайте проект в Android Studio.    Минимальная версия SDK проекта должна быть 22. При создании проекта выберите No Activitty.     Совет: Подробную информацию о том, как создать новый проект в Android Studio смотрите на сайте developer.android.com        В файле build.gradle проекта:    allprojects { repositories {     google()     jcenter()     maven { url 'https://jitpack.io' }    }}            В файле build.gradle приложения (папка app), в зависимости подключите библиотеку egais-api:    implementation 'com.github.evotor:egais-api:ebe58e1a79'            В файле AndroidManifest.xml, в секции application укажите элемент meta-data, содержащий идентификатор приложения:    &lt;meta-data         android:name=\"app_uuid\"         android:value=\"&lt;Идентификатор приложения&gt;\" /&gt;         Примечание: Идентификатор приложения вы можете скопировать на странице приложения на сайте разработчиков.        Убедитесь, что PackageName приложения совпадает с указанным на сайте разработчиков, это необходимо для установки приложения на смарт-терминал.  ",
        "url": "doc_egais_project_creation.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-app-icon-html": {
        "title": "Вызов приложения из интерфейса смарт-терминала",
        "tags": "[]",
        "content": "Вы можете запустить своё приложение по иконке, расположенной на одном из экранов смарт-терминала:  на главном экране;  на экране продажи;  на экране возврата.Вы можете запускать приложение с помощью иконки на главном экране смарт-терминала или с помощью иконок на экране продажи и/или возврата товараВы можете интегрировать своё приложение в существующий процесс смарт-терминала, например, продажу или работу с оборудованием, или добавить иконку приложения на главный экран. Плиток может быть несколько, если приложение реализует независимые действия, например, иконки “Продать товар” и “Вернуть товар”.Рекомендации по добавлению иконкиДобавляйте иконку если:  у приложения есть свой интерфейс;  приложение реализует полезное действие и / или предоставляет сотруднику магазина доступ к аналитической информации.Вы можете изменять следующие параметры иконки:      Цвет. Может быть любым, пока на его фоне отчётливо отображаются символы и иконка.     Совет: Как правило цвет иконки делают таким же как и цвет основных кнопок в интерфейсе приложения.        Название. Может быть названием приложения или полезного действия, например, “Продажи за неделю”. Плитка отображает до 20 символов. Остальные символы скрываются многоточием.        Иконка. Иконка должна быть квадратной – 64 dp. Требуется обеспечить набор иконок в трёх разрешениях: 96, 192, 256px.  Иконка приложения на главном экране смарт-терминалаЧтобы добавить иконку приложения на главный экран смарт-терминала:В манифесте приложения, измените секцию требуемой операции следующим образом:&lt;activity  android:name=\".&lt;НазваниеОперации&gt;\"  android:icon=\"@mipmap/ic_launcher\"  android:label=\"Example tile\"  &gt;  &lt;meta-data      android:name=\"ru.evotor.launcher.BACKGROUND_COLOR\"      android:value=\"#133788\" /&gt;  &lt;intent-filter&gt;      &lt;action android:name=\"android.intent.action.MAIN\" /&gt;      &lt;category android:name=\"android.intent.category.EVOTOR\" /&gt;  &lt;/intent-filter&gt;&lt;/activity&gt;Где:Атрибут android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\" задаёт фон, на котором отображается иконка приложения.Элемент &lt;action android:name=\"android.intent.action.MAIN\" /&gt; указывает, что иконка приложения будет отображаться на главном экране смарт-терминала.Приложение на главном экране смарт-терминалаИконка приложения на экране оплатыЧтобы добавить иконку приложения на экран оплаты смарт-терминала:      В созданном приложении создайте службу (service).    Для этого, в Android Studio, в проекте выберите app и выполните следующие действия: File → New → Service → Service (IntentService).    Добавленная служба автоматически объявится в манифесте приложения:    &lt;service    android:name=\".&lt;Имя службы&gt;\"    android:exported=\"false\"&gt;&lt;/service&gt;            В манифесте приложения, измените секцию добавленной службы следующим образом:    &lt;service android:name=\".&lt;Имя службы&gt;\" android:icon=\"@mipmap/ic_launcher_round\" android:label=\"Hello world\"&gt; &lt;meta-data     android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\"     android:value=\"#133788\" /&gt; &lt;intent-filter android:priority=\"20\"&gt;     &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;     &lt;action android:name=\"evo.v2.receipt.sell.receiptDiscount\" /&gt; &lt;/intent-filter&gt; &lt;/service&gt;        Где:    Атрибут android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\" задаёт фон, на котором отображается иконка приложения.    Элемент &lt;action android:name=\"evo.v2.receipt.sell.receiptDiscount\" /&gt; сообщает приложению где отображать иконку.     Совет: Чтобы добавить иконку приложения на экран возврата товара, используйте элемент &lt;action android:name=\"evo.v2.receipt.payback.receiptDiscount\" /&gt;.  Итоговый манифест приложения, иконки которого отображаются как на главном экране, так и на экране оплаты выглядит так:&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"com.example.yourprojectname\"&gt;    &lt;application        android:allowBackup=\"true\"        android:icon=\"@mipmap/ic_launcher\"        android:label=\"@string/app_name\"        android:roundIcon=\"@mipmap/ic_launcher_round\"        android:supportsRtl=\"true\"        android:theme=\"@style/AppTheme\"&gt;        &lt;activity            android:name=\".&lt;Имя операции&gt;\"            android:icon=\"@mipmap/ic_launcher_round\"            android:label=\"Hello world\"            android:theme=\"@style/AppTheme.NoActionBar\"&gt;            &lt;meta-data                android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\"                android:value=\"#133788\" /&gt;            &lt;intent-filter&gt;                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;                &lt;category android:name=\"android.intent.category.EVOTOR\" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;service            android:name=\".&lt;Имя службы&gt;\"            android:icon=\"@mipmap/ic_launcher_round\"            android:label=\"Hello world\"&gt;            &lt;meta-data                android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\"                android:value=\"#133788\" /&gt;            &lt;intent-filter android:priority=\"20\"&gt;                &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;                &lt;action android:name=\"evo.v2.receipt.sell.receiptDiscount\" /&gt;            &lt;/intent-filter&gt;        &lt;/service&gt;    &lt;/application&gt;&lt;/manifest&gt;Приложение на экране оплаты смарт-терминалаЗамена кнопки Продажа на главном экране смарт-терминалаВы можете заменить кнопку Продажа, расположенную на главном экране смарт-терминала, на кнопку своего приложения:Изменение кнопки **Продажа**Чтобы заменить кнопку Продажа:В манифесте приложения, измените секцию соответствующей операции следующим образом: &lt;activity   android:name=\".&lt;НазваниеОперации&gt;\"   android:icon=\"@mipmap/ic_launcher\"   android:label=\"Example tile\"   &gt;   &lt;meta-data       android:name=\"ru.evotor.launcher.BACKGROUND_COLOR\"       android:value=\"#133788\" /&gt;   &lt;intent-filter&gt;       &lt;action android:name=\"ru.evotor.intent.action.SELL_MAIN\" /&gt;       &lt;category android:name=\"android.intent.category.EVOTOR\" /&gt;       &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;    &lt;/intent-filter&gt; &lt;/activity&gt;Где:Атрибут android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\" задаёт фон, на котором отображается иконка приложения.Элемент &lt;action android:name=\"ru.evotor.intent.action.SELL_MAIN\" /&gt; указывает, что иконка приложения заменит кнопку Продажа на главном экране смарт-терминала.Теперь вы можете собрать apk своего приложения и установить его на терминал.",
        "url": "doc_java_app_icon.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-app-manifest-html": {
        "title": "Манифест Java-приложения",
        "tags": "[]",
        "content": "Ниже приведён пример манифеста java-приложения, которое добавляет две иконки на экран оплаты.Изменяйте манифест соответствующим образом, чтобы настроить взаимодействие приложения со смарт-терминалом с помощью точек интеграции.При разработке драйвера для устройств нужно учитывать дополнительные параметры (см. SDK для денежных ящиков и другие разделы, посвящённые разработке драйверов). Примечание: В секции application, требуется указать элемент meta-data, который содержит идентификатор приложения – строка в формате uuid4. Идентификатор отображается в поле Идентификатор приложениия на вкладке APK вашего приложения, на сайте dev.evotor.ru.Идентификатор приложенияПример манифеста приложения&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"com.example.mythirdjavaapplication\"&gt;  &lt;application      android:allowBackup=\"true\"      android:icon=\"@mipmap/ic_launcher\"      android:label=\"@string/app_name\"      android:roundIcon=\"@mipmap/ic_launcher_round\"      android:supportsRtl=\"true\"      android:theme=\"@style/AppTheme\"&gt;      &lt;meta-data android:name=\"app_uuid\" android:value=\"&lt;Идентификатор приложения&gt;\"/&gt;      &lt;activity          android:name=\".MainActivity\"          android:label=\"@string/title_activity_main\"          android:theme=\"@style/AppTheme.NoActionBar\"&gt;          &lt;meta-data              android:name=\"ru.evotor.launcher.BACKGROUND_COLOR\"              android:value=\"#133788\" /&gt;          &lt;intent-filter&gt;              &lt;action android:name=\"android.intent.action.MAIN\" /&gt;              &lt;category android:name=\"android.intent.category.EVOTOR\" /&gt;          &lt;/intent-filter&gt;      &lt;/activity&gt;    &lt;service        android:name=\".MyLittleService\"        android:enabled=\"true\"        android:exported=\"true\"&gt;        &lt;intent-filter&gt;            &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;            &lt;action android:name=\"evo.v2.receipt.sell.beforePositionsEdited\" /&gt;        &lt;/intent-filter&gt;    &lt;/service&gt;    &lt;activity android:name=\".SugarSuggestionActivity\" /&gt;    &lt;receiver        android:name=\".MyLittleReceiver\"        android:enabled=\"true\"        android:exported=\"true\"&gt;        &lt;intent-filter&gt;            &lt;action android:name=\"evotor.intent.action.receipt.sell.POSITION_ADDED\" /&gt;            &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;        &lt;/intent-filter&gt;    &lt;/receiver&gt;  &lt;/application&gt;&lt;/manifest&gt;",
        "url": "doc_java_app_manifest.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-app-users-html": {
        "title": "Работа с пользователями смарт-терминала",
        "tags": "[]",
        "content": "С помощью User API вы можете узнать данные всех пользователей или пользователя, который авторизован на смарт-терминале в данный момент. Например, список прав авторизованного пользователя.Для работы используйте класс UserAPI.МетодыКласс UserAPI содержит следующие методы:Получить данные всех пользователейfun getAllUsers(context: Context): List&lt;User&gt;Где:  context – контекст приложения.  List&lt;User&gt; – список всех пользователей смарт-терминала.Получить данные авторизованного пользователяfun getAuthenticatedUser(context: Context): UserГде:  context – контекст приложения.  User – пользователь авторизованный на смарт-терминале. Если пользователь не авторизован, возвращается null.Получить список всех доступных правfun getAllGrants(context: Context): List&lt;Grant&gt;Где:  context – контекст приложения.  List&lt;Grant&gt; – список всех возможных прав.Получить список прав авторизованного пользователяfun getGrantsOfAuthenticatedUser(context: Context): List&lt;Grant&gt;Где:  context – контекст приложения.  List&lt;Grant&gt; – список всех прав авторизованного пользователя.ПримерПример использования User API в демонстрационном приложении.",
        "url": "doc_java_app_users.html",
        "product": ""
      }
      ,
      
    
          
      "doc-java-barcode-scanner-html": {
        "title": "Работа со сканером штрихкодов",
        "tags": "[]",
        "content": "Чтобы приложение получало данные от сканера штрихкодов:      В манифесте приложения добавьте разрешение на использование сканера штрихкодов: &lt;uses-permission android:name=\"ru.evotor.devices.SCANNER_RECEIVER\" /&gt;        Объявите класс BarcodeBroadcastReceiver:    BarcodeBroadcastReceiver mBarcodeBroadcastReceiver = new BarcodeBroadcastReceiver() {    @Override    public void onBarcodeReceived(String barcode, Context context) {        // Переменная barcode содержит считанный штрихкод.    }};            В операции (Activity) или фрагменте (Fragment) запускайте и останавливайте подписку BarcodeBroadcastReceiver :        @Override    protected void onPause() {        super.onPause();        unregisterReceiver(mBarcodeBroadcastReceiver);    }    @Override    protected void onResume() {        super.onResume();        registerReceiver(mBarcodeBroadcastReceiver, BarcodeBroadcastReceiver.BARCODE_INTENT_FILTER, BarcodeBroadcastReceiver.SENDER_PERMISSION, null);    }}      ПримерПример получения штрихкода в демонстрационном приложении.",
        "url": "doc_java_barcode_scanner.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-bill-printer-html": {
        "title": "Работа с принтером чеков",
        "tags": "[]",
        "content": "Работа с принтером чековЧтобы приложение печатало свои данные на чеке, выполните следующие действия:      В манифесте приложения укажите следующий элемент:    &lt;uses-permission android:name=\"ru.evotor.permission.receipt.printExtra.SET\" /&gt;            В колбэке onCreate() или при запуске операции (activity) инициализируйте класс ru.evotor.devices.commons.DeviceServiceConnector:    DeviceServiceConnector.startInitConnections(getApplicationContext());        Класс инициализируется асинхронно, чтобы не препятствовать вызывающему потоку.     Совет: Воспользуйтесь методом addConnectionWrapper, чтобы получить событие об успешном подключении. Используйте это событие, если необходимо выполнить какой-либо код сразу после установки соединения.        Вызовите метод DeviceServiceConnector.getPrinterService().    Метод возвращает объект ru.evotor.devices.commons.IPrinterServiceWrapper. Не может быть null    Метод может вернуть следующие исключения (exception):          ru.evotor.devices.commons.exception.ServiceNotConnectedException возвращается в результате серии неудачных попыток подключиться к принтеру.      ru.evotor.devices.commons.exception.DeviceServiceException – наследованое исключение.            Вы можете вызвать следующие методы объекта ru.evotor.devices.commons.IPrinterService:          int getAllowableSymbolsLineLength(int deviceId) – возвращает количество символов, которые помещаются на одной строке чека.      int getAllowablePixelLineLength(int deviceId) – возвращает доступную для печати ширину бумаги в пикселях.              void printDocument(int deviceId, in PrinterDocument printerDocument) – печатает указанный массив объектов: текст, штрихкоды, изображения.        Аргумент deviceId указывает устройство, для которого вызывается метод.         Важно: В настоящий момент печать возможна только на ККМ, встроенной в смарт-терминал, поэтому вместо номера устройства всегда следует передавать константу ru.evotor.devices.commons.Constants.DEFAULT_DEVICE_INDEX.        Каждый из методов может вернуть наследованное исключение ru.evotor.devices.commons.exception.DeviceServiceException.                  Передайте данные в печать с помощью метода printDocument(int deviceId, in PrinterDocument printerDocument).    Аргумент PrinterDocument содержит список элементов печати IPrintable:          Тексты – ru.evotor.devices.commons.printer.printable.PrintableText;      Штрихкоды – ru.evotor.devices.commons.printer.printable.PrintableBarcode;      Картинки – ru.evotor.devices.commons.printer.printable.PrintableImage.       Важно: Работа с удалённым сервисом может занимать длительное время, поэтому не вызывайте перечисленные методы в главном потоке приложения.Вызов методов из главного потока приложения вернёт исключение DeviceServiceOperationOnMainThreadException.ПримерыКод для печати сообщения на чеке:try {  DeviceServiceConnector.getPrinterService().printDocument(    DEFAULT_DEVICE_INDEX_UNSET,    new PrinterDocument(              new PrintableText(\"Первая строка\"),              new PrintableText(\"Довольно длинный текст, помещающийся лишь на несколько строк\"),              new PrintableBarcode(\"1234567890\", PrintableBarcode.BarcodeType.CODE39),              new PrintableImage(bitmap1)));} catch (DeviceServiceException exc) {}Пример работы с принтером чеков в демонстрационном приложении.",
        "url": "doc_java_bill_printer.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-discounts-html": {
        "title": "Начисление скидок",
        "tags": "[]",
        "content": "Вы можете добавлять скидку как на каждую позицию отдельно, так и на весь чек (см. ниже).Назначение скидки на чекПриложение не может автоматически применять скидку, перед этим его требуется вручную вызвать с помощью иконки на экране оплаты смарт-терминала.Для расчёта и назначения скидки:  Подпишитесь на событие ReceiptDiscountEvent, которое сообщает о возможности начислить скидку.  Получите результат, который сообщает о возможности начисления скидки.Чтобы добавить скидку на весь чек:      Подпишитесь на событие:          Создайте службу, которая наследует класс IntegrationService, например MyDiscountService.              Переопределите метод createProcessors службы MyDiscountService и создайте в нём процессор ReceiptDiscountEventProcessor .           public class MyDiscountService extends IntegrationService { @Nullable @Override protected Map&lt;String, ActionProcessor&gt; createProcessors() {     Map&lt;String, ActionProcessor&gt; map = new HashMap&lt;&gt;();     map.put(ReceiptDiscountEvent.NAME_SELL_RECEIPT, new ReceiptDiscountEventProcessor() {         @Override         public void call(@NonNull String action, @NonNull ReceiptDiscountEvent event, @NonNull Callback callback){         }     });     return map; } }                где:                  call – метод получения событий и объектов.          action – действие при событии.          event –  событие.          callback– объект возврата результата.                            Объявите службу в манифесте приложения:        &lt;service        android:name=\"MyDiscountService\"        android:enabled=\"true\"        android:exported=\"true\"&gt;        &lt;intent-filter&gt;            &lt;action android:name=\"evo.v2.receipt.sell.receiptDiscount\" /&gt;        &lt;/intent-filter&gt;&lt;/service&gt;                          Запросите результат ReceiptDiscountEventResult.    try {callback.onResult(  new ReceiptDiscountEventResult(      discount,      new SetExtra(extra),      changes));    }        catch (RemoteException exc) {                exc.printStackTrace();            }        Где:          discount – значение скидки в валюте.      new SetExtra(extra) – команда для создания дополнительных полей в чеке. Если дополнительные поля создавать не требуется вы можете передать null.      changes – список изменений по позициям.      Назначение скидки на позициюЧтобы добавить скидку на позицию, вам потребуется передать значение цены с учётом скидки в поле priceWithDiscountPosition. Если скидки на позицию нет, передавайте null. Список полей позиции описан в классе position.java.Передать поле можно в любой момент, когда доступно редактирование существующих или добавление новых позиций в чек:  При создании чека в приложении.  В списке изменений changes, при работе с чеком.  В списке изменений по позициям (см. выше)Пример скидки на позициюList&lt;PositionAdd&gt; positionAddList = new ArrayList&lt;&gt;();        positionAddList.add(                new PositionAdd(                        Position.Builder.newInstance(                                //идентификатор (uuid) позиции                                UUID.randomUUID().toString(),                                //идентификатор (uuid) товара                                null,                                //Наименование товара                                \"Зубочистки\",                                //Наименование единицы измерения                                \"кг\",                                //Точность единицы измерения                                0,                                //Цена без скидок                                new BigDecimal(200),                                //Количество                                new BigDecimal(1)                                //Добавление цены с учетом скидки на позицию. Итог = price - priceWithDiscountPosition                        ).setPriceWithDiscountPosition(new BigDecimal(100))                                .setExtraKeys(set).build()                )        ); Примечание: Вы можете найти пример начисления скидок в демонстрационном приложении.Получение скидокПолучение скидки потребуется вам чтобы точно определить сумму уплаченную по чеку. Вы можете узнавать скидку начисленную как на открытый, так и на ранее сохранённые чеки.Узнать значение скидки вы можете с помощью методов:fun getDiscount(): BigDecimalГде BigDecimal – абсолютное значение скидки в рублях.Методы принадлежат классу Receipt.ktСкидка на чекМетод getDiscount(), вызванный в классе Receipt возвращает абсолютное значение скидки на чек.Сумма скидок для текущей группыМетод getDiscount(), вызванный в классе Receipt.PrintReceipt возвращает абсолютное значение скидки на текущую печатную группу, без учёта скидки на чек.Пример получения скидок Примечание: Приведённую в примере службу требуется объявить в манифесте приложения.package com.example.dfabrichnyi.integration_lib_testimport ru.evotor.framework.core.IntegrationServiceimport ru.evotor.framework.core.action.event.receipt.print_extra.PrintExtraRequiredEventimport ru.evotor.framework.core.action.event.receipt.print_extra.PrintExtraRequiredEventProcessorimport ru.evotor.framework.core.action.processor.ActionProcessorimport ru.evotor.framework.receipt.Receiptimport ru.evotor.framework.receipt.ReceiptApiimport java.math.BigDecimalclass TestIntegrationService : IntegrationService() {    override fun createProcessors(): MutableMap&lt;String, ActionProcessor&gt; {        return hashMapOf(                Pair(PrintExtraRequiredEvent.NAME_SELL_RECEIPT, object : PrintExtraRequiredEventProcessor() {                    override fun call(action: String, event: PrintExtraRequiredEvent, callback: Callback) {                        //Возвращает текущий открытый чек.                        val receipt = ReceiptApi.getReceipt(this@TestIntegrationService, Receipt.Type.SELL)!!                        val receiptDiscount = receipt.getDiscount()                        println(\"Скидка на чек. Без учета скидок на позиции: $receiptDiscount\")                        var sum = BigDecimal.ZERO                        for (document in receipt.printDocuments) {                            sum += document.getDiscount()                        }                        println(\"Сумма скидок для текущей группы: $sum\")                        callback.skip()                    }                })        )    }}",
        "url": "doc_java_discounts.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-get-receipt-html": {
        "title": "Получить данные сформированного чека",
        "tags": "[]",
        "content": "МетодыКлассы ReceiptApi и Receipt содержат описанные ниже методы.Получить текущий открытый чекfun getReceipt(context: Context, type: Receipt.Type): Receipt?Где:  context – контекст приложения.  type – тип чека:          SELL – продажа товара;      BUY – покупка товара;      PAYBACK – возврат проданного товара;      BUYBACK – возврат купленного товара.        Receipt – текущий открытый чек.Метод возвращает чек или null, если чек закрыт.Получить чек по идентификаторуfun getReceipt(context: Context, uuid: String): Receipt?Где:  context – контекст приложения.  uuid – идентификатор чека в формате uuid4.  Receipt – чек.Метод возвращает чек или null, если чек не найден.Получить по штрихкоду позицию для добавления в чек:fun getPositionsByBarcode(context: Context, barcode: String): List&lt;Position&gt;Где:  context – контекст приложения.  barcode – штрихкод товара.  List&lt;Position&gt; – список позицийПолучить позиции чекаfun getPositions(): List&lt;Position&gt; {    return printDocuments            .flatMap { it.positions }            .toList()}Где:  List&lt;Position&gt; – список позиций чекаПолучить список платежей чекаfun getPayments(): List&lt;Payment&gt; {    return printDocuments            .map { it.payments }            .flatMap { it.keys }            .distinct()}Где:  List&lt;Payment&gt; – список платежей чекаПолучить список заголовков чекаfun getReceiptHeaders(context: Context, type: Receipt.Type? = null): ru.evotor.framework.Cursor&lt;Receipt.Header?&gt;?Где:  context – контекст приложения.  type – тип чека:          SELL – продажа товара;      BUY – покупка товара;      PAYBACK – возврат проданного товара;      BUYBACK – возврат купленного товара.        ru.evotor.framework.Cursor&lt;Receipt.Header?&gt; – курсор с заголовками чека.Метод возвращает заголовки созданных чеков, которые хранятся на терминале.ПримерПолучить список позиций открытого чека продажи:List&lt;Position&gt; positions = ReceiptApi.getReceipt(context, Receipt.Type.SELL).getPositions();",
        "url": "doc_java_get_receipt.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-integration-library-connection-html": {
        "title": "Подключение библиотеки integration library",
        "tags": "[]",
        "content": "ТребованияДля разработки java-приложения, вам потребуется:  Android Studio версии 3.0 или выше;  библиотека integration-library версии 0.4+.Подключение библиотекиЧтобы подключить библиотеку integration-library:      В Android Studio создайте новый проект: &lt;YourProjectName&gt;.    При создании проекта убедитесь, что в раскрывающемся списке Minimum SDK выбран API версии 22 или выше.    В качестве примера, используйте операцию Empty Activity. Вы можете не добавлять операцию или использовать любую из предложенных.    На скриншоте представлена структура полученного проекта:    Структура проекта    Манифест созданного проекта выглядит так:    &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.&lt;yourprojectname&gt;\"&gt;   &lt;application       android:allowBackup=\"true\"       android:icon=\"@mipmap/ic_launcher\"       android:label=\"@string/app_name\"       android:roundIcon=\"@mipmap/ic_launcher_round\"       android:supportsRtl=\"true\"       android:theme=\"@style/AppTheme\"&gt;       &lt;activity android:name=\".&lt;НазваниеОперации&gt;\"&gt;           &lt;intent-filter&gt;               &lt;action android:name=\"android.intent.action.MAIN\" /&gt;               &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;           &lt;/intent-filter&gt;       &lt;/activity&gt;   &lt;/application&gt; &lt;/manifest&gt;         Примечание: Работы с приложением, манифест должен содержать элемент &lt;meta-data/&gt; с идентификатором приложения (см. раздел “Манифест приложения”).        В файле проекта build.gradle (Project: &lt;YourProjectName&gt;) укажите:    allprojects {    repositories {        jcenter()        maven { url 'https://jitpack.io' }    }}            В файле приложения build.gradle (Module: app), добавьте библиотеку integration-library в зависимости:    dependencies {compile group: 'com.github.evotor', name: 'integration-library', version: 'v0.4.+'}        Убедитесь, что вы используете актуальную версию библиотеки.        В проекте укажите параметр minSdkVersion:    defaultConfig {     minSdkVersion 22...}      Библиотека подключена к проекту. Теперь вы можете собрать APK-файл своего приложения.Также вы можете:  добавить иконку приложения на главный экран или экран оплаты;  установить приложение на смарт-терминал.",
        "url": "doc_java_integration_library_connection.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-inventory-html": {
        "title": "Товароучёт",
        "tags": "[]",
        "content": "МетодыКласс InventoryApi содержит методы, описанные ниже.Получить все штрихкоды товара:fun getAllBarcodesForProduct(context: Context, productUuid: String): List&lt;String&gt;Где:  context – контекст приложения.  productUuid – идентификатор товара в формате uuid4.  List&lt;String&gt; – список всех штрихкодов товара.Поиск товара по идентификатору:fun getProductByUuid(context: Context, uuid: String): ProductItem?Где:  context – контекст приложения.  productUuid – идентификатор товара в формате uuid4  ProductItem – абстракция над товарами и товарными группами.Поля, одинаковые для товара и группы:  uuid – идентификатор товара или группы в формате uuid4.  parentUuid – идентификатор родительской группы в формате uuid4.  code – код товара из 1С, если нет, то null.  name – наименование товара или группы.  taxNumber – налоговая ставка.Поля, уникальные для товаров:  type – тип товара. Допустимые значения: NORMAL (обычный товар), ALCOHOL_MARKED (маркированный алкоголь) и ALKOHOL_NOT_MARKED (не маркированный алкоголь).  price – цена товара.  quantity – количество товара.  description – описание товара.  measureName – единицы измерения товара.  measurePrecision – точность измерения.  alcoholByVolume – крепость алкоголя. Если указан обычный товар, используется значение null.  alcoholProductKindCode – идентификатор алкогольной продукции в формате uuid4.  tareVolume – объём тары алкогольной продукции.Получить возможные дополнительные поля:fun getField(context: Context, fieldUuid: String): Field?Где:  context - контекст приложения  productUuid - uuid товара      Field – результат. Может быть одного из двух типов: TextField и DictionaryField.    Независимо от типа, содержит поля: name – имя поля. fieldUUID – идентификатор поля в формате uuid4. title – заголовок, который отображается в интерфейсе смарт-терминала. type – тип поля: TEXT_FIELD или DICTIONARY_FIELD.    Поля, уникальные для типа TEXT_FIELD:          data – Валидный JSON-объект, который содержит данные, отображаемые с помощью JavaScript в интерфейсе смарт-терминала.        Поля, уникальные для типа DICTIONARY_FIELD:          multiple –\tвключает или выключает возможность выбора нескольких значений.      items – массив возможных значений. Массив содержит поля title – заголовок элемента управления, который отображается пользователю и value – идентификатор элемента управления.      Получить значения дополнительных полей товара:fun getProductExtras(context: Context, productUuid: String): List&lt;ProductExtra&gt;Где:  context - контекст приложения  productUuid - uuid товара  List&lt;ProductExtra&gt; – в качестве результата будет возвращен список значений дополнительных полей товараОбъект ProductExtra содержит в себе следующие данные:  uuid – uuid значения дополнительного поля товара.  name – имя дополнительного поля товара.  fieldUUID – uuid дополнительного поля товара.      fieldValue – строка содержащая значение дополнительного поля в определенном формате:          для текстового поля – строка обрамленная кавычками (“785af1da-4053-4214-abd6-71c9cd4b5800”).      для поля из словаря – массив uuid элементов ([“61bff019-5040-40cd-bedf-d854ac935f6c”,”b993bd2a-8f6a-4fbc-b916-2d9786cd5def”]).        data - дополнительные данные от приложения.ПримерПример работы с Inventory API в демонстрационном приложении.",
        "url": "doc_java_inventory.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-logging-html": {
        "title": "Доступ к логам",
        "tags": "[]",
        "content": "Для записи событий Java-приложений используйте методы класса Log:  Log.v(String, String) – Verbose;  Log.d(String, String) – Debug;  Log.i(String, String) – Info;  Log.w(String, String) – Warn;  Log.e(String, String) – Error.Смарт-терминал фильтрует логи по имени пакета (packagename) приложения.Чтобы ваши логи отображались в logcat необходимо добавить имя пакета приложения в тэг или в текст сообщения:private static final String TAG = \"packagename\";Log.v(TAG, String);Подробное описание класса и используемых методов смотрите в документации для ОС Android.",
        "url": "doc_java_logging.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-navigation-html": {
        "title": "Вызов окон смарт-терминала",
        "tags": "[]",
        "content": "ОписаниеС помощью методов класса NavigationApi приложения вызывают различные окна смарт-терминала.МетодыcreateIntentForSellReceiptEditfun createIntentForSellReceiptEdit(): IntentОписаниеОткрывает окно редактирования чека продажи.Возвращает  IntentcreateIntentForPaybackReceiptEditfun createIntentForPaybackReceiptEdit(): IntentОписаниеОткрывает окно редактирования чека возврата проданного товара.Возвращает  IntentcreateIntentForBuyReceiptEditfun createIntentForBuyReceiptEdit(): IntentОписаниеОткрывает окно редактирования чека покупки.Возвращает  IntentcreateIntentForBuybackReceiptEditfun createIntentForBuybackReceiptEdit(): IntentОписаниеОткрывает окно редактирования чека возврата купленного товара.Возвращает  IntentcreateIntentForSellReceiptPaymentfun createIntentForSellReceiptPayment(): IntentОписаниеОткрывает окно оплаты чека продажи.Возвращает  IntentcreateIntentForPaybackReceiptPaymentfun createIntentForPaybackReceiptPayment(): IntentОписаниеОткрывает окно оплаты чека возврата проданного товара.Возвращает  IntentcreateIntentForBuyReceiptPaymentfun createIntentForBuyReceiptPayment(): IntentОписаниеОткрывает окно оплаты чека покупки.Возвращает  IntentcreateIntentForBuybackReceiptPaymentfun createIntentForBuybackReceiptPayment(): IntentОписаниеОткрывает окно оплаты чека возврата купленного товара.Возвращает  IntentcreateIntentForCashReceiptSettingsfun createIntentForCashReceiptSettings(): IntentОписаниеОткрывает окно редактирования клише чека (Настройки → Кассовый чек).Возвращает  IntentcreateIntentForCashRegisterReportfun createIntentForCashRegisterReport(): IntentОписаниеОткрывает окно доступа к кассовым отчётам (Отчёты → Кассовый отчёт).Возвращает  IntentcreateIntentForChangeUserfun createIntentForChangeUser(): IntentОписаниеОткрывает окно смены пользователей.Возвращает  IntentcreateIntentForNewProductfun createIntentForNewProduct(productBuilder: NewProductIntentBuilder): IntentОписаниеОткрывает окно создания нового товара.Параметры      productBuilder     class NewProductIntentBuilder {     private var barcode: String? = null     fun setBarcode(barcode: String?): NewProductIntentBuilder {         this.barcode = barcode         return this     }     @JvmSynthetic     internal fun build() = Intent(ACTION_EDIT_PRODUCT).apply {         barcode?.let {             putExtra(EXTRA_BARCODE, it)         }     } }      Возвращает  IntentcreateIntentForEditProductfun createIntentForEditProduct(productBuilder: EditProductIntentBuilder): IntentОписаниеОткрывает окно редактирования товара.Параметры  productBuilder   class EditProductIntentBuilder {       private lateinit var uuid: String       fun setUuid(uuid: String): EditProductIntentBuilder {           this.uuid = uuid           return this       }       @JvmSynthetic       internal fun build() = Intent(ACTION_EDIT_PRODUCT).apply {           putExtra(EXTRA_PRODUCT_UUID, uuid)       }   }Возвращает  IntentgetProductUuidfun getProductUuid(intent: Intent): String?ОписаниеПолучает идентификатор товара при успешном добавлении.Параметры  intentВозвращает  StringПримерПример вызова окон добавления и редактирования товара.package evotor.ru.pushsample;import android.content.Intent;import android.os.Bundle;import android.support.annotation.Nullable;import android.widget.Toast;import ru.evotor.framework.core.IntegrationAppCompatActivity;import ru.evotor.framework.navigation.NavigationApi;public class SampleActivity extends IntegrationAppCompatActivity {    public static final int REQUEST_CODE_FOR_NEW_PRODUCT = 10;    public static final int REQUEST_CODE_FOR_EDIT_PRODUCT = 11;    @Override    public void onCreate(@Nullable Bundle savedInstanceState) {        //Вызов суперкласса onCreate, создающего операцию.        super.onCreate(savedInstanceState);        //NavigationApi.createIntentForNewProduct() создает намерение (Intent) на создание товара с указанным штрихкодом.        startActivityForResult(NavigationApi.createIntentForNewProduct(                new NavigationApi.NewProductIntentBuilder().setBarcode(\"111\")), REQUEST_CODE_FOR_NEW_PRODUCT);    }    @Override    protected void onActivityResult(int requestCode, int resultCode, Intent data) {        if (requestCode == REQUEST_CODE_FOR_NEW_PRODUCT &amp;&amp; resultCode == RESULT_OK) {            //Toast.makeText() выводит на экран смарт-терминала сообщение            //с идентификатором нового товара.            //getProductUuid(data) получает идентификатор (uuid)            //нового товара.            Toast.makeText(this, \"UUID of new product: \" + getProductUuid(data)                    , Toast.LENGTH_SHORT).show();            //NavigationApi.createIntentForEditProduct() создает намерение (Intent) на редактирование товара.            //.setUuid(getProductUuid(data)) задаёт идентификатор редактируемого товара.            startActivityForResult(NavigationApi.createIntentForEditProduct(                    new NavigationApi.EditProductIntentBuilder()                            .setUuid(getProductUuid(data))), REQUEST_CODE_FOR_EDIT_PRODUCT);        } else if (requestCode == REQUEST_CODE_FOR_EDIT_PRODUCT &amp;&amp; resultCode == RESULT_OK) {            //Toast.makeText() выводит на экран смарт-терминала сообщение            //об успешном редактировании товара.            Toast.makeText(this, \"Товар отредактирован пользователем\", Toast.LENGTH_SHORT).show();        } else if (resultCode == RESULT_CANCELED) {            //Toast.makeText() выводит на экран смарт-терминала сообщение            //об отмене создания нового товара.            Toast.makeText(this, \"Отменено пользователем\", Toast.LENGTH_SHORT).show();        }        super.onActivityResult(requestCode, resultCode, data);    }}",
        "url": "doc_java_navigation.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-online-store-receipt-html": {
        "title": "Передача электронных чеков",
        "tags": "[]",
        "content": "Приложение может создавать чеки и передавать их для оформления в смарт-терминал. Такие чеки являются фискальными.С помощью команд PrintSellReceiptCommand и PrintPaybackReceiptCommand смарт-терминал может автоматически передавать созданные чеки на указанный адрес электронной почты (email) и / или номер телефона. Передача чеков актуальна, например, для интернет-магазинов.Передача чека на email и номер телефонаСмарт-терминал передаёт чеки если указан email и / или номер телефона. Касса не печатает чек, если указаны поля email и / или номер телефона. Примечание: Только кассы нового образца могут не печатать чеки. Кассы старого образца печатают чек независимо от того указан email или номер телефона.Чтобы передавать чек на email и номер телефона:      В манифесте укажите права приложения:    &lt;uses-permission android:name=\"ru.evotor.permission.receipt.print.INTERNET_RECEIPT\" /&gt;            Составьте список позиций, который требуется добавить в чек, наполните список    public void openReceipt() {        List&lt;positions&gt; positionAddList = new ArrayList&lt;&gt;();        JSONObject extra = new JSONObject();      }        Где:    List&lt;PositionAdd&gt; positionAddList = new ArrayList&lt;&gt;()– список позиций. Как добавить позицию в чек смотрите в разделе Добавление, изменение и удаление позиций.    JSONObject extra = new JSONObject();– добавляет дополнительные данные к чеку. Данные доступны только вашему приложению. Не создавайте этот объект, если приложение не добавляет дополнительные поля к чеку.        Укажите способ оплаты:    List&lt;Payment&gt; payments = new ArrayList&lt;&gt;();Payment payment = new Payment(        UUID.randomUUID().toString(),        new BigDecimal(9000),        new PaymentSystem(PaymentType.ELECTRON, \"Card\", \"Cashless\"),        null,        null,        null);        Где:          PaymentType – задаёт способ оплаты.            Создайте команду для передачи чека и вызовите метод .process:    PrintSellReceiptCommand command = new PrintSellReceiptCommand(positions, payments, null, \"example@example.com\");command.process(MainActivity.this, new IntegrationManagerCallback() {    @Override    public void run(IntegrationManagerFuture future) {        IntegrationManagerFuture.Result result = null;        try {            result = future.getResult();            switch (result.getType()) {                case OK:                    PrintReceiptCommandResult printSellReceiptResult = PrintReceiptCommandResult.create(result.getData());                    Toast.makeText(MainActivity.this, \"OK\", Toast.LENGTH_LONG).show();                    break;                case ERROR:                    Error error = result.getError();                    Toast.makeText(MainActivity.this, error.getMessage(), Toast.LENGTH_LONG).show();                    break;            }        } catch (IntegrationException e) {            e.printStackTrace();        }    }});        Где:          positions – список позиций чека.      payments – информация о способе оплаты.      clientPhone – номер телефона клиента в формате строки. Может быть null. Смарт-терминал передаёт чек на указанный номер телефона. Если поле не указано, смарт-терминал вернёт ошибку.      clientEmail – email клиента в формате строки. Может быть null. Смарт-терминал передаёт чек на указанный адрес электронной почты. Если поле не указано, смарт-терминал вернёт ошибку.         Совет: Чтобы передать чек возврата, вместо команды PrintSellReceiptCommand используйте команду PrintPaybackReceiptCommand.  Команда возвращает результат, описанный в классе PrintReceiptCommandResult.ПримерПример печати электронных чеков в демонстрационном приложении.Существует также более детальный способ создания и передачи чека:List&lt;Position&gt; list = new ArrayList&lt;&gt;();list.add(        Position.Builder.newInstance(                UUID.randomUUID().toString(),                null,                \"1234\",                \"12\",                0,                new BigDecimal(1000),                BigDecimal.TEN        ).build());list.add(        Position.Builder.newInstance(                UUID.randomUUID().toString(),                null,                \"1234\",                \"12\",                0,                new BigDecimal(500),                BigDecimal.ONE        ).setPriceWithDiscountPosition(new BigDecimal(300)).build());HashMap payments = new HashMap&lt;Payment, BigDecimal&gt;();payments.put(new Payment(                    UUID.randomUUID().toString(),                    new BigDecimal(9300),                    new PaymentSystem(PaymentType.ELECTRON, \"Internet\", \"12424\"),                    null,                    null,                    null            ), new BigDecimal(9300));PrintGroup printGroup = new PrintGroup(UUID.randomUUID().toString(),                PrintGroup.Type.CASH_RECEIPT, null, null, null, null, false);final Receipt.PrintReceipt printReceipt = new Receipt.PrintReceipt(        printGroup,        list,        payments,        new HashMap&lt;Payment, BigDecimal&gt;());ArrayList&lt;Receipt.PrintReceipt&gt; listDocs = new ArrayList&lt;&gt;();listDocs.add(printReceipt);BigDecimal receiptDiscount = new BigDecimal(1000);new PrintSellReceiptCommand(listDocs, null, null, \"example@example.com\", receiptDiscount).process(MainActivity.this, new IntegrationManagerCallback() {    @Override    public void run(IntegrationManagerFuture integrationManagerFuture) {        try {            IntegrationManagerFuture.Result result = integrationManagerFuture.getResult();            switch (result.getType()) {                       case OK:                           PrintReceiptCommandResult printSellReceiptResult = PrintReceiptCommandResult.create(result.getData());                           Toast.makeText(MainActivity.this, \"OK\", Toast.LENGTH_LONG).show();                           break;                       case ERROR:                           Error error = result.getError();                           Toast.makeText(MainActivity.this, error.getMessage(), Toast.LENGTH_LONG).show();                           break;                   }        } catch (IntegrationException e) {            e.printStackTrace();        }    }});",
        "url": "doc_java_online_store_receipt.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-payment-systems-html": {
        "title": "Использование различных способов оплаты",
        "tags": "[]",
        "content": "Пользователи Эвотор могут установить на смарт-терминал приложения для работы с различными платёжными системами. После установки приложения платёжной системы, на экране оплаты/возврата товара, помимо кнопок Наличные и Банковская карта, добавляется кнопка платёжной системы.Служба для взаимодействия со сторонними платёжными системамиЧтобы добавить поддержку сторонней платёжной системы:      В манифесте приложения, добавьте разрешение:    &lt;uses-permission android:name=\"ru.evotor.permission.PAYMENT_SYSTEM\" /&gt;            Создайте службу и назовите её, например .PaymentService.    Служба будет обрабатывать событие evo.v2.receipt.paymentSystem.    Событие содержит поле OperationType, которое указывает тип операции:          OperationType.SELL – продажа;      OperationType.SELL_CANCEL – отмена продажи;      OperationType.PAYBACK – возврат;      OperationType.PAYBACK_CANCEL – отмена возврата.        Каждому типу операции соответствует событие и метод, который его обрабатывает. Методы представлены в классе PaymentSystemProcessor.kt:    abstract class PaymentSystemProcessor : ActionProcessor() {    override fun process(action: String, bundle: Bundle?, callback: ActionProcessor.Callback) {        val event = PaymentSystemEvent.create(bundle) ?: return        when (event.operationType) {            PaymentSystemEvent.OperationType.SELL -&gt; sell(action, event as PaymentSystemSellEvent, callback)            PaymentSystemEvent.OperationType.SELL_CANCEL -&gt; sellCancel(action, event as PaymentSystemSellCancelEvent, callback)            PaymentSystemEvent.OperationType.PAYBACK -&gt; payback(action, event as PaymentSystemPaybackEvent, callback)            PaymentSystemEvent.OperationType.PAYBACK_CANCEL -&gt; paybackCancel(action, event as PaymentSystemPaybackCancelEvent, callback)            else -&gt; null        }    }        Ваша служба должна реализовывать все методы, описанные в классе.        Измените раздел службы .PaymentService в манифесте приложения:    &lt;service    android:name=\".PaymentService\"    android:exported=\"true\"    android:icon=\"@android:drawable/ic_dialog_map\"    android:label=\"Текст на кнопке\"&gt;    &lt;meta-data        android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\"        android:value=\"@android:color/holo_green_light\" /&gt;    &lt;meta-data        android:name=\"ru.evotor.paymentSystem.PAYMENT_SYSTEM_ID\"        android:value=\"ru.test.testapplication.paymentSystem.packageName\" /&gt;    &lt;intent-filter&gt;        &lt;action android:name=\"evo.v2.receipt.paymentSystem\" /&gt;    &lt;/intent-filter&gt;&lt;/service&gt;        Где:          Элемент ru.evotor.sales_screen.BACKGROUND_COLOR задаёт цвет кнопки платёжной системы.      Элемент ru.evotor.paymentSystem.PAYMENT_SYSTEM_ID задаёт уникальный идентификатор приложения. Уникальность идентификатора необходима, чтобы смарт-терминал всегда мог определить с какой платёжной системой он взаимодействует. Идентификатор остаётся неизменным даже, если название службы изменилось при обновлении приложения.         Совет: Хорошей практикой является использование packageName приложения в идентификаторе.          В intent-filter подпишите службу на получение события evo.v2.receipt.paymentSystem.            После обработки события evo.v2.receipt.paymentSystem, служба .PaymentService должна возвращать соответствующий результат.    В случае удачной обработки события служба возвращает результат PaymentSystemPaymentOkResult.    В случае неудачной обработки события служба возвращает результат PaymentSystemPaymentErrorResult.  СобытияВ зависимости от операции на смарт-терминале в службу могут поступать четыре типа событий.ПродажаПри продаже товара приходит событие PaymentSystemSellEvent.kt:class PaymentSystemSellEvent(        val receiptUuid: String,        val accountId: String?,        val sum: BigDecimal,        val description: String?)Где:  receiptUuid – идентификатор чека.  accountId – счёт (учётная запись) в платёжной системе. Поле указывать необязательно.  sum – сумма платежа.  description – текстовое описание. Поле может быть указано любым приложением, например, при разделении чека. В приложении требуется предусмотреть возможность отображения этого поля.Отмена продажиПри отмене продажи приходит событие PaymentSystemSellCancelEvent.kt:class PaymentSystemSellCancelEvent(        val receiptUuid: String,        val accountId: String?,        val sum: BigDecimal,        val rrn: String?,        val description: String?)Где:  receiptUuid – идентификатор чека.  accoundId – счёт (учётная запись) в платёжной системе.  sum – сумма платежа.  rrn – уникальный идентификатор платежа, который будет отменён.  description – текстовое описание. Поле может быть указано любым приложением, например, при разделении чека. В приложении требуется предусмотреть возможность отображения этого поля.ВозвратПри возврате товара приходит событие PaymentSystemPaybackEvent.kt:class PaymentSystemPaybackEvent(        val receiptUuid: String,        val accountId: String?,        val sum: BigDecimal,        val rrn: String?,        val description: String?)Где:  receiptUuid – идентификатор чека.  accoundId – счёт (учётная запись) в платёжной системе.  sum – сумма платежа.  rrn – уникальный идентификатор платежа, по которому будет проведён возврат.  description – текстовое описание. Поле может быть указано любым приложением, например, при разделении чека. В приложении требуется предусмотреть возможность отображения этого поля.Отмена возвратаПри отмене возврата приходит событие PaymentSystemPaybackCancelEvent.kt:class PaymentSystemPaybackCancelEvent(        val receiptUuid: String,        val accountId: String?,        val sum: BigDecimal,        val rrn: String?,        val description: String?)Где:  receiptUuid – идентификатор чека.  accoundId – счёт (учётная запись) в платёжной системе.  sum – сумма платежа.  rrn – уникальный идентификатор платежа, который будет отменён.  description – текстовое описание. Поле может быть указано любым приложением, например, при разделении чека. В приложении требуется предусмотреть возможность отображения этого поля.РезультатыУспешная обработка событияВ случае успешной обработки события служба должна возвращать результат PaymentSystemPaymentOkResult:class PaymentSystemPaymentOkResult(        val rrn: String,        val slip: List&lt;String&gt;,        val paymentInfo: String?,        val paymentType: PaymentType = PaymentType.ELECTRON)Где:  rrn – уникальный идентификатор платежа, который понадобится при отмене транзакции.  slip – текст, который будет напечатан на чеке в двух экземплярах.  paymentInfo – поле для хранения статистической информации. Приложение не заполняет это поле.  paymentType – тип оплаты. По умолчанию ELECTRON.Ошибка обработки событияВ случае ошибки служба должна возвращать результат PaymentSystemPaymentErrorResult.kt:class PaymentSystemPaymentErrorResult(        val errorDescription: String?)Где:  errorDescription – описание ошибки.Пример службы PaymentServiceПример работы с PaymentSystem API в демонстрационном приложении.Пример службы PaymentService, которая поддерживает все методы класса PaymentSystemProcessor.kt:public class PaymentService extends IntegrationService {    public static final String TAG = \"PaymentService\";    @Nullable    @Override    protected Map&lt;String, ActionProcessor&gt; createProcessors() {        Map&lt;String, ActionProcessor&gt; processorMap = new HashMap&lt;&gt;();        processorMap.put(                PaymentSystemEvent.NAME_ACTION,                new PaymentSystemProcessor() {                    @Override                    public void sell(String s, PaymentSystemSellEvent paymentSystemSellEvent, Callback callback) {                        Log.e(TAG, \"sell \" + paymentSystemSellEvent);                        Intent intent = new Intent(PaymentService.this, PaymentActivity.class);                        intent.putExtra(EXTRA_NAME_OPERATION, \"sell\");                        try {                            callback.startActivity(intent);                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                    @Override                    public void sellCancel(String s, PaymentSystemSellCancelEvent paymentSystemSellCancelEvent, Callback callback) {                        Log.e(TAG, \"sellCancel \" + paymentSystemSellCancelEvent);                        Intent intent = new Intent(PaymentService.this, PaymentActivity.class);                        intent.putExtra(EXTRA_NAME_OPERATION, \"sellCancel\");                        try {                            callback.startActivity(intent);                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                    @Override                    public void payback(String s, PaymentSystemPaybackEvent paymentSystemPaybackEvent, Callback callback) {                        Log.e(TAG, \"payback \" + paymentSystemPaybackEvent);                        Intent intent = new Intent(PaymentService.this, PaymentActivity.class);                        intent.putExtra(EXTRA_NAME_OPERATION, \"payback\");                        try {                            callback.startActivity(intent);                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                    @Override                    public void paybackCancel(String s, PaymentSystemPaybackCancelEvent paymentSystemPaybackCancelEvent, Callback callback) {                        Log.e(TAG, \"paybackCancel \" + paymentSystemPaybackCancelEvent);                        Intent intent = new Intent(PaymentService.this, PaymentActivity.class);                        intent.putExtra(EXTRA_NAME_OPERATION, \"paybackCancel\");                        try {                            callback.startActivity(intent);                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                }            }        );}Пример операции PaymentActivitypackage ru.apptest.test.testapplication;import android.os.Bundle;import android.view.View;import android.widget.TextView;import java.util.ArrayList;import java.util.List;import java.util.Random;import ru.evotor.framework.core.IntegrationActivity;import ru.evotor.framework.core.action.event.receipt.payment.system.result.PaymentSystemPaymentErrorResult;import ru.evotor.framework.core.action.event.receipt.payment.system.result.PaymentSystemPaymentOkResult;import ru.evotor.framework.payment.PaymentType;public class PaymentActivity extends IntegrationActivity {    public static final String EXTRA_NAME_OPERATION = \"EXTRA_NAME_OPERATION\";    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_payment);        findViewById(R.id.button_ok).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                String rrn = \"\";                Random random = new Random();                for (int i = 0; i &lt; 10; i++) {                    rrn += random.nextInt(10);                }                List&lt;String&gt; slip = new ArrayList&lt;String&gt;();                slip.add(\"SLIP START\");                slip.add(\"RRN:\");                slip.add(rrn);                slip.add(\"SLIP EMD\");                setIntegrationResult(new PaymentSystemPaymentOkResult(rrn, slip, \"123qwe\", PaymentType.ELECTRON));                finish();            }        });        findViewById(R.id.button_error).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                setIntegrationResult(new PaymentSystemPaymentErrorResult(\"beda was happened\"));                finish();            }        });        if (getIntent().hasExtra(EXTRA_NAME_OPERATION)) {            ((TextView) findViewById(R.id.textView_operation)).setText(getIntent().getStringExtra(EXTRA_NAME_OPERATION));        }    }    @Override    public void onBackPressed() {        setIntegrationResult(new PaymentSystemPaymentErrorResult(\"onBackPressed was happened\"));        finish();    }}",
        "url": "doc_java_payment_systems.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-pushnotifications-html": {
        "title": "Оповещение пользователей с помощью push-уведомлений",
        "tags": "[]",
        "content": "Приложения могут принимать и отображать push-уведомления.В качестве примера, рассмотрим класс, который отображет простое всплывающее сообщение.Чтобы реализовать поддержку push-уведомлений в приложении:      Создайте класс-приёмник push-уведомлений PushReceiver, который наследует класс PushNotificationReceiver.    public class PushReceiver extends PushNotificationReceiver { @Override public void onReceivePushNotification(Context context, Bundle data, long messageId) {     //...получение push-уведомления.     Toast.makeText(context, data.getString(\"header\") + \" \" + data.getString(\"description\")             + \" \" + messageId, Toast.LENGTH_SHORT).show();    }}            Добавьте необходимые права.    Для приложения:    &lt;uses-permission android:name=\"ru.evotor.pushnotifications.PUSH_RECEIVE\" /&gt;         Совет: Обратите внимание, как указаны права у демонстрационного приложения.    И для класса PushReceiver:    &lt;receiver   android:name=\".PushReceiver\"   android:permission=\"ru.evotor.pushnotifications.PUSH_SENDER\"&gt;   &lt;intent-filter&gt;       &lt;action android:name=\"ru.evotor.pushnotifications.PUSH_RECEIVED_EVENT\" /&gt;   &lt;/intent-filter&gt;&lt;/receiver&gt;        Укажите в классе intent-фильтр &lt;action android:name=\"ru.evotor.pushnotifications.PUSH_RECEIVED_EVENT\" /&gt;.  ПримерПример реализованной службы вы найдёте в нашем демонстрационном приложении, в ветке push_sample.См. также  Сборка и установка демонстрационного приложения;  Обмен сообщениями приложения и стороннего сервиса.",
        "url": "doc_java_pushnotifications.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-receipt-api-html": {
        "title": "Поиск товара по штрихкоду",
        "tags": "[]",
        "content": "КлассДля работы используйте класс ReceiptApi.МетодыПолучить по штрихкоду позицию для добавления в чек:fun getPositionsByBarcode(context: Context, barcode: String): List&lt;Position&gt;Где:  context – контекст приложения.  barcode – штрихкод товара.  List&lt;Position&gt; – список позицийПримерПример поиска товара по штрихкоду в демонстрационном приложении.",
        "url": "doc_java_receipt_api.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-receipt-creation-html": {
        "title": "Открытие чека в приложении",
        "tags": "[]",
        "content": "Чтобы открыть чек продажи в смарт-терминале:      Составьте список позиций, который требуется добавить в чек, и наполните его:    public void openReceipt() {        List&lt;PositionAdd&gt; positionAddList = new ArrayList&lt;&gt;();        JSONObject extra = new JSONObject();      }        Где:    List&lt;PositionAdd&gt; positionAddList = new ArrayList&lt;&gt;()– список позиций. Как добавить позицию в чек смотрите в разделе Добавление, изменение и удаление позиций.    JSONObject extra = new JSONObject();– добавляет дополнительные данные к чеку. Данные доступны только вашему приложению. Не создавайте этот объект, если приложение не добавляет дополнительные поля к чеку.        Создайте команду открытия чека и вызовите метод .process    new OpenSellReceiptCommand(positionAddList, null).process(                        activity,                        new IntegrationManagerCallback() {                            @Override                            public void run(IntegrationManagerFuture integrationManagerFuture) {                                try {                                    IntegrationManagerFuture.Result result = integrationManagerFuture.getResult();                                    if (result.getType() == IntegrationManagerFuture.Result.Type.OK) {                                        //Чтобы открыть другие документы используйте методы NavigationApi.                                        startActivity(NavigationApi.createIntentForSellReceiptPayment());                                    }                                } catch (IOException e) {                                    e.printStackTrace();                                } catch (IntegrationException e) {                                    e.printStackTrace();                                }                            }                        });        Где вместо null вы можете передать new SetExtra(extra), команду для создания дополнительных полей в чеке.    Чтобы открыть чек другого типа используйте соответствующую команду. Возможные команды:          OpenSellReceiptCommand – команда открытия чека продажи.      OpenPaybackReceiptCommand – команда открытия чека возврата проданного товара.      OpenBuyReceiptCommand – команда открытия чека покупки.      OpenBuybackReceiptCommand – команда открытия чека возврата купленного товара.         Совет: Замените SELL на PAYBACK, если хотите открыть чек возврата.     Примечание: При создании нового чека, происходит автоматическая очистка существующего открытого чека.  ПримерПример открытия чека продажи или возврата в демонстрационном приложении.",
        "url": "doc_java_receipt_creation.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-receipt-division-html": {
        "title": "Разделение чека",
        "tags": "[]",
        "content": "ТребованияЧтобы служба получала необходимые сообщения, в манифесте приложения требуется задать intent-filter для соответствующей службы:&lt;intent-filter&gt;  &lt;action android:name=\"evo.v2.receipt.sell.payment.SELECTED\" /&gt;  &lt;action android:name=\"evo.v2.receipt.sell.printGroup.REQUIRED\" /&gt;&lt;/intent-filter&gt;Где:  evo.v2.receipt.sell.payment.SELECTED – сообщает о разделении платежей.  evo.v2.receipt.sell.printGroup.REQUIRED – сообщает о разделении чека на несколько печатных групп.Разделение чекаСхема разделения чека выглядит следующим образом:Процесс разделения чека:  Пользователь выбирает тип оплаты Банковская карта.      Смарт-терминал передаёт событие PaymentSelectedEvent и ожидает ответа от приложений.     Примечание: Событие возникает только если пользователь выбрал безналичный расчёт.        Приложение может разделить чек на несколько платежей в счёт одного или нескольких юридических лиц.    Приложение возвращает данные о соответствии счетов и платежей в объекте PaymentSelectedEventResult и указывает разделение платежей в объекте PaymentPurpose.    Каждый из платежей, указанных в PaymentPurpose содержит:          собственный идентификатор объекта PaymentPurpose, который можно использовать для сопоставления платежа и печатной группы;      сумму платежа;      идентификаторы платёжной системы и счёта в ней;      текст, который отображается пользователю при проведении данного платежа.        В данный момент поддерживается разделение только в рамках той системы оплаты, которую выбрал пользователь. Разделение на различные системы оплаты (комбинированная оплата) не поддерживается.    Чтобы получить список счетов, доступных на данном смарт-терминале, воспользуйтесь методом getPaymentSystems, класса PaymentSystemApi.    Используйте команду SetExtra, чтобы добавить к чеку дополнительные поля.        На основе данных, полученных от приложения, смарт-терминал совершает платежи и начинает печать чека. Перед печатью чека EvoPOS передаёт событие PrintGroupRequiredEvent и ожидает ответа от приложений.        Приложение может напечатать несколько разных печатных документов и разделить платежи между ними.    Приложение передаёт данные о печатных документах, закреплённых за ними позициях и соответствующих платежах в объекте PrintGroupRequiredEventResult, которому соответствует список объектов SetPrintGroup.    Для каждого объекта SetPrintGroup приложение указывает:          печатную группу (PrintGroup);      список идентификаторов платежей (paymentPurposeIds);      список иденификаторов позиций в формате uuid4 (positionUuids)        В печатной группе приложение указывает:          идентификатор печатной группы;              тип чека:                  фискальный – CASH_RECEIPT          квитанция (нефискальный чек) – INVOICE                      ЕНВД (нефискальный чек) – STRING_UTII            Квитанция и ЕНВД чек задаются в виде строк, в отличие от фискального чека, который набирается с помощью команд ККМ. ЕНВД чек отличается от квитанции тем, что квитанция не содержит информации о способе оплаты и на распечатанном чеке явно указывается, что это квитанция.                                      систему налогообложения;        Систему налогообложения можно указывать как для фискальных, так и для нефискальных чеков. Смарт-терминал печатает чеки с указанной системой налогообложения, если она попадает в список разрешённых систем. В противном случае смарт-терминал выбирает систему налогообложения, заданную по умолчанию.            реквизиты организации (название, ИНН, адрес).      Поле true или false, которое задаёт необходимость печати чека.        Используйте команду SetExtra, чтобы добавить к чеку дополнительные поля.    EvoPOS печатает чек в соответствии с полученными печатными группами.Методы PaymentSystem APIИспользуйте класс PaymentSystemApi.Получить список платёжных систем, а также их учётных записей, доступных на смарт-терминале:fun getPaymentSystems(context: Context): List&lt;Pair&lt;PaymentSystem, List&lt;PaymentAccount&gt;&gt;&gt;Метод возвращает список доступных на терминале платёжных систем (PaymentSystem) и соответствующих им счетов (PaymentAccount). Счета можно получить у приложений, которые реализуют различные способы оплаты.Объекты PaymentSystem содержат:  тип платёжной системы (наличные, электронные платежи, другие);  название, которое можно отобразить пользователю;  постоянный идентификатор платёжной системы в терминале.Объекты PaymentAccount содержат:  идентификатор счёта в рамках платёжной системы;  название счёта, которое можно отобразить пользователю.ПримерыРазделение платежей в чекеПример разделения чека на несколько платежей в демонстрационном приложении.        processorMap.put(                PaymentSelectedEvent.NAME_SELL_RECEIPT,                new PaymentSelectedEventProcessor() {                    @Override                    public void call(@NonNull String s, @NonNull PaymentSelectedEvent                            paymentSelectedEvent, @NonNull Callback callback) {                        List&lt;PaymentPurpose&gt; paymentParts = new ArrayList&lt;PaymentPurpose&gt;();                        String psId = paymentSelectedEvent.getPaymentSystem().getPaymentSystemId();                        paymentParts.add(new PaymentPurpose(\"-1-\", psId, new BigDecimal(3), \"0\", \"платёж клиента 1\"));                        paymentParts.add(new PaymentPurpose(\"-2-\", psId, new BigDecimal(5), \"0\", \"платёж клиента 2\"));                        paymentParts.add(new PaymentPurpose(\"-3-\", psId, new BigDecimal(2), \"0\", \"платёж клиента 3\"));                        paymentParts.add(new PaymentPurpose(\"-4-\", psId, new BigDecimal(10), \"0\", \"платёж клиента 4\"));                        try {                            callback.onResult(                                    new PaymentSelectedEventResult(                                            null,                                            paymentParts                                    ).toBundle()                            );                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                }        );Разделение чека на несколько печатных группПример разделения чека на несколько печатных групп в демонстрационном приложении.Пример печати квитанции (INVOICE)processorMap.put(                PrintGroupRequiredEvent.NAME_SELL_RECEIPT,                new PrintGroupRequiredEventProcessor() {                    @Override                    public void call(@NonNull String s, @NonNull PrintGroupRequiredEvent printGroupRequiredEvent, @NonNull Callback callback) {                        List&lt;SetPrintGroup&gt; setPrintGroups = new ArrayList&lt;SetPrintGroup&gt;();                        PrintGroup printGroup = new PrintGroup(                                UUID.randomUUID().toString(),                                PrintGroup.Type.INVOICE,                                \"ООО \\\"Пример\\\"\",                                \"012345678901\",                                \"г. Москва\",                                TaxationSystem.PATENT,                                true                        );                        List&lt;String&gt; paymentPurposeIds = new ArrayList&lt;String&gt;();                        paymentPurposeIds.add(\"-1-\");                        paymentPurposeIds.add(\"-3-\");                        List&lt;String&gt; positionUuids = new ArrayList&lt;String&gt;();                        if (lastPosition != null) {                            positionUuids.add(lastPosition.getUuid());                        }                        setPrintGroups.add(new SetPrintGroup(                                printGroup,                                paymentPurposeIds,                                positionUuids                        ));                        try {                            callback.onResult(                                    new PrintGroupRequiredEventResult(                                            null,                                            setPrintGroups                                    )                            );                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                }        ); Примечание: Поле true печатной группы printGroup указывает, что чек будет напечатан. ",
        "url": "doc_java_receipt_division.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-receipt-extras-html": {
        "title": "Создание дополнительных полей в чеке",
        "tags": "[]",
        "content": "Приложения могут записывать дополнительные поля в чеки продажи и возврата.Дополнительные поля помогут вам хранить и отображать информацию, которая не предусмотрена стандартной моделью чека продажи или возврата.Например, системы лояльности могут хранить в дополнительных полях информацию о карте лояльности пользователя.Дополнительные поля должны представлять валидный JSON-объект:JSONObject object = new JSONObject();                object.put(\"key\", \"value\");                SetExtra extra = new SetExtra(object);Вы можете создавать дополнительные поля в чеках в следующих случаях:  при открытии чека;  при применении скидки;  при изменении позиций в чеке.",
        "url": "doc_java_receipt_extras.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-receipt-interactions-html": {
        "title": "Работа с позициями чека",
        "tags": "[]",
        "content": "Использование службы и получение событий о намерении изменения чека      Создайте службу, например MyIntegrationService, которая наследует класс IntegrationService. В колбэке onCreate службы, зарегистрируйте процессор BeforePositionsEditedEventProcessor (процессор наследует класс ActionProcessor).    public class MyIntegrationService extends IntegrationService { @Nullable @Override protected Map&lt;String, ActionProcessor&gt; createProcessors() {     Map&lt;String, ActionProcessor&gt; map = new HashMap&lt;&gt;();     map.put(BeforePositionsEditedEvent.NAME_SELL_RECEIPT, new BeforePositionsEditedEventProcessor() {         @Override         public void call(@NonNull String action, @NonNull BeforePositionsEditedEvent event, @NonNull Callback callback){         }     });     return map;    }}            Объявите службу в манифесте приложения:    &lt;service        android:name=\".MyIntegrationService\"        android:enabled=\"true\"        android:exported=\"true\"&gt;        &lt;intent-filter&gt;            &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;            &lt;action android:name=\"evo.v2.receipt.sell.beforePositionsEdited\" /&gt;        &lt;/intent-filter&gt;&lt;/service&gt;      В метод call процессора приходит событие beforePositionsEditedEvent и объект для возврата результата callback.В ответ приложение возвращает результат со списком возможных изменений:public BeforePositionsEditedEventResult(        @Nullable List&lt;IPositionChange&gt; changes,        @Nullable SetExtra extra)Чтобы вернуть результат, используйте метод:callback.onResult(beforePositionsEditedEventResult)Если приложению для возврата результата необходимо взаимодействие с пользователем, запустите операцию (Activity), которая наследует класс IntegrationActivity:callback.startActivity(new Intent(context, MainActivity.class));Ваша операция должна вызвать метод setIntegrationResult.Например:setIntegrationResult(new BeforePositionsEditedEventResult(changes, null));Где вместо null вы можете передать new SetExtra(extra), команду для создания дополнительных полей в чеке.Описание события BeforePositionsEditedEventО намерении изменения чека сообщает событие beforePositionsEditedEvent:Описание позицииВы можете добавить в чек как позицию соответствующую товару в базе терминала, так и задать свободную позицию.Конструкторы позиций описаны  в классе Position.java.Пример конструктора позиции чека, соответствующей товару в терминале (у позиции есть uuid товара):public Position(        String uuid,        String productUuid,        String productCode,        ProductType productType,        String name,        String measureName,        int measurePrecision,        TaxNumber taxNumber,        BigDecimal price,        BigDecimal priceWithDiscountPosition,        BigDecimal quantity,        String barcode,        String mark,        BigDecimal alcoholByVolume,        Long alcoholProductKindCode,        BigDecimal tareVolume,        Set&lt;ExtraKey&gt; extraKeys,        List&lt;Position&gt; subPositions)Где:  uuid – идентификатор позиции в формате uuid4.  productUuid – идентификатор товара в формате uuid4, полученный из локальной базы товаров смарт-терминала.  productCode – Код товара. Может быть null.  productType – Вид товара.  name – наименование товара из локальной базы товаров смарт-терминала.  measureName – единицы измерения товара, полученные из локальной базы товаров смарт-терминала.  measurePrecision – точность измерения единиц товара, выраженная в количестве знаков после запятой.  taxNumber – налоговая ставка. Может быть null. Доступные значения описаны в классе TaxNumber.java. Если поле не задано, смарт-терминал обращается за налоговой ставкой в Облако. Если в Облаке нет информации о налоговой ставке для позиции, смарт-терминал использует значение, заданное в настройках.  price – цена продукта, полученная из локальной базы товаров смарт-терминала.  priceWithDiscountPosition – цена позиции с учётом скидки.  quantity – количество добавленного товара.  barcode – штрихкод, по которому найден товар. Может быть null.  mark – алкогольная марка.  alcoholByVolume – крепость алкогольной продукции. Может быть null.  alcoholProductKindCode – код вида продукции ФСРАР. Может быть null.  tareVolume – объём тары. Может быть null.      extraKeys – дополнительные ключи (идентификаторы). Каждый ключ имеет описание (description), которое отображается в интерфейсе и печатается на чеке (можно передавать null), идентификатор (identity) и хранит данные о приложении, создавшем ключ (appId).     Примечание: Приложение записывает дополнительные ключи в чек только под своим идентификатором.    subPositions – список подпозиций.Позиция с подпозициейПример позиции чека с подпозицией (у позиции и подпозиции есть uuid товара):val positionFromProduct = Position.Builder.newInstance(                UUID.randomUUID().toString(),                product.uuid,                product.name,                product.measureName,                product.measurePrecision,                product.price,                BigDecimal.ONE        ).build()        positionFromProduct.subPosition.add(                Position.Builder.newInstance(                                UUID.randomUUID().toString(),                                product.uuid,                                product.name,                                product.measureName,                                product.measurePrecision,                                product.price,                                BigDecimal.ONE                        ).build()                )Вы можете использовать подпозиции subPosition для добавления опций к товару.Например, к товару “Кофе” можно добавить подпозицию “Молоко”. Подпозиция удаляется вместе с основной позицией товара.Свободно заданная позицияПример свободно заданной позиции (uuid товара – null):val freeProductPosition = Position.Builder.newInstance(                UUID.randomUUID().toString(),                null,                \"Товар\",                \"шт\",                0,                BigDecimal(100),                BigDecimal(100)        ).build()Добавление, изменение и удаление позицийЧтобы добавить позицию:      В Java-приложении используйте метод:    data class PositionAdd(val position: Position) : IPositionChange {    override fun toBundle(): Bundle {        return Bundle().apply {            putBundle(                    PositionMapper.KEY_POSITION,                    PositionMapper.toBundle(position)            )        }    }    override fun getPositionUuid(): String? {        return position.uuid    }    override fun getType(): IChange.Type {        return IChange.Type.POSITION_ADD    }    companion object {        @JvmStatic        fun from(bundle: Bundle?): PositionAdd? {            bundle ?: return null            return PositionAdd(                    PositionMapper.from(                            bundle.getBundle(PositionMapper.KEY_POSITION)                    ) ?: return null            )        }    }}            В JS-приложении используйте метод:    function processBeforePositionsEdited(actionData) {var position = {    \"uuid\" : \"8e0ffg-lk3e-e93bnk-v0p41\",    \"productUuid\" : \"trb44-i32lev-9833jf\",    \"productCode\" : \"1024\",    \"productType\" : \"NORMAL\",    \"name\" : \"myLittlePosition\",    \"measureName\" : \"kg\",    \"measurePrecision\" : 0,    \"price\" : \"100\",    \"quantity\" : \"1\"}    receipt.addPosition(JSON.stringify(position));}      Чтобы изменить позицию, используйте следующий метод:data class PositionEdit(val position: Position) : IPositionChange {    override fun toBundle(): Bundle {        return Bundle().apply {            putBundle(                    PositionMapper.KEY_POSITION,                    PositionMapper.toBundle(position)            )        }    }    override fun getPositionUuid(): String? {        return position.uuid    }    override fun getType(): IChange.Type {        return IChange.Type.POSITION_EDIT    }    companion object {        @JvmStatic        fun from(bundle: Bundle?): PositionEdit? {            bundle ?: return null            return PositionEdit(                    PositionMapper.from(bundle.getBundle(PositionMapper.KEY_POSITION)) ?: return null            )        }    }}Чтобы удалить позицию, используйте следующий метод:data class PositionRemove(        private val positionUuid: String) : IPositionChange {    override fun toBundle(): Bundle {        return Bundle().apply {            putString(                    KEY_POSITION_UUID,                    positionUuid            )        }    }    override fun getPositionUuid(): String? {        return positionUuid    }    override fun getType(): IChange.Type {        return IChange.Type.POSITION_REMOVE    }    companion object {        const val KEY_POSITION_UUID = \"positionUuid\"        @JvmStatic        fun from(bundle: Bundle?): PositionRemove? {            bundle ?: return null            return PositionRemove(                    bundle.getString(KEY_POSITION_UUID) ?: return null            )        }    }}",
        "url": "doc_java_receipt_interactions.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-receipt-print-html": {
        "title": "Печать внутри кассового чека",
        "tags": "[&quot;java&quot;, &quot;terminal&quot;, &quot;equipment&quot;]",
        "content": "Смарт-терминал позволяет приложениям печатать свои данные внутри кассового чека: тексты, штрихкоды или изображения.Следующие методы определяют, где печатаются переданные данные:  PrintExtraPlacePrintGroupTop – данные печатаются после клише и до текста “Кассовый чек”;  PrintExtraPlacePrintGroupHeader – данные печатаются после текста “Кассовый чек”, до имени пользователя;  PrintExtraPlacePrintGroupSummary – данные печатаются после итога и списка оплат, до текста “всего оплачено”;  PrintExtraPlacePositionFooter – данные печатаются в позиции в чеке, до подпозиций;  PrintExtraPlacePositionAllSubpositionsFooter – данные печатаются в позиции в чеке, после всех подпозиций.Печать данных внутри кассового чекаЧтобы приложение печатало данные внутри кассового чека:      В манифесте приложения, укажите права приложения:    &lt;uses-permission android:name=\"ru.evotor.permission.receipt.printExtra.SET\" /&gt;        Создайте службу, которая отвечает за передачу данных для печати.      Объявите службу в манифесте приложения и укажите intent-filter:    &lt;action android:name=\"&lt;Событие&gt;\" /&gt;        где необходимо указать событие, при которое определяет тип чека, в котором будут напечатаны данные. Возможны следующие события:          evo.v2.receipt.sell.printExtra.REQUIRED – печать внутри кассового чека продажи товара.      evo.v2.receipt.buy.printExtra.REQUIRED  – печать внутри кассового чека покупки товара.      evo.v2.receipt.payback.printExtra.REQUIRED – печать внутри кассового чека возврата проданного товара.      evo.v2.receipt.buyback.printExtra.REQUIRED – печать внутри кассового чека возврата купленного товара.            В службе, подпишите процессор PrintExtraRequiredEventProcessor на событие:    processorMap.put(                //NAME_SELL_RECEIPT – имя события, которое указывает тип чека, где будут напечатаны данные.                PrintExtraRequiredEvent.NAME_SELL_RECEIPT,                new PrintExtraRequiredEventProcessor() {                }                )            В службе, в методе PrintExtraRequiredEventProcessor укажите место и массив данных, которые требуется распечатать:    new PrintExtraRequiredEventProcessor() {    @Override    public void call(String s, PrintExtraRequiredEvent printExtraRequiredEvent, Callback callback) {        List&lt;SetPrintExtra&gt; setPrintExtras = new ArrayList&lt;SetPrintExtra&gt;();        setPrintExtras.add(new SetPrintExtra(                //Метод, который указывает место, где будут распечатаны данные.                new PrintExtraPlacePrintGroupTop(null),                //Массив данных, которые требуется распечатать.                new IPrintable[]{                        new PrintableText(\"&lt;Текст&gt;\"),                        new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39),                        new PrintableImage(BitmapFactory.decodeFile(\"&lt;путь к файлу изображения&gt;\"))                }        ));      }    }         Примечание: Наполняйте массив IPrintable только теми элементами, которые требуется распечатать. Например, если на чеке необходимо распечатать только штрихкод, в массив следует добавить только элемент new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39). Пустые элементы в массиве IPrintable приведут к исключению.  ПримерПечать внутри кассового чека продажи и возврата в демонстрационном приложении.Ниже приведена служба, которая передаёт данные для печати с помощью всех доступных методов:processorMap.put(                PrintExtraRequiredEvent.NAME_SELL_RECEIPT,                new PrintExtraRequiredEventProcessor() {                    @Override                    public void call(String s, PrintExtraRequiredEvent printExtraRequiredEvent, Callback callback) {                        List&lt;SetPrintExtra&gt; setPrintExtras = new ArrayList&lt;SetPrintExtra&gt;();                        setPrintExtras.add(new SetPrintExtra(                                new PrintExtraPlacePrintGroupTop(null),                                new IPrintable[]{                                        new PrintableText(\"&lt;Текст&gt;\"),                                        new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39),                                        new PrintableImage(BitmapFactory.decodeFile(\"&lt;путь к файлу изображения&gt;\"))                                }                        ));                        setPrintExtras.add(new SetPrintExtra(                                new PrintExtraPlacePrintGroupHeader(null),                                new IPrintable[]{                                        new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39),                                        new PrintableText(\"&lt;Текст&gt;\")                                }                        ));                        setPrintExtras.add(new SetPrintExtra(                                new PrintExtraPlacePrintGroupSummary(null),                                new IPrintable[]{                                        new PrintableText(\"&lt;Текст&gt;\"),                                        new PrintableImage(BitmapFactory.decodeFile(\"&lt;путь к файлу изображения&gt;\")),                                        new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39),                                        new PrintableText(\"&lt;Текст&gt;\")                                }                        ));                        Receipt r = ReceiptApi.getReceipt(DiscountService.this, Receipt.Type.SELL);                        if (r != null) {                            for (Position p : r.getPositions()) {                                setPrintExtras.add(new SetPrintExtra(                                        new PrintExtraPlacePositionFooter(p.getUuid()),                                        new IPrintable[]{                                                new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39),                                                new PrintableText(\"&lt;Текст&gt;\\n\" + p.getUuid() + \"\\n&lt;Текст&gt;\")                                        }                                ));                                setPrintExtras.add(new SetPrintExtra(                                        new PrintExtraPlacePositionAllSubpositionsFooter(p.getUuid()),                                        new IPrintable[]{                                                new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39),                                                new PrintableText(\"&lt;Текст&gt;\\n\" + p.getUuid() + \"\\n&lt;Текст&gt;\")                                        }                                ));                            }                        }                        try {                            callback.onResult(new PrintExtraRequiredEventResult(setPrintExtras).toBundle());                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                }        );",
        "url": "doc_java_receipt_print.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-scales-html": {
        "title": "Работа с весами",
        "tags": "[]",
        "content": "Чтобы получить данные от весов:      В колбэке onCreate() или при запуске операции (activity) инициализируйте класс ru.evotor.devices.commons.DeviceServiceConnector:    DeviceServiceConnector.startInitConnections(getApplicationContext());    Класс инициализируется асинхронно, чтобы не препятствовать вызывающему потоку     Совет: Воспользуйтесь методом addConnectionWrapper, чтобы получить событие об успешном подключении. Используйте это событие, если необходимо выполнить какой-либо код сразу после установки соединения.        Вызовите метод DeviceServiceConnector.getScalesService().    Метод не может быть null и в случае успеха возвращает объект ru.evotor.devices.commons.IScalesServiceWrapper.    Метод может вернуть следующие исключения (exception):          ru.evotor.devices.commons.exception.ServiceNotConnectedException возвращается в результате серии неудачных попыток подключиться к весам.      ru.evotor.devices.commons.exception.DeviceServiceException – наследованое исключение.            С помощью метода Weight getWeight(int deviceId), объекта ru.evotor.devices.commons.IScalesService, вы можете получить вес товара Weight.    Где:    deviceId – указывает устройство, для которого вызывается метод.     Важно: В настоящий момент приложения не могут получить список номеров подключённых устройств, поэтому вместо номера устройства всегда следует передавать константу ru.evotor.devices.commons.Constants.DEFAULT_DEVICE_INDEX. Будет использовано устройство, заданное по умолчанию.    Weight – вес товара, заданный в виде:    private final BigDecimal weightInGrams;//вес товара в граммах, возвращённый весами.// поддерживали ли весы флаг стабильности при последнем взвешиванииprivate final boolean supportStable;//Указывает был установлен флаг стабильности при последнем взвешивании или нет.private final boolean stable;//Указывает стабильность последнего взвешивания.      Метод может вернуть наследованное исключение ru.evotor.devices.commons.exception.DeviceServiceException.",
        "url": "doc_java_scales.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-session-html": {
        "title": "Получение информации о кассовых сменах",
        "tags": "[]",
        "content": "ОписаниеС помощью методов класса SystemStateApi.kt приложения получают информацию о кассовой смене.МетодыgetLastSessionNumberfun getLastSessionNumber(context: Context): Long?ОписаниеПолучает номер последней кассовой смены.Параметры  context – контекст приложения.Возвращает  Long – номер кассовой смены.isSessionOpenedfun isSessionOpened(context: Context): Boolean?ОписаниеВозвращает информацию о состоянии кассовой смены.Параметры  context – контекст приложения.Возвращает  true – смена открыта.  false – смена закрыта.ПримерПример использования методов SystemStateApi.kt. Примечание: Соответствующие кнопки требуется зарегистрировать в манифесте приложения.package &lt;Ваш packagename&gt;import android.os.Bundleimport android.support.v7.app.AppCompatActivityimport android.widget.Buttonimport ru.evotor.framework.system.SystemStateApiclass IntegrationLibraryApiTestActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        //Вызов суперкласса onCreate, создающего операцию.        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_integration_library_api_test)        //Кнопка, нажатиже на которую возвращает номер последней кассовой смены.        findViewById&lt;Button&gt;(R.id.get_last_session_number).setOnClickListener {            getLastSessionNumber()        }        //Кнопка, нажатиже на которую возвращает информацию состоянии кассовой смены.        findViewById&lt;Button&gt;(R.id.get_is_session_opened).setOnClickListener {            getIsSessionOpened()        }    }    //Функция, реализующая метод получения номера последней кассовой смены    //SystemStateApi.getLastSessionNumber()    private fun getLastSessionNumber() {        val lastSessionNumber = SystemStateApi.getLastSessionNumber(this)        if (lastSessionNumber != null) {            //Выводит на экран номер последней кассовой смены.            println(\"lastSessionNumber = $lastSessionNumber\")        } else {            //Выводит на экран сообщение, если номер кассовой смены получить не удалось.            println(\"Не удалось получить номер последней кассовой смены.\")        }    }    //Функция, реализующая метод получения информации о состоянии кассовой смены    //SystemStateApi.isSessionOpened()    private fun getIsSessionOpened() {        val isSessionOpened = SystemStateApi.isSessionOpened(this)        if (isSessionOpened != null) {            //Выводит на экран состояние текущей кассовой смены.            println(\"isSessionOpened = $isSessionOpened\")        } else {            //Выводит на экран сообщение, если состояние кассовой смены получить не удалось.            println(\"Не удалось определить состояние текущей кассовой смены.\")        }    }}",
        "url": "doc_java_session.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-st-events-html": {
        "title": "Обработка событий смарт-терминала",
        "tags": "[]",
        "content": "Получение событий об открытии чека, обновлении базы товаров или результате изменения чекаСмарт-терминал не ждёт ответ от приложения на широковещательные сообщения. Чтобы получать сообщения о результате изменения позиций в чеке, зарегистрируйте приёмник широковещательных сообщений:package ru.evotor.consumer.consumer;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.widget.Toast;import ru.evotor.framework.core.action.event.receipt.position_edited.PositionAddedEvent;public class AddPositionBroadcastReceiver extends BroadcastReceiver {    @Override    public void onReceive(Context context, Intent intent)        { Toast.makeText(context, \"UUID: \" + PositionAddedEvent.create(intent.getExtras()).getReceiptUuid(), Toast.LENGTH_LONG).show(); }    }}Объявите приёмник в манифесте приложения:&lt;receiver        android:name=\".AddPositionBroadcastReceiver\"        android:enabled=\"true\"        android:exported=\"true\"&gt;        &lt;intent-filter&gt;            &lt;action android:name=\"evotor.intent.action.receipt.sell.POSITION_ADDED\" /&gt;            &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;        &lt;/intent-filter&gt;    &lt;/receiver&gt;Сообщения о результатах изменения чекаСобытие открытия чекаПри открытии чека (продажи или возврата) приходит сообщение:public interface ReceiptOpenedEvent {    String BROADCAST_ACTION_SELL_RECEIPT = \"evotor.intent.action.receipt.sell.OPENED\";    String BROADCAST_ACTION_PAYBACK_RECEIPT = \"evotor.intent.action.receipt.payback.OPENED\";    String KEY_UUID = \"uuid\";}Событие добавления позиции в чекПри добавлении позиции приходит сообщение:public class PositionAddedEvent extends PositionEvent {    public static final String BROADCAST_ACTION_SELL_RECEIPT = \"evotor.intent.action.receipt.sell.POSITION_ADDED\";    public static final String BROADCAST_ACTION_PAYBACK_RECEIPT = \"evotor.intent.action.receipt.payback.POSITION_ADDED\";    public PositionAddedEvent(Bundle extras) {        super(extras);    }    public PositionAddedEvent(String receiptUuid, Position position) {        super(receiptUuid, position);    }}Событие изменения позиции в чекеПри изменении позиции приходит сообщение:public class PositionEditedEvent extends PositionEvent {    public static final String BROADCAST_ACTION_SELL_RECEIPT = \"evotor.intent.action.receipt.sell.POSITION_EDITED\";    public static final String BROADCAST_ACTION_PAYBACK_RECEIPT = \"evotor.intent.action.receipt.payback.POSITION_EDITED\";    public PositionEditedEvent(Bundle extras) {        super(extras);    }    public PositionEditedEvent(String receiptUuid, Position position) {        super(receiptUuid, position);    }}Событие удаления позиции из чекаПри удалении позиции приходит сообщение:public class PositionRemovedEvent extends PositionEvent {    public static final String BROADCAST_ACTION_SELL_RECEIPT = \"evotor.intent.action.receipt.sell.POSITION_REMOVED\";    public static final String BROADCAST_ACTION_PAYBACK_RECEIPT = \"evotor.intent.action.receipt.payback.POSITION_REMOVED\";    public PositionRemovedEvent(Bundle extras) {        super(extras);    }    public PositionRemovedEvent(String receiptUuid, Position position) {        super(receiptUuid, position);    }}Событие обновления базы товаровПри обновлении базы товаров приходит сообщение:public class PositionRemovedEvent extends PositionEvent {    public static final String BROADCAST_ACTION_PRODUCTS_UPDATED = \"evotor.intent.action.inventory.PRODUCTS_UPDATED\";    public ProductsUpdatedEvent(Bundle extras) {        super(extras);    }    public ProductsUpdatedEvent(String receiptUuid, Position position) {        super(receiptUuid, position);    }}Событие очистки чекаПри очистке чека приходит сообщение:public class ReceiptClearedEvent extends ReceiptEvent {    public static final String BROADCAST_ACTION_SELL_RECEIPT_CLEARED = \"evotor.intent.action.receipt.sell.CLEARED\";    public static final String BROADCAST_ACTION_PAYBACK_RECEIPT_CLEARED = \"evotor.intent.action.receipt.payback.CLEARED\";    public ReceiptClearedEvent(@NonNull String receiptUuid) {        super(receiptUuid);    }    @Nullable    public static ReceiptClearedEvent create(@Nullable Bundle bundle) {        if (bundle == null) {            return null;        }        String receiptUuid = getReceiptUuid(bundle);        if (receiptUuid == null) {            return null;        }        return new ReceiptClearedEvent(receiptUuid);    }}Событие смены пользователяПри смене пользователя приходит сообщение:public class UserChangedEvent extends UserEvent {    public static final String BROADCAST_ACTION_USER_CHANGED = \"evotor.intent.event.user.CHANGED\";    public UserChangedEvent() {        super();    }    @Nullable    public static UserChangedEvent create(@Nullable Bundle bundle) {        if (bundle == null) {            return null;        }        return new UserChangedEvent(bundle);    }}Логирование различных событий смарт-терминалаНиже представлен пример логирования событий, которые может распространять смарт-терминал. Для обработки таких событий также требуется создавать приёмник широковещательных сообщений.public class MyReceiver extends BroadcastReceiver {    @Override    public void onReceive(Context context, Intent intent) {        String action = intent.getAction();        Bundle bundle = intent.getExtras();        Log.e(\"TAG\", action);        if (action.equals(\"evotor.intent.action.cashDrawer.OPEN\")) {            CashDrawerOpenEvent.create(bundle);//Открытие денежного ящика.        } else if (action.equals(\"evotor.intent.action.cashOperation.CASH_IN\")) {            Log.e(\"TAG\", \"total\" + CashInEvent.create(bundle).getTotal().toPlainString());//Внесение наличных.            Log.e(\"TAG\", \"uuid\" + CashInEvent.create(bundle).getDocumentUuid());        } else if (action.equals(\"evotor.intent.action.cashOperation.CASH_OUT\")) {            Log.e(\"TAG\", \"total\" + CashOutEvent.create(bundle).getTotal().toPlainString());//Изъятие наличных.            Log.e(\"TAG\", \"uuid\" + CashOutEvent.create(bundle).getDocumentUuid());        } else if (action.equals(\"evotor.intent.action.inventory.CARD_OPEN\")) {            Log.e(\"TAG\", \"uuid\" + ProductCardOpenedEvent.create(bundle).getProductUuid());//Открытие карточки товара.        } else if (action.equals(\"evotor.intent.action.receipt.sell.CLEARED\")) {            Log.e(\"TAG\", \"uuid\" + ReceiptClearedEvent.create(bundle).getReceiptUuid());//Очистка чека продажи (создание нового чека).        } else if (action.equals(\"evotor.intent.action.receipt.payback.CLEARED\")) {            Log.e(\"TAG\", \"uuid\" + ReceiptClearedEvent.create(bundle).getReceiptUuid());//Очистка чека возврата (создание нового чека).        } else if (action.equals(\"evotor.intent.action.receipt.sell.RECEIPT_CLOSED\")) {            Log.e(\"TAG\", \"uuid\" + ReceiptClosedEvent.create(bundle).getReceiptUuid());//Закрытие чека продажи.        } else if (action.equals(\"evotor.intent.action.receipt.payback.RECEIPT_CLOSED\")) {            Log.e(\"TAG\", \"uuid\" + ReceiptClosedEvent.create(bundle).getReceiptUuid());//Закрытие чека возврата.        } else if (action.equals(\"evotor.intent.action.receipt.sell.OPENED\")) {            Log.e(\"TAG\", \"uuid\" + ReceiptOpenedEvent.create(bundle).getReceiptUuid());//Открытие чека продажи.        } else if (action.equals(\"evotor.intent.action.receipt.payback.OPENED\")) {            Log.e(\"TAG\", \"uuid\" + ReceiptOpenedEvent.create(bundle).getReceiptUuid());//Открытие чека возврата.        }    }}",
        "url": "doc_java_st_events.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-third-party-service-communication-html": {
        "title": "Обмен сообщениями приложения и стороннего сервиса",
        "tags": "[]",
        "content": "Все запросы приложений к стороннему сервису проходят через Облако Эвотор:Для отправки запросов приложения могут использовать только 80 и 443 порт.Смарт-терминал не поддерживает протокол WebSocket. Важно: Установленные на смарт-терминале приложения могут обращаться только к сторонним сервисам. При этом, если сторонние сервисы находятся в одной локальной сети со смарт-терминалом, облако не проксирует запросы. Обращаться к REST API Облака Эвотор нельзя.Подготовка к отправке запросовДля отправки запросов требуется:  На портале dev.evotor.ru, указать список разрешённых URL, к которым может обращаться приложение.  Поддержать возможность обращения к сторонним сервисам в приложении.      Установить приложение в Магазине приложений.    В данном случае установка подразумевает активацию приложения в Личном кабинете и необходима, чтобы применились URL, которые вы указали на сайте разработчиков.   Примечание: Если вы разрабатываете JS-приложение, смотрите раздел “Обмен сообщениями JS-приложения и стороннего сервиса”.Настройка списка разрешённых URLЧтобы настроить список разрешённых URL:  На портале dev.evotor.ru выберите приложение, для которого требуется указать список разрешённых URL.  На вкладке Интеграция, установите флажок Проксирование запросов из приложения с терминала на ваш сервер (ver. 2) и укажите список URL, к которым может обращаться приложение.Примеры:  http://example\\.com/document.*\\.jsp\\?wildcard=\\*&amp;param=value.*;  https://another\\.host\\.com/document.*\\.jsp;  https://another\\.host\\.com/.*. Совет: Чтобы задавать маски веб-сайтов используйте регулярные выражения.После создания списка и установки приложения в Магазине приложений, обмен сообщениями происходит по описанному ниже процессу.Шаг 1. Приложение отправляет HTTP-сообщение в сторонний сервисПриложение создаёт HTTP-сообщение и отправляет его в сторонний сервис. Вы можете воспользоваться любым удобным способом отправки сообщения.Например, для отправки HTTP-сообщения из Java-приложения вы можете, использовать библиотеку OkHttp или способ, описанный на сайте developer.android.com.Независимо от версии проксирования, SDK смарт-терминала и Облако Эвотор поддерживают следующие HTTP-методы:  GET;  POST;  PUT;  DELETE.Эвотор гарантирует поддержку следующих MIME-типов:  application/x-www-form-urlencoded  application/json  application/xml  text/*  image/*  multipart/form-dataПоддержка других MIME-типов не гарантируется.Шаг 2. Смарт-терминал передаёт сообщение в облакоТерминал перехватывает сообщение и передаёт его в облако Эвотор.Заголовки, которые терминал добавляет к запросу вашего приложения:  X-Device-ID  X-Device-IMEI  X-User-ID  X-Signed-Url  X-Shop-UUID  X-Device-Salt  X-Device-Algorithm  X-Device-Date  X-Secret-Device-ID  X-OAuth-Client-ID  X-Device-UUID  X-Evotor-*  Expect  Host  Transfer-Encoding Примечание: Убедитесь, что ваше приложение не использует перечисленные заголовки. В противном случае, смарт-терминал перезапишет их содержимое.Шаг 3. Облако передаёт сообщение адресатуОблако удаляет служебные заголовки, добавляет свои заголовки и передаёт сообщение адресату.Заголовки, которые добавляет облако:  X-Evotor-Store-Uuid – содержит идентификатор магазина в формате uuid4, к которому привязан терминал.  X-Evotor-Device-UUID – содержит идентификатор устройства в формате uuid4, полученный по запросу к /api/v1/inventories/devices.  X-Evotor-User-Id – содержит идентификатор пользователя в Облаке Эвотор.  Authorization – содержит токен пользователя приложения стороннего сервиса. Токен необходим для bearer-авторизации.Сторонний сервер получает сообщение от облака Эвотор и определяет отправителя с помощью заголовка Authorization.Шаг 4. Ответ стороннего сервисаОтвет стороннего сервиса передаётся приложению в обратном порядке.Требования к содержимому ответа отсутствуют. Совет: За проксирование отвечает параметр Проксирование запросов из приложения с терминала на ваш сервер на вкладке Интеграция вашего приложения, на сайте dev.evotor.ru.",
        "url": "doc_java_third_party_service_communication.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-java-z-report-html": {
        "title": "Печать Z-отчёта",
        "tags": "[]",
        "content": "Чтобы напечатать z-отчёт:      В манифесте укажите права приложения:    &lt;uses-permission android:name=\"ru.evotor.permission.PRINT_Z_REPORT\" /&gt;            Создайте команду для снятия чека и вызовите метод .process:    new PrintZReportCommand().process(context, callback);        Результатом выполнения команды будет печать z-отчёта.  ",
        "url": "doc_java_z_report.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "java-examples-html": {
        "title": "Примеры реализации",
        "tags": "[&quot;publishing&quot;, &quot;stuff&quot;]",
        "content": "integration-library          Integration-library-example      Приложение, демонстрирующее возможности библиотеки integration-library.      egais-api          Egais-api-example      Приложение, демонстрирующее возможности библиотеки egais-api.      ",
        "url": "java_examples.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "java-introduction-html": {
        "title": "Введение",
        "tags": "[]",
        "content": "Информация, представленная в этом разделе, поможет вам при разработке Java-приложения.В разделе представлены Javadoc-справочники наших библиотек integration",
        "url": "java_introduction.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "java-query-api-html": {
        "title": "Обращение к базе данных смарт-терминала",
        "tags": "[]",
        "content": "С помощью запросов к базе данных смарт-терминала приложения могут получать необходимую информацию, например, данные товаров (класс ProductQuery.kt).Построение запросаПример запроса для получения данных товара:const products = await new ProductQuery()        .alcoholByVolume.between(40, 70)        .intersection(new ProductQuery()            .price.greater(100, true)            .or().tareVolume.greater(10)            .union(new ProductQuery()                .price.lower(5)                .and().name.like(\"Водка\")            )        ).sortOrder(new ProductSortOrder()            .price.asc()            .alcoholByVolume.desc()            .tareVolume.asc()        ).limit(1000)        .execute();ОператорыОператоры сравненияДля построения запросов доступны следующие операторы сравнения:  fun equal(value: V) – аналогичен оператору “равно” =.  fun notEqual(value: V) – аналогичен оператору “не равно” !=.  fun greater(value: V, including: Boolean = false) – аналогичен оператору “больше” &gt;.  fun lower(value: V, including: Boolean = false) – аналогичен оператору “меньше” &lt;.  fun like(text: String, escape: Char? = null) – определяет совпадает ли символьная строка с заданным шаблоном. Где escape – символ, предшествующий спецсимволам, если их надо использовать в прямом из значении (например, “%”), аналогично синтаксису SQL.  fun between(leftValue: V, rightValue: V) – задаёт диапазон для проверки.  fun notBetween(leftValue: V, rightValue: V) – задаёт диапазон, за пределами которого находится удовлетворяющий условию результат.  fun inside(values: List&lt;V&gt;) – определяет находится ли значение в заданном списке.  fun inside(values: Array&lt;V&gt;) – определяет находится ли значение в заданном массиве.  fun notInside(values: List&lt;V&gt;) – определяет находится ли значение за пределами заданного списка.  fun notInside(values: Array&lt;V&gt;) – определяет находится ли значение за пределами заданного массива.Логические операторыДля построения запросов доступны следующие логические операторы:  and(intersection: Executor&lt;Q, S, R&gt;) – логическое “И” (пересечение).  or(union: Executor&lt;Q, S, R&gt;) – логическое “ИЛИ” (объединение).  and(): Q – логическое “И”.  or(): Q – логическое “ИЛИ”.ПримерПример приложения, которое получает данные товара.",
        "url": "java_query_api.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-1c-integration-html": {
        "title": "Интеграция с 1С",
        "tags": "[]",
        "content": "Конфигурация 1С, установленная на компьютере пользователя, и обменивается данными с Эвотором с помощью REST API. Эвотор авторизует запросы от 1С с помощью токена приложения, который пользователь может получить на странице Настройки приложения в Личном кабинете.Ключ для интеграции с 1СЧтобы приложение работало корректно, убедитесь, что вы включили необходимые опции на вкладке Интеграция приложения, на сайте разработчиков:      Признак товароучетной системы, получение номенклатуры и остатков в стороннем сервисе и запрет редактирования товаров. Поля заполнять не требуется.        Получать документы из облака Эвотор.        Создать вкладку “Настройки” на странице приложения. В поле Значение поля укажите ${token}, чтобы токен приложения отображался в соответствующем поле, в закладке Настройки приложения.        Управлять номенклатурой в облаке Эвотор.        Получать номенклатуру из облака Эвотор.  При оформлении приложения следуйте ограничениям, описанным на сайте разработчиков. Когда вы оформите и протестируете приложение, и будете готовы выложить его в открытый доступ, нам потребуется провести приёмочное тестирование. О готовности приложения сообщите по адресу developer@evotor.ru.Приёмочное тестирование включает следующие проверки:  Эвотор авторизует запросы приложения с помощью токена, указанного на странице Настройки.      Приложение сопоставляет сущности Эвотора (смарт-терминалы, сотрудников и магазины) и 1С.    Сопоставление сущностей Облака Эвотор и 1С        Приложение передаёт товары из 1С в Эвотор. Проверяется:          Корректность данных: данные соответствуют описанию в Справочнике REST API.      Сжатие запросов в gzip.      Передача товаров пачками (актуально для большой базы товаров)        Приложение удаляет товары в Эвоторе как поштучно, так и все товары одновременно.      Приложение загружает документы из Эвотора. Проверяется:          Загрузка документов как по всему магазину, так и по конкретному смарт-терминалу (deviceUuid).      Загрузка определённого типа документов (см. запрос Получить список документов/.      Корректность дат в GET-параметрах.      Обработка возвращаемых ошибок.      После того как приложение пройдёт приёмочное тестирование, мы выложим его в открытый доступ.",
        "url": "doc_1C_integration.html",
        "product": ""
      }
      ,
      
    
          
      "doc-about-billing-html": {
        "title": "О биллинге",
        "tags": "[]",
        "content": "Эвотор определяет кто выполняет биллинг пользователя в зависимости от того, работает пользователь с существующей учётной записью стороннего сервиса или создаёт новую из Личного кабинета.Кто выполняет биллингЭвотор выполняет биллинг, если пользователь создал новую учётную запись в стороннем сервисе после установки приложения, из Личного кабинета Эвотор (сторонний сервис должен поддерживать URL /api/v1/user/create). В этом случае, при создании новой учётной записи, сторонний сервис возвращает параметр \"hasBilling\": \"False\". Впоследствии, при авторизации с помощью такой учётной записи, сторонний сервис всегда возвращает \"hasBilling\": \"False\".Сторонний сервис выполняет биллинг, если после установки приложения пользователь авторизовался с помощью учётной записи, созданной не из Личного кабинета. (сторонний сервис должен поддерживать URL /api/v1/user/verify). Сторонний сервис возвращает параметр \"hasBilling\": \"True\" после авторизации пользователя, если биллинг выполняет сторонний сервис.Все изменения, связанные с подпиской, Эвотор отправляет по адресу partner.ru/api/v1/user/event.Данные о биллинге пользователейЭвотор отправляет данные о биллинге пользователей на URL partner.ru/api/v1/user/event:  SubscriptionCreated – новая подписка.  SubscriptionActivated – активирована платная фаза подписики. Эвотор передаёт сообщение, если пользователь решил продолжить использовать приложение после завершения пробного периода.  SubscriptionRenewed – подписка продлена на следующий период.  SubscriptionCancelled – подписка отменена.      SubscriptionTermsChanged – изменились условия подписки, например, тарифный план или количество устройств.    Стороннему сервису достаточно подписаться на эти сообщения. Эвотор гарантирует доставку сообщений и не требует подтверждения получения.  Подробное описание передаваемых данных и способов авторизации смотрите в справочнике API.",
        "url": "doc_about_billing.html",
        "product": ""
      }
      ,
      
    
          
      "doc-app-developer-mode-html": {
        "title": "Включение режима разработчика",
        "tags": "[]",
        "content": "Режим разработчика позволяет:  устанавливать приложение на смарт-терминал с помощью ADB, без необходимости загружать его в магазин приложений;  просматривать логи приложения с помощью утилиты LogCat  подключать отладчик приложения.Чтобы включить режим разработчика:  На dev.evotor.ru выберите необходимое приложение.      На вкладке Версии, выберите необходимую версию приложения и перейдите на вкладку APK.     Примечание: Одновременно у вас в разработке не может быть более двух версий приложения.        На вкладке APK:                  Если вы хотите, чтобы тестировщики могли установить приложение из Магазина приложений, выберите Загрузить APK.        После того как вы загрузите APK, поля Код версии и Package name автоматически заполнятся значениями, указанными в APK приложения.                    Если вы хотите вручную устанавливать приложение на смарт-терминал с помощью ADB, выберите Ввести ID пакета вручную.        Вам потребуется вручную указать имя пакета вашего приложения, в поле ID пакета. Код версии в этом случае указывать не требуется.                  На вкладке Версии, выберите необходимую версию и нажмите на кнопку Выложить на тест.    Вам может потребоваться заполнить данные профиля и указать платёжные данные. Для тестов вы можете указать любые данные.    На вкладке Тестирование укажите номер телефона учётной записи, для которой требуется включить режим разработчика.  Выберите тип пользователя Разработчик приложения на терминале Эвотор и нажмите на кнопку Добавить.Режим разработчика включается на всех терминалах, зарегистрированных на указанный номер телефона.Режим разработчика действует только для приложения с заданным packageName. Совет: Если режим разработчика не включился сразу после добавления разработчика, попробуйте выключить и включить wi-fi.В панели уведомлений смарт-терминалов, зарегистрированных на указанный номер, появится сообщение:Режим разработчика активенADB: &lt;IP-адрес&gt;:&lt;порт&gt;Для подключения к смарт-терминалу в Android Studio, используйте команду:adb connect &lt;IP-адрес&gt;:&lt;порт&gt;",
        "url": "doc_app_developer_mode.html",
        "product": "Generic"
      }
      ,
      
    
          
      "doc-app-installation-html": {
        "title": "Установка приложения",
        "tags": "[]",
        "content": "Вы можете установить приложение на терминал:  из Магазина приложений;  с помощью ADB Shell.Установка приложения из магазина приложенийУстановить приложение из Магазина могут только пользователи в роли Тестировщик.Чтобы установить приложение из Магазина приложений:      Создайте приложение на сайте dev.evotor.ru.    Если вы разрабатываете приложение для смарт-терминала, при создании приложения установите флажок, который сообщает о наличии apk-файла.        Выберите или создайте новую версию приложения, которую требуется протестировать.        На вкладке APK, загрузите apk-файл своего приложения.    Если вы уже загружали apk-файл, обратите внимание, что значение параметра versioncode нового apk-файла, должно быть больше, чем у уже загруженного.     Совет: Пропустите этот шаг, если вы разрабатываете облачное приложение и вы не устанавливали флажок, который сообщает о наличии apk-файла.        На вкладке Тестирование, добавьте номера телефонов аккаунтов market.evotor.ru, которым будет доступно приложение для тестирования.        На вкладке Версии выберите версию, которую требуется протестировать и нажмите кнопку Выложить на тест.        Войдите в Личный кабинет на сайте market.evotor.ru используя номер телефона тестировщика.        Установите приложение из Магазина приложений.    Флажок установки приложения  Необходимая версия приложения будет установлена на смарт-терминал, привязанный к этому аккаунту.Проблемы при установке приложения из Магазина приложенийЕсли у вас возникли проблемы при установке приложения:  Убедитесь, что на сайте разработчиков создано приложение Приложение с APK;  Убедитесь, что на вкладке APK, на странице приложения, на сайте разработчиков, загружен apk-файл приложения;  Убедитесь, что приложение, которое требуется установить на смарт-терминал, опубликовано или находится в одном из статусов: в тестировании или ревью.  На вкладке Установка/Удаление, на странице приложения в Магазине приложений снимите флажок со смарт-терминала на котором требуется установить приложение и нажмите кнопку Применить. Затем повторно установите флажок и нажмите кнопку Применить.  При установке приложения из Магазина приложений на смарт-терминал со включённым режимом разработчика, убедитесь, что на смарт-терминале установлена прошивка не ниже версии 3.0.*. В противном случае, отключите режим разработчика.  Ознакомьтесь с инструкциями, представленными на странице устранения проблем.Установка приложения с помощью ADB ShellДля установки с помощью ADB Shell вам потребуется:  смарт-терминал с включённым режимом разработчика.  Android Studio. Примечание: Перед установкой убедитесь, что ваш компьютер и смарт-терминал находятся в одной сети wi-fi.Чтобы установить приложение с помощью ADB Shell:      На вкладке APK вашего приложения, на сайте dev.evotor.ru, нажмите на кнопку Ввести ID пакета вручную и укажите package name своего приложения в поле ID пакета.    Вы также можете нажать на кнопку Загрузить APK и загрузить APK своего приложения на сайт. В этом случае поле ID пакета будет заполнено автоматически.        Выложите приложение на тест.        В консоли Android Studio подключитесь к смарт-терминалу с помощью команды:    adb connect &lt;IP-адрес&gt;:&lt;порт&gt;        Выполните команду:    adb install &lt;адрес apk-файла&gt;  Приложение установится на смарт-терминал.Проблемы при установке приложения с помощью ADB ShellЕсли у вас возникли проблемы при установке приложения:  Убедитесь, что на смарт-терминале включён режим разработчика;  Убедитесь, что на сайте разработчиков создано приложение Приложение с APK;  Убедитесь, что app_uuid и packageID указанные на вкладке APK, на странице приложения на сайте разработчиков, совпадают со значениями заданными в манифесте приложения;  Убедитесь, что смарт-терминал привязан к аккаунту, с ролью разработчика на вкладке Тестирование, на странице приложения на сайте разработчиков.  Ознакомьтесь с инструкциями, представленными на странице устранения проблем.",
        "url": "doc_app_installation.html",
        "product": "Generic"
      }
      ,
      
    
          
      "doc-app-review-html": {
        "title": "Черновики, модерация и публикация приложения",
        "tags": "[]",
        "content": "Наши сотрудники модерируют каждое приложение перед публикацией. Процесс модерации называется ревью.Модерация приложения длится пять рабочих дней.Вы можете передать на ревью не более одной версии приложения. Приложение, переданное на ревью, приобретает статус Ожидает ревью. Изменять приложение, переданное на ревью, нельзя.Статус приложения, переданного на ревьюВ процессе модерации могут возникнуть замечания, которые вам потребуется устранить. Для этого наши сотрудники переводят приложение обратно в статус черновика.Модерация исправленной версии начинается сначала и также проходит в течение пяти рабочих дней.После устранения всех замечаний, сотрудники Эвотора публикуют приложение. С этого момента приложение можно приобрести в Магазине приложений.После публикации приложения вы можете создать новый черновик.Таким образом одновременно у вас может быть не более трёх версий приложения: одна опубликованная версия и два черновика. Примечание: При публикации обновления, текущая опубликованная версия приложения автоматически переносится в архив.",
        "url": "doc_app_review.html",
        "product": ""
      }
      ,
      
    
          
      "doc-app-tariffication-html": {
        "title": "О тарификации приложений",
        "tags": "[]",
        "content": " Важно: Цены, приведённые в разделе, являются ориентировочными. Каждый тариф модераторы Эвотора проверяют и согласуют отдельно.О тарификации приложенийПлатная подписка на приложение является основным инструментом монетизации ваших приложений. Рассчитывайте стоимость подписки с учётом технической поддержки пользователей. Также учитывайте, что многие клиенты, например, муниципальные предприятия, не могут оплачивать подписку ежемесячно. Поэтому, мы рекомендуем включить в вашу тарифную линейку годовые подписки. Примечание: Скидка при оформлении годовых подписок не может превышать 10%.Возможно также распространение приложения за разовую оплату, например, если приложение относится к категории Драйверы. Совет: Вы можете отдельно согласовать тарификацию своего приложения с Эвотором.Ниже приводятся категории приложений и рекомендуемые способы их тарификации. Все возможные исключения необходимо согласовывать с Эвотором.Категории приложений1С Интеграции и приложения, использующие токен в открытом видеПриложения, использующие для авторизации единый токен доступа к функциям API (например, Товароучетный API 1C), имеют единую тарификацию. Это сделано, чтобы избежать подмены токена более дешевым. Тарифы данных приложений должны с указанными здесь.Если вы хотите изменить тарификацию, необходимо обеспечить сохранность токена и поддержать авторизацию на стороне вашего сервиса.Учетные системыМинимальная стоимость приложения категории учетных систем составляет 300 руб./месяц за кассу, с учётом соответствующих скидок.Минимальная стоимость приложения, чей функционал ограничен редактированием товаров и получением информации о продажах, составляет 100 руб./месяц.Кассовые приложенияМинимальная стоимость приложения с функционалом необходимым для работы кассы составляет 50 руб/месяц.Платежные приложения и приложения финансовых сервисовПлатежные приложения и приложения финансовых сервисов как правило бесплатны для клиента и работают по модели разделения прибыли (revenue sharing).Приложения для использования кассы в качестве фискального принтера и другого функционала с ограничением дальнейшего использования по основному назначениюМинимальная стоимость приложения этой категории, а также приложения, значительно изменяющих функционал смарт-терминала, составляет 800 руб./месяц. Это вызвано тем, что изменение функций смарт-терминала снижает или блокирует монетизацию за счёт установки других приложений.Определенные типы API и доступ к даннымОпределенные типы API как и доступ к данным в облаке Эвотор тарифицируются отдельно или требуют минимальной цены приложения. Все подобные изменения мы указываем в рамках этого раздела.Драйверы устройствМинимальная стоимость для драйверов устройств, необходимых для торговли (весы, принтеры этикеток, экраны покупателей, принтеры чеков),  составляет 1000 рублей.При этом, для цену платной подписки можно устанавливать ниже.Стоимость драйверов устройств, распространяющихся с приложениями, может входить в стоимость подписки на приложение. Примечание: Если ваше приложение не относится к приведённым категории, его минимальная цена будет начинаться от 30 руб./месяц. Также вы можете отдельно согласовать тарификацию своего приложения с Эвотором.Заказная разработкаВы можете использовать REST API Облака Эвотор для разработки заказных решений для третьих лиц. При заказной разработке вы можете предложить компании заказчику оплатить только разработку, а само приложение обозначить как бесплатное. В этом случае вам необходимо учитывать, что любое использование нашего API платное и Эвотор будет ежемесячно взимать с вас оплату независимо от ваших договорённостей с заказчиком. Важно: Каждый подобный случай необходимо согласовывать с Эвотором.Временные акции и возможности для продвиженияДля продвижения приложения вы можете продлевать или расширять функционал пробного периода. Продолжительность пробного периода использования приложения должна быть единой и независимой от тарифа, который выбрал пользователь.Другие инструменты для продвижения, например, бесплатные версии, требуется согласовывать с Эвотором отдельно. Warning: Запрещено использовать демпинг и временное значительное снижение цены (не в рамках согласованных акций).",
        "url": "doc_app_tariffication.html",
        "product": ""
      }
      ,
      
    
          
      "doc-app-testing-html": {
        "title": "Перевод приложения в тестирование",
        "tags": "[]",
        "content": "Если вы изменяете APK приложения, добавляете скриншоты, видео и т.п. приложение необходимо выкладывать в тестирование, чтобы изменения вступили в силу. Приложение в тестировании доступно учётным записям, указанным в роли Тестировщик, на вкладке Тестирование.Тестирование приложенияЧтобы протестировать своё приложение выполните следующие действия:  Войдите в личный кабинет разработчика.      Выберите приложение, которое требуется протестировать.    Выбор приложения        На вкладке Тестирование, в разделе Тестировщик, в поле Мобильный телефон, укажите номер телефона, к которому привязана учётная запись Эвотор и нажмите на кнопку Добавить.    Одновременно вы можете добавить не более пяти тестировщиков.    Добавление тестировщика        В разделе Версии нажмите на кнопку Выложить на тест.    Передача приложения в тестирование    Статус приложения изменится на В тестировании    Приложение будет добавлено в тестовом режиме в Магазин приложений. Вы увидите приложение в магазине, если войдёте в Личный кабинет пользователя, зарегистрированный на номер телефона тестировщика, указанный в шаге 3. На иконке приложения будет надпись В разработке.      ",
        "url": "doc_app_testing.html",
        "product": "Generic"
      }
      ,
      
    
          
      "doc-authorization-html": {
        "title": "Авторизация запросов к Облаку Эвотор",
        "tags": "[]",
        "content": "Все запросы к Облаку Эвотор осуществляются в рамках приложения. После установки приложения в Личном кабинете, Облако присваивает ему токен Облака Эвотор, уникальный для пары приложение-пользователь.Передавайте этот токен в заголовке X-Authorization, чтобы авторизовать свои запросы к Облаку.Как получить токен Облака ЭвоторВы можете получить токен Облака Эвотор:  вручную;      автоматически.    Для автоматического получения токена Облака Эвотор вам потребуется поддержать собственный сервис. В документации такой сервис называется сторонним.  Получение токена вручнуюЧтобы получить токен Облака Эвотор вручную:      Войдите в Личный кабинет на сайте разработчиков и выберите созданное приложение.        Выберите необходимый черновик и перейдите на вкладку Интеграция.        В разделе Настройки приложения, включите опцию Создать вкладку “Настройки” на странице приложения.    Опция добавляет вкладку Настройки для приложения установленного в Личном кабинете пользователя Эвотор.        Нажмите кнопку Текстовое поле, в поле Значение поля укажите ${token}.        Сохраните изменения, вернитесь к списку черновиков приложения и переведите необходимый черновик в тестирование.        Войдите в Личный кабинет в Магазине приложений.        На вкладке Мои приложения, выберите приложение, в котором были сделаны изменения.        Перейдите на вкладку Настройки.    На вкладке отображается поле, которое содержит токен Облака Эвотор, необходимый для авторизации запросов к Облаку. Передавайте токен в заголовке X-Authorization.      Автоматическое получение токенаАвтоматически вы можете получить токен Облака Эвотор одним из двух способов:      На адрес partner.ru/api/v1/user/token;        В GET-параметре token веб-адреса iframe-приложения.  Чтобы получить токен Облака Эвотор на адрес partner.ru/api/v1/user/token:      Поддержите в своём сервисе адрес partner.ru/api/v1/user/token.    На указанный адрес Облако передаёт токен Облака Эвотор после его установки в Личном кабинете пользователя. Запросы облака необходимо авторизовать с помощью токена приложения стороннего сервиса.     Примечание: Токен приложения стороннего сервиса – токен, с помощью которого ваш сервис авторизует запросы от Облака Эвотор        Войдите в Личный кабинет на сайте разработчиков и выберите созданное приложение.        Выберите необходимый черновик и перейдите на вкладку Интеграция.        Включите опцию Токен приложения для доступа к REST API Эвотор.        В поле URL, укажите адрес вида partner.ru/api/v1/user/token, на который Облако будет передавать токен Облака Эвотор.        Выберите тип авторизации, с помощью которого ваш сервис будет авторизовать передачу токена Облака Эвотор.                  Если вы выбрали С помощью токена. В поле Токен, укажите токен приложения стороннего сервиса в формате uuid4.        Облако передаёт токен в заголовке Authorization.                    Если вы выбрали Запрос логина и пароля ( Basic Auth ). В полях Логин и Пароль укажите данные для доступа к стороннему сервису.        Облако кодирует логин и пароль с помощью base64 и передаёт закодированные данные в заголовке Authorization.              Подробное описание запроса на передачу токена Облака Эвотор вы найдёте в Справочнике API. Полученный токен передавайте в заголовке X-Authorization, в своих запросах к Облаку.        Сохраните изменения, вернитесь к списку черновиков приложения и переведите необходимый черновик в тестирование.  После того, как пользователь Магазина приложений установит ваше приложение, Облако будет передавать в ваш сервис токен Облака Эвотор.Чтобы получить токен Облака Эвотор в GET-параметре token веб-адреса iframe-приложения:      Войдите в Личный кабинет на сайте разработчиков и выберите созданное приложение.        Выберите необходимый черновик и перейдите на вкладку Интеграция.        В разделе Настройки приложения, включите опцию Создать вкладку “Настройки” на странице приложения.        Нажмите на iframe и укажите необходимые поля.        Сохраните изменения, вернитесь к списку черновиков приложения и переведите необходимый черновик в тестирование.  Iframe будет добавлен на вкладку Настройки, на странице установленного приложения. Облако передаёт токен Облака Эвотор в GET-параметре token веб-адреса iframe:https://partner.org/#/?uid=&lt;example&gt;&amp;token=stringТокен из iframe",
        "url": "doc_authorization.html",
        "product": ""
      }
      ,
      
    
          
      "doc-cloud-systems-integration-html": {
        "title": "Интеграция с облачными сервисами",
        "tags": "[]",
        "content": "Облачная товароучётная система это сторонний сервис, который позволяет  пользователям взаимодействовать с сущностями предприятия: магазинами, сотрудниками и товарами.Для пользователей Эвотора интеграция выглядит как приложение, которое можно купить в Магазине приложений. Купленные приложения отображаются в Личном кабинете, в разделе Мои приложения.Перед интеграцией, убедитесь, что облачная  товароучётная система поддерживает адреса, указанные в таблице ниже.            URL      Назначение      Авторизация      Дополнительно                  https://example.com/api/v1/user/create      Эвотор отправляет по адресу регистрационные данные для создания новой учётной записи в облачной товароучётной системе.      Товароучётная система авторизует запрос облака с помощью имени пользователя и пароля (basic-авторизация) или токена (bearer-авторизация).                     https://example.com/api/v1/user/verify      Эвотор отправляет по адресу данные для авторизации пользователя в облачной товароучётной системе с помощью ранее созданной учётной записи.                            https://example.com/api/v1/user/token      Эвотор отправляет по адресу токен приложения, с помощью которого будет авторизовывать запросы от товароучётной системы.                            https://example.com/api/v1/subscription/event      Эвотор отправляет по адресу события сообщающие об изменении подписки на приложение.                     Примечание: Информацию о сущностях пользователя Эвотор (магазинах, товарах, сотрудниках и смарт-терминалах), товароучётная система получает с помощью запросов к облаку Эвотор.Покупка и активация приложенияЭтап 1В магазине приложений, пользователь выбирает приложение и тариф, и авторизуется в стороннем сервисе одним из двух способов:            Если у пользователя нет учётной записи, Эвотор отправляет в сторонний сервис запрос [POST] Регистрация учётной записи. Тело запроса содержит регистрационные данные, с помощью которых сторонний сервис создаёт учётную запись. Для авторизации своих запросов, Эвотор передаёт заголовок Authorization.        В ответе сервис передаёт облаку токен пользователя (токен, который Эвотор отправляет в вебхуках-уведомлениях и запросах от смарт-терминала).                Если у пользователя есть учётная запись, Эвотор отправляет в сторонний сервис запрос [POST] Авторизация пользователя. Тело запроса содержит данные учётной записи пользоваетя в стороннем сервисе.  Для авторизации своих запросов, Эвотор передаёт заголовок Authorization.        Тело ответа должно содержать параметр haslBilling. В зависимости от значения параметра Эвотор определяет, кто выполняет биллинг пользователя:                                    true – биллинг пользователя выполняет сторонний сервис;                                        false – биллинг пользователя выполняет Эвотор.                            Содержимое заголовка Authorization вы задаёте на портале разработчиков, при создании приложения. В зависимости от типа авторизации (basic или bearer), который поддерживает сторонний сервис, заголовок может содержать имя пользователя и пароль для доступа к стороннему сервису, закодированные в base64, или токен стороннего сервиса.Этап 2Эвотор передаёт в сторонний сервис событие SSubscriptionCreated. Событие содержит поля, которые указывают на начало пробного периода использования приложения. В дальнейшем, при изменении подписки, Облако передаёт в сторонний сервис другие события биллинга.Удаление и деактивация приложенияЭвотор останавливает интеграцию и удаляет приложение если:  пользователь самостоятельно удалил приложение в разделе Мои приложения в Личном кабинете пользователя Эвотор;  у пользователя недостаточно средств для продления подписки.В этом случае, за пять дней до отключения приложения, Эвотор начинает рассылать пользователю смс с предупреждением о скором отключении приложения.В обоих случаях, после удаления приложения, Эвотор передаёт в сторонний сервис запрос [POST] Активация / деактивация тарифа с состоянием INACTIVE.Повторная установка приложенияПри повторной установке приложения, Эвотор проверяет истёк пробный период использования приложения или нет. Так же, в зависимости от значения параметра hasBilling, возможно изменение стороны ответственной за биллинг пользователя.Подробная схема покупки и установки приложенияСхема покупки и установки приложения",
        "url": "doc_cloud_systems_integration.html",
        "product": ""
      }
      ,
      
    
          
      "doc-dev-introduction-html": {
        "title": "Введение в раздел разработки",
        "tags": "[]",
        "content": "Введение в раздел разработки.",
        "url": "doc_dev_introduction.html",
        "product": "Generic"
      }
      ,
      
    
          
      "doc-dev-site-introduction-html": {
        "title": "Введение",
        "tags": "[]",
        "content": "",
        "url": "doc_dev_site_introduction.html",
        "product": "Java SDK"
      }
      ,
      
    
          
      "doc-egais-html": {
        "title": "Продажа алкоголя. Работа с ЕГАИС",
        "tags": "[]",
        "content": "Если вы хотите продавать алкоголь, вам потребуется передавать данные в ЕГАИС. ЕГАИС, или Единая Государственная Автоматизированная Информационная Система, предназначена для контроля над оборотом этилового спирта, алкогольной и спиртосодержащей продукции. Вы должны самостоятельно подключиться к ЕГАИС.Передача данных в ЕГАИС осуществляется с помощью Универсального Транспортного Модуля (УТМ). УТМ – программное решение, которое обеспечивает достоверность данных и организует обмен данными между пользовательскими программами, например, системами товарного учёта, и ЕГАИС.Схема передачи данных от пользователя в ЕГАИСДля обеспечения достоверности данных УТМ использует Квалифицированную Электронную Подпись (КЭП). КЭП хранится на USB-накопителе, который подключается к устройству с установленным УТМ.Все смарт-терминалы Эвотор поддерживают УТМ. Таким образом, для обмена данными с ЕГАИС вам достаточно подключить USB-накопитель с КЭП к смарт-терминалу и установить на него соответствующее приложение.Чтобы сторонние приложения могли работать и обмениваться данными с ЕГАИС, мы реализовали egais-api.",
        "url": "doc_egais.html",
        "product": ""
      }
      ,
      
    
          
      "doc-errors-returned-html": {
        "title": "Ошибки, которые может возвращать сторонний сервис",
        "tags": "[]",
        "content": "Сторонний сервис должен отвечать на каждый вебхук Облака Эвотор. Ответ стороннего сервиса содержит HTTP-код состояния, в теле ответа обязательно только поле code.Схема ответа стороннего сервисаНиже приведена общая схема ответа стороннего сервиса на вебхук Облака Эвотор{\t\"errors\": [\t\t{\t\t\t\"code\": \"errorCode1\"\t\t},\t\t{\t\t\t\"code\": \"errorCode2\",\t\t\t\"additionalField1\": \"field1Value\",\t\t\t\"additionalField2\": \"field2Value\"\t\t}\t]}где:  errors – массив объектов ошибок. Обязательное поле.  code – поле, которое содержит код ошибки из списка возможных ошибок. Код ошибки может принимать значения от 0000 до 9999.  additionalField – дополнительное поле. Значение дополнительного поля может определять ответное действие Облака Эвотор.Примеры ошибок400 Неверный запросОтвет стороннего сервиса на некорректный вебхук Облака будет выглядеть так:{ \"errors\":  [    {      \"code\": 2003,      \"reason\": \"incorrect\",      \"subject\": \"deviceUuid\",      \"value\": \"null\"    }  ]}Помимо обязательного поля code, объект содержит дополнительные поля которые указывают на ошибку. Дополнительные поля могут отсутствовать или отличаться от приведённых в примере.401 Не авторизованОтвет стороннего сервиса на неверные данные авторизации, полученные от Облака, будет выглядеть так:{ \"errors\":  [    {      \"code\": 1001    }  ]}404 Не найденоОтвет стороннего сервиса если указанный в запросе Облака ресурс не найден:{ }Таблица ошибок, которые сторонний сервис может возвращать ОблакуТаблица ниже содержит коды возвращаемых ошибок, которые сторонний сервис может вернуть Облаку, их описания и содержимое ответов.   HTTP-код состоянияОписаниеКодТело ответа400 Неверный запросСинтаксическая ошибка в запросе.2001{ \"errors\":  [    { \"code\": 2001 }  ]}В запросе отсутствует обязательное поле или присутствуют неизвестные поля.2002{ \"errors\":  [    {      \"code\": 2002,      \"reason\": \"missing\",      \"subject\": \"deviceUuid\"    },    {      \"code\": 2002,      \"reason\": \"unexpected\",      \"subject\": \"deviceUuid\"    }  ]}Параметры запроса содержат недопустимые значения.2003{ \"errors\":  [    {      \"code\": 2003,      \"reason\": \"incorrect\",      \"subject\": \"deviceUuid\",      \"value\": \"null\"    }  ]}401 Не авторизованНеверный токен облака Эвотор.1001{ \"errors\":  [    {      \"code\": 1001    }  ]}Неверный токен пользователя.1002{ \"errors\":  [    {      \"code\": 1002    }  ]}Истёк срок действия токена пользователя.1003{ \"errors\":  [    {      \"code\": 1003    }  ]}При авторизации в стороннем сервисе, пользователь указал неверные данные.1006{ \"errors\":  [    {      \"code\": 1006    }  ]}402 Необходима оплатаПодписка для пользователя не активна. Требуется оплата.1004{ \"errors\":  [    {      \"code\": 1004,      \"reason\": \"payment required\",      \"subject\": \"userUuid\",      \"value\": \"01-000000000015463\"    }  ]}404 Не найденоОтсутствует указанный ресурс.–405 Не поддерживаетсяТерминал не активен в рамках текущей подписки. Активируйте терминал и попробуйте ещё раз.1005{ \"errors\":  [    {      \"code\": 1005,      \"reason\": \"not allowed\",      \"subject\": \"deviceUuid\",      \"value\": \"93a9bfa3-7353-490d-aa54-8c6efe9d8a8f\"    }  ]}Лицензированных терминалов недостаточно для активации в рамках тарифа.1007{ \"errors\":  [    {      \"code\": 1007,      \"reason\": \"license overhead\",      \"subject\": \"deviceUuid\",      \"value\": \"93a9bfa3-7353-490d-aa54-8c6efe9d8a8f\"    }  ]}409 КонфликтАссоциация записей невозможна. В стороннем сервисе userUuid ассоциирован с другой учётной записью пользователя Эвотора.2004{ \"errors\":  [    {      \"code\": 2004    }  ]}Регистрация невозможна. В стороннем сервисе уже зарегистрирована учётная запись с указанными данными.2005{ \"errors\":  [    {      \"code\": 2005    }  ]}",
        "url": "doc_errors_returned.html",
        "product": ""
      }
      ,
      
    
          
      "doc-evotor-api-authorization-html": {
        "title": "Авторизация вебхуков, которые Облако Эвотор передаёт в сторонний сервис",
        "tags": "[]",
        "content": "Облако Эвотор авторизует запросы с помощью заголовка X-Authorization, который содержит токен Облака Эвотор.Запросы Облака к стороннему сервису требуется авторизовать в зависимости от типа запроса:  Вебхуки-запросы. Сторонний сервис авторизует такие запросы с помощью токена приложения стороннего сервиса, который вы указываете в соответствующих параметрах, на вкладке Интеграция, в Личном кабинете на сайте разработчиков.      Вебхуки-уведомления. Все уведомления, кроме Событий подписки и Событий установки и удаления приложений, сторонний сервис должен авторизовать с помощью токена пользователя приложения стороннего сервиса, который Облако получает от стороннего сервиса при регистрации или авторизации пользователей.     Примечание: События подписки и события установки и удаления приложений авторизуются с помощью токена приложения стороннего сервиса.  Токен приложения стороннего сервисаТокен приложения стороннего сервиса необходим для авторизации следующих запросов и уведомлений Облака:  Регистрация новой учётной записи;  Авторизация существующего пользователя;  События подписки;  События установки и удаления приложений;  Передача токена Облака Эвотор.Чтобы задать токен приложения стороннего сервиса:  На сайте dev.evotor.ru выберите приложение для которого требуется задать токен.      На вкладке Интеграция выберите необходимый параметр (например, Регистрация учётной записи в стороннем сервисе) и укажите один из вариантов:                  Если вы указали С помощью токена. В поле Токен, укажите токен приложения стороннего сервиса в формате uuid4.        Облако передаёт токен в заголовке Authorization.                    Если вы указали Запрос логина и пароля ( Basic Auth ). В полях Логин и Пароль укажите данные для доступа к стороннему сервису.        Облако кодирует логин и пароль с помощью base64 и передаёт закодированные данные в заголовке Authorization.            В ответ на вебхуки-запросы Регистрация новой учётной записи и Авторизация существующего пользователя сторонний сервис возвращает в Облако токен пользователя.Токен пользователя приложения стороннего сервисаПри создании нового или авторизации существующего пользователя, сторонний сервис возвращает в Облако уникальный токен пользователя приложения стороннего сервиса. Облако передаёт токен в заголовке Authorization вебхуков-уведомлений.С помощью токена пользователя приложения стороннего сервиса вы можете определить пользователя своего приложения.Облако передаёт токен пользователя приложения стороннего сервиса в следующих вебхуках-уведомлениях:  Создать товары;  Передать документы;  Создать смарт-терминал;  Создать сотрудника;  Создать магазин;  Отправить чек (V2).",
        "url": "doc_evotor_api_authorization.html",
        "product": ""
      }
      ,
      
    
          
      "doc-evotor-api-introduction-html": {
        "title": "Введение",
        "tags": "[]",
        "content": "Облако Эвотор хранит данные о пользователях смарт-терминалов: магазины, товары, документы смарт-терминала, информацию о магазинах и сотрудниках пользователей.Вы можете получить доступ ко всем этим данным с помощью API Облака.С чего начатьДля разработки интеграции с Облаком Эвотор вам потребуется приобрести набор разработчика.Набор разработчика представляет смарт-терминал без фискального накопителя.Смарт-терминал добавит в Личный кабинет пользователя Эвотор стандартные роли администратора и кассира, а также позволит вам создавать новых сотрудников и новые магазины. Совет: В личном кабинете вы так же сможете создавать собственные роли. Набор разработчика для этого не нужен. Примечание: Некоторые запросы к API облака можно выполнить и без смарт-терминала. Например, вы можете получить список магазинов. При этом, в ответ придёт пустой массив.Чтобы начать интеграцию с Облаком Эвотор:  Создайте Личный кабинет в Магазине приложений.      Привяжите смарт-терминал к номеру телефона, на который зарегистрирован Личный кабинет пользователя Эвотор.    В Личном кабинете появятся роли кассира и администратора, а также стандартный магазин “Мой магазин”.    Зарегистрируйтесь на сайте для разработчиков      Нажмите Добавить новое.    Укажите название своего приложения. Например “Тестирование API Эвотор”. Если вы планируете устанавливать своё приложение на терминал, установите флажок APK. Подробнее о разработке для терминала.        Нажмите кнопку Продолжить.        Откроется страница со вкладками Обзор, Видео и скриншоты и Интеграция. Для разработки приложения вам в первую очередь потребуется вкладка Интеграция.    Вкладки Обзор и Видео и скриншоты необходимы для оформления страницы приложения в Магазине приложений и потребуются вам, когда вы будете готовы продавать своё приложение.        Нажмите на название приложения.    Откроется страница с черновиками вашего приложения.        Выберите вкладку Тестирование.    В роли тестировщика укажите номер телефона, на который зарегистрирован Личный кабинет в Магазине приложений.        Выберите вкладку Версии и нажмите кнопку Выложить на тест.    Теперь вы сможете видеть своё приложение в Магазине приложений, если войдёте в Личный кабинет. Приложение будет иметь статус “В разработке”.        Войдите в Личный кабинет в Магазине приложений и выберите в магазине своё приложение.        Нажмите кнопку УстановитьПолучите токен приложения, который позволит вам авторизовать свои запросы к API, и вы сможете обращаться к Облаку.",
        "url": "doc_evotor_api_introduction.html",
        "product": ""
      }
      ,
      
    
          
      "doc-example-calls-html": {
        "title": "Примеры запросов к Облаку Эвотор",
        "tags": "[]",
        "content": "С помощью API Облака Эвотор сторонние сервисы могут получить доступ к данным пользователей платформы, которые хранятся в облаке Эвотор.Обращаясь к Облаку сторонние сервисы могут:  искать магазины, сотрудников и смарт терминалы пользователя платформы;      в рамках выбранного магазина:          получать и передавать информацию о товарах;      удалять товары;      получать документы смарт-терминалов;      создавать схемы и дополнительные поля товаров.      Примеры запросов к Облаку ЭвоторПолучить список всех магазинов пользователяДля выполнения этого запроса вам потребуется токен приложения.Запрос:curl -X GET \\  https://api.evotor.ru/api/v1/inventories/stores/search \\  -H 'x-authorization: &lt;токен приложения&gt;'Ответ:[  {    \"uuid\": \"&lt;идентификатор магазина&gt;\",    \"address\": null,    \"name\": \"Мой магазин1\",    \"code\": null  },]Создать новый товар в определённом магазинеДля выполнения этого запроса вам потребуется токен приложения и идентификатор магазина, который вы можете получить с помощью предыдущего запроса.Создать новый товар в определённом магазине:curl -X POST \\  https://api.evotor.ru/api/v1/inventories/stores/&lt;идентификатор магазина&gt;/products \\  -H 'accept: application/json' \\  -H 'content-type: application/json' \\  -H 'x-authorization: &lt;токен приложения&gt;' \\  -d '[  {    \"uuid\": \"01ba18b6-8707-5f47-3d9c-4db058054cb2\",    \"code\": \"6\",    \"barCodes\": [      \"2000000000060\"    ],    \"alcoCodes\": [      \"0000000000000000001\"    ],    \"name\": \"Сидр\",    \"price\": 123.12,    \"quantity\": 12,    \"costPrice\": 100.123,    \"measureName\": \"шт\",    \"tax\": \"VAT_18\",    \"allowToSell\": true,    \"description\": \"Вкусный яблочный сидр.\",    \"articleNumber\": \"сид123\",    \"parentUuid\": \"1ddea16b-971b-dee5-3798-1b29a7aa2e27\",    \"group\": false,    \"type\": \"ALCOHOL_NOT_MARKED\",    \"alcoholByVolume\": 5.45,    \"alcoholProductKindCode\": 123,    \"tareVolume\": 0.57  }]'no contentПри создании товаров в ответ приходит пустое сообщение. Код ответа в случае удачного добавления – 200.Примеры вебхуков, которые Облако передаёт в сторонний сервисВсе изменения в Личном кабинете пользователя (например, создание магазина или регистрация смарт-терминала) Облако Эвотор может передавать в сторонний сервис, с помощью вебхуков.Подписка на вебхуки позволяет:  Регистрировать или авторизовывать учётные записи в стороннем сервисе.  Активировать и деактивировать тарифы за использование стороннего сервиса.  Редактировать магазины, сотрудников и смарт-терминалы пользователей в стороннем сервисе.  Передавать в сторонний сервис чеки (упрощённые документы) и документы смарт-терминалов.  Получать и передавать номенклатуру.Вебхук-запрос на авторизацию учётной записи стороннего сервисаДля выполнения этого запроса облаку потребуется токен стороннего сервиса.Запрос:-X POST --header 'Content-Type: application/json' --header 'Accept: application/json' --header 'Authorization: Basic &lt;токен стороннего сервиса&gt;' -d '{\"userUuid\":\"01-000000000000001\",\"username\":\"&lt;Имя учётной записи&gt;\",\"password\":\"&lt;пароль учётной записи&gt;\",\"customField\":\"любое значение\"}' 'https://partner.org/api/v1/user/verify'Ответ:{  \"userUuid\": \"01-000000000000001\",  \"hasBilling\": false,  \"token\": \"&lt;токен пользователя&gt;\"}Вебхук-уведомление о создании нового магазина в Личном кабинете пользователя ЭвоторДля выполнения этого запроса облаку потребуется токен пользователя.Запрос:-X PUT --header 'Content-Type: application/json' --header 'Accept: application/json' --header 'Authorization: &lt;токен пользователя&gt;' -d '[{\"uuid\": \"string\", \"name\": \"string\", \"address\": \"string\"}]' 'https://partner.org/api/v1/inventories/stores'Ответ:[  {    \"uuid\": \"string\",    \"parentId\": \"string\",  }]Справочник APIСо всеми возможностями Облака Эвотор вы можете ознакомиться в справочнике.Последние изменения в документации и API отражаются в разделе Что нового.",
        "url": "doc_example_calls.html",
        "product": ""
      }
      ,
      
    
          
      "doc-faq-html": {
        "title": "Часто задаваемые вопросы",
        "tags": "[]",
        "content": "                                                                                                        Что я могу сделать на портале разработчиков?                                                                                                                                    Вы можете сделать оформление страницы вашего приложения.                            Если вы разрабатываете обработку для 1С, то вы можете подготовить все необходимое для публикации.                            Все другие интеграции (терминальное приложение, облачная интеграция) пока требуют действий со стороны Эвотор, поэтому после оформления страницы напишите на почту: developer@evotor.ru.                                                                                                                                                                                                    Нужно ли мне иметь юридическое лицо для разработки приложений?                                                                                                                                        Да, пока нужно иметь юридическое лицо. Но мы уже работаем над тем, чтобы дать возможность частным лицам тоже публиковали свои приложения.                                                                                                                                                                                                    Что если я придумаю идею, а вы возьмете ее и сами реализуете?                                                                                                                                        Мы не занимаемся разработкой приложений и также мы не занимаемся поддержкой. Наша основная задача предоставить стабильную и функциональную платформу для разработчиков.                                                                                                                                                                                                    Как получить token для авторизации запросов к API (на примере 1C)?                                                                                                                                    Пока тестовый токен не выводится на портале для разработчиков, установите любое приложение 1С. После установки в разделе “Настройки” будет ключ доступа.                            Поскольку приложения с пробным периодом, вам не нужно ничего платить первые 30 дней.                                                                                                                                                                                                    Можно ли для разработки WebView-приложений использовать JavaScript-фреймворки, например, jQuery?                                                                                                                                    Да, можно.                            Перед публикацией приложения, убедитесь что компонент Android System WebView версии 39, который поставляется на смарт-терминале, корректно обрабатывает код приложения.                                                                                                                                                                                                    Что происходит при повторной установке после удаления приложения?                                                                                                                                    Если пользователь удалил приложение и до конца оплаченного периода установил его обратно, то он ничего не платит и подписка продолжается как обычно. При этом, пользователь не может поменять тариф.                                                        Если пользователь удалил приложение и установил его уже после окончания оплаченного периода, то создается новая подписка. При этом, пользователь может поменять тариф.                                                                                                                                                                                                    Возможна ли автогенерация кода приложения с помощью вашей openAPI спецификации?                                                                                                                                    В настоящий момент автоматически генерировать код нельзя. Работы по этому направлению не ведутся.                                                                                                                                                                                                    После нажатия на кнопку \"Выложить на тест\" в интерфейсе разработчика, внесенные в версию приложения изменения не видны на странице приложения в маркетплейсе Эвотор. В чем может быть дело?                                                                                                                                    На сервере Эвотор работает кэширование. Внесённые изменения отображаются на сайте с задержкой до 10 минут.                            Чтобы исключить возможность локального кэширования страницы приложения на вашем устройстве, требуется очистить кэш браузера.                                                                                                                                                                                Что делать если у тестировщика или разработчика закончился пробный период приложения, с которым они работают?                                                                                                                                    Создайте учётную запись в вашей системе с помощью своего интерфейса, чтобы биллинг пользователя проходил на вашей стороне. В этом случае, при установке приложения на учётную запись тестировщика или разработчика, выберите опцию у меня уже есть учётная запись. Облако Эвотор передаст в вашу систему запрос на авторизацию данных пользователя в вашей системе. В ответ ваша система передаёт токен пользователя и параметр hasBilling: true.                            Так как биллинг выполняет ваша система, Эвотор не пытается снять деньги с пользователя.                                                                                                                                                                                Что делать если Облако Эвотор не проксирует запросы к стороннему сервису?                                                                                                                                    Если Облако Эвотор не проксирует запросы  от вашего приложения к стороннему сервису, убедитесь что:                                                          для обмена сообщениями со сторонним сервисом приложение использует порты 80 и 443;                              приложение установлено из Магазина приложений;                              на смарт-терминале установлены последние версии Evotor POS и EvoWall.                                                                                                                                                                                                            Значение скидки на весь чек отличается от суммы скидок на позиции в чеке, почему?                                                                                                                                    Дело в том, что при применении скидки на позицию остаются дробные части меньше копейки.                            Пример:                            Товар стоимостью 19.31 за штуку. Продаётся 200 штук.                            Скидка на чек - 10%:                            (19,31*200) - 10% = 3862 - 10% = 3475,8                            Скидка на позицию - 10%:                            (19,31 - 10%) * 200 = 17,379 * 200 = 17,38 * 200 = 3476                                                                        ",
        "url": "doc_faq.html",
        "product": ""
      }
      ,
      
    
          
      "doc-iframe-within-application-page-html": {
        "title": "IFrame на странице приложения",
        "tags": "[]",
        "content": "Добавление IFrameС помощью IFrame ваше приложение может отображать информацию, переданную сторонним сервисом.Вы можете добавить IFrame на закладку Настройки вашего приложения.Чтобы добавить IFrame на закладку Настройки приложения, выполните следующие действия:  Войдите в личный кабинет разработчика на сайте https://developer.evotor.ru/.  Выберите приложение, для которого требуется добавить фрейм.  На закладке Интеграция установите флажок создать вкладку “Настройки” на странице приложения.  В Форме кастомизации нажмите на кнопку iframe.      В поле Значение поля укажите веб-адрес страницы-источника фрейма в формате:https://&lt;веб-адрес страницы-источника&gt;.com?token=${token}&amp;user_id=${uid}    Где:    ${token} – облако Эвотор передаёт токен приложения.    ${uid} – облако Эвотор передаёт идентификатор пользователя в облаке.    Нажмите кнопку Сохранить.  На вкладке Версии нажмите на кнопку Выложить на тест.Фрейм будет добавлен на закладку Настройки приложения.",
        "url": "doc_iframe_within_application_page.html",
        "product": ""
      }
      ,
      
    
          
      "doc-installation-troubleshooting-html": {
        "title": "Устранение проблем с установкой приложения",
        "tags": "[]",
        "content": " Примечание: Обратите внимание облачные приложения не устанавливаются на смарт-терминал.Если у вас возникли проблемы при установке приложения на смарт-терминал:      Убедитесь, что на смарт-терминале нет проблем с подключением к Интернету:    Для этого откройте в браузере (Ещё → Браузер) страницу Магазина приложений - https://market.evotor.ru.        Попробуйте отключить и повторно подключить смарт-терминал к wi-fi;        Попробуйте следующий способ:          Перейдите в раздел Ещё → Настройки → Хранилище и USB-накопители → Приложения → Системный сервис.      Нажмите кнопку Стереть данные.      Перезагрузите смарт-терминал.      ",
        "url": "doc_installation_troubleshooting.html",
        "product": ""
      }
      ,
      
    
          
      "doc-java-app-tutorial-html": {
        "title": "Сборка и установка демонстрационного приложения",
        "tags": "[]",
        "content": "Демонстрационное приложение предоставляет доступ к интерфейсам, которые поддерживает смарт-терминал. Среди функций приложения:  открытие чека продажи и возврата;  добавление скидки к чеку продажи;  взаимодействие с базой товаров на смарт-терминале;  Замена кнопки “Продажа”;  Взаимодействие со сканером штрихкодов и принтером чеков.В разделе представлена информация, необходимая для установки на смарт-терминал демонстрационного приложения.Требования Примечание: Приведённая ниже инструкция актуальна для платформы Windows 10.Перед тем как приступить к сборке и установке демонстрационного приложения убедитесь, что у вас установлено следующее ПО:  Android Studio 3.0 или выше.  Android SDK platform 25.  Build tools 26.0.2.  Oracle JDK.  Git 2.15.0 или выше.      Заданы следующие переменные среды:    Path = &lt;ПУТЬ_К_КАТАЛОГУ_platform-tools&gt;, например C:\\Android\\android-sdk\\platform-toolsJAVA_HOME = &lt;ПУТЬ_К_КАТАЛОГУ_JDK&gt;, например C:\\Program Files (x86)\\Java\\jdk1.8.0_112      Сборка приложения      В Android Studio выполните VCS → Checkout from Version Control → GitHub.    Укажите данные своей учётной записи на GitHub.    В поле Git Repository URL укажите адрес репозитория https://github.com/evotor/evotor-api-example.  В поле Parent Directory укажите локальный адрес, куда будет клонирован репозиторий.      Нажмите Clone.    Выберите Use local gradle distribution и укажите путь к локальному дистрибутиву Gradle, который поставляется с Android Studio.     Примечание: Соглашайтесь, если Android Studio предлагает установить недостающие компоненты  Структура скопированного проекта, выглядит следующим образом:Структура проектаВам потребуется изменить packageName и app_uuid полученного проекта.Замена packageNameЧтобы заменить packageName:  В Android Studio откройте манифест приложения AndroidManifest.xml.      Установите курсор на ту часть packageName, которую требуется изменить, например evotortest6.    &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"  package=\"ru.qualitylab.evotor.evotortest6\"&gt;        В контекстном меню выберите Refactor &gt; Rename и укажите новое имя пакета.      В файле build.gradle (Module: app) замените имя пакета в параметре applicationId.    android {    compileSdkVersion 25    buildToolsVersion '26.0.2'    defaultConfig {        applicationId 'ru.qualitylab.evotor.evotortest6'        ...        Выполните команду Tools - Android - Sync Project with Gradle Files.Замена идентификатора приложенияЧтобы заменить идентификатор приложения:  В Android Studio откройте манифест приложения AndroidManifest.xml.      В поле app_uuid элемента &lt;meta-data&gt; вместо текущего идентификатора укажите идентификатор приложения, который вы получили в процессе подготовки приложения на сайте разработчиков    &lt;meta-data         android:name=\"app_uuid\"         android:value=\"66998575-ee62-4e87-b191-89f351fdc572\" /&gt;            Последовательно выполните команды:          Build - Clean Project.      Build - Build APK(s).      Вы получите файл app-debug.apk приложения, который можно загрузить в облако и установить на терминал для тестирования.Подготовка приложения на сайте разработчиковЧтобы установить приложение на терминал, вам потребуется идентификатор приложения (app_uuid), который вы можете получить на сайте разработчиков.Чтобы получить идентификатор приложения:  Зарегистрируйтесь на сайте разработчиков.      Нажмите Добавить новое.    Укажите название своего приложения. Например, “Тестирование API Эвотор”. Установите флажок Приложение с APK.        Нажмите кнопку Продолжить.    Откроется страница со вкладками Обзор, Видео и скриншоты и Интеграция. Для разработки приложения вам в первую очередь потребуется вкладка Интеграция.    Вкладки Обзор и Видео и скриншоты необходимы для оформления страницы приложения в Магазине приложений и потребуются вам, когда вы будете готовы распространять своё приложение.        Перейдите на вкладку APK. Скопируйте параметр app_uuid и укажите его в файле AndroidManifest.xml    Идентификатор приложения  Установка приложенияВы можете установить приложение вручную, с помощью командной строки или adb shell или из Магазина приложений.",
        "url": "doc_java_app_tutorial.html",
        "product": ""
      }
      ,
      
    
          
      "doc-payoff-html": {
        "title": "Выплаты",
        "tags": "[]",
        "content": "Чтобы распространять свои приложения, вам требуется заключить договор оферты. Договор заключается непосредственно при размещении вашего приложения в Магазине приложений. Договор требуется заключать для каждого из ваших приложений.Выплаты при продаже вашего приложения распределяются следующим образом:  50% получаете вы.  30% получает Эвотор.  20% получают партнёры Эвотора – компании региональные распространители смарт-терминалов.Выплаты перечисляются на банковские реквизиты, указанные в вашем профиле на сайте dev.evotor.ru. Эти же реквизиты фиксируются в договоре, при передаче прав на распространение приложения компании Эвотор.Единственным документом, на основании которого делаются выплаты, является отчёт лицензиата (компании Эвотор). Это связано с тем, что лицензионный договор не облагается НДС.",
        "url": "doc_payoff.html",
        "product": ""
      }
      ,
      
    
          
      "doc-smart-terminal-documents-html": {
        "title": "Документы смарт-терминала",
        "tags": "[]",
        "content": "При организации товарно-денежных операций, смарт-терминал создаёт и обменивается документами.Документ – JSON-файл с информацией о транзакциях (действиях), выполненных на смарт-терминале, например, открытие или закрытие смены, продажа товара. Как и другая информация пользователей платформы, документы хранятся в облаке Эвотор. Порядок транзакций важен при чтении документа. ТипНазваниеACCEPTПриёмкаSELLПродажаBUYВыкуп товара у клиента, с увеличением остатка. Например, при приёме цветного металла.PAYBACKВозврат денегBUYBACKВыкуп товара клиентом, с уменьшением остатка. Например, выкуп залога в ломбарде.CASH_INCOMEВнесение наличныхCASH_OUTCOMEИзъятие наличныхCLOSE_SESSIONЗакрытие смены смарт-терминалаOPEN_SESSIONОткрытие смены смарт-терминалаINVENTORYИнвентаризацияWRITE_OFFСписание товараRETURNВозврат товара поставщикуREVALUATIONПереоценкаFPRINT (Transaction:FPRINT_X_REPORT)Печать X-отчётаFPRINT (Transaction:FPRINT_Z_REPORT)Печать Z-отчётаOPEN_TAREВскрытие тары алкогольной продукцииСо структурой всех типов документов смарт-терминала вы можете ознакомиться в нашем репозитории на гитхабе.",
        "url": "doc_smart_terminal_documents.html",
        "product": ""
      }
      ,
      
    
          
      "doc-subscriptions-html": {
        "title": "Подписки",
        "tags": "[]",
        "content": "Согласно разделу Тарифы, вы можете распространять своё приложение как по подписочной модели, так и за разовые платежи.Чтобы ваш сервис узнавал об установке приложения, его удалении или каких-либо изменениях в подписках, Облако Эвотор передаёт сервису события установки и удаления приложения и события подписки. Примечание: Облако передаёт события в течение трёх дней до тех пор, пока сторонний сервис не ответит 200 ОК. Облако передаёт события подписки, только если биллинг пользователя выполняет Эвотор.Жизненный цикл подпискиЭтапы жизненного цикла подписки:      Пробный этап. Подписка переходит на этот этап после установки приложения, если тариф предусматривает наличие пробного периода использования приложения. Пробный этап заканчивается в установленный срок после успешной оплаты тарифа (событие subscriptionActivated).        Активный этап (или этап биллинга). Подписка переходит на этот этап после успешной оплаты тарифа. Этап длится в течение срока, заданного в тарифе. Этап оканчивается с очередной оплатой  (событие subscriptionRenewed), после которой начинается новый этап биллинга.        Этап напоминаний (или этап даннинга). Этот этап начинается если пользователь не продлил подписку на приложение в срок, заданный в тарифе. Облако выполняет попытки списать средства раз в день в течение пяти дней с момента окончания подписки.    Если по истечению пяти дней списать средства не удалось, Облако передаёт событие subscriptionTerminated, которое сообщает о завершении подписки, после чего приложение автоматически удаляется из Личного Кабинета и с устройств пользователя (событие ApplicationUninstalled).    Если Облаку удаётся выполнить списание средств в течение пяти дней (событие subscriptionRenewed), начинается очередной этап биллинга.  Порядок распространения событийПодписка на приложениеПри подписке на приложение, Облако Эвотор передаёт события в следующем порядке:      После того как пользователь устанавливает приложение в Личном Кабинете, Облако передаёт событие subscriptionCreated.    Также, после события subscriptionCreated, Облако передаёт событие ApplicationInstalled.        По истечению пробного периода:                  Если пользователь оплачивает приложение, Облако передаёт событие subscriptionActivated.        Событие subscriptionActivated сообщает об успешной оплате приложения.                    Если пользователь не оплачивает приложение, Облако передаёт событие subscriptionTerminated.        Событие subscriptionTerminated сообщает о том, что регулярная оплата приложения не прошла.                  После того как пользователь удаляет приложение до истечения оплаченного или пробного периода, Облако передаёт событие subscriptionTerminationRequested.    Также, после удаления приложения, Облако передаёт событие ApplicationUninstalled.        После успешной оплаты очередного периода и продления использования приложения, Облако передаёт событие subscriptionRenewed.        После того как пользователь изменяет условия подписки на приложение (например, тарифный план или количество устройств) в течение оплаченного или пробного периода, Облако передаёт событие SubscriptionTermsChanged.        Если в течение оплаченного или пробного периода пользователь переустанавливает приложение с новым тарифным планом, Облако передаёт следующие события:          subscriptionTerminationRequested.      subscriptionRenewed.      SubscriptionTermsChanged.      Ниже представлена диаграмма распространения событий при подписке на приложение.Диаграмма распространения событийРазовая оплата приложенияПри разовой оплате приложения, Облако Эвотор передаёт события в следующем порядке:      После того как пользователь устанавливает приложение в Личном Кабинете, Облако передаёт событие subscriptionCreated.    Также, после события subscriptionCreated, Облако передаёт событие ApplicationInstalled.        По истечению пробного периода:                  Если пользователь оплачивает приложение, Облако передаёт событие subscriptionActivated.                    Если пользователь не оплачивает приложение, Облако передаёт событие subscriptionTerminated.               Примечание: Если у приложения нет пробного периода, Облако передаёт событие subscriptionActivated сразу после события subscriptionCreated.        После того как пользователь удаляет приложение, Облако передаёт событие ApplicationUninstalled.   Совет: Суммируйте различные подписки (subscriptionId) в рамках одного пользователя. Это поможет определить на сколько устройств пользователь установил приложение.Ниже представлена диаграмма распространения событий при разовой оплате приложения.Диаграмма распространения событий",
        "url": "doc_subscriptions.html",
        "product": ""
      }
      ,
      
    
          
      "doc-tariffs-html": {
        "title": "Тарифы",
        "tags": "[]",
        "content": "Пользователи оплачивают приложения, согласно тарифам, которые вы создаёте на портале разработчиков.Вы можете:  сделать своё приложение бесплатным;  распространять приложение за разовые платежи;  создать различные планы подписки для приложения.Набор тарифов уникален для каждого приложения. Вы можете редактировать созданные тарифы до тех пор, пока они не будут проверены и опубликованы. Примечание: Опубликованные тарифы изменять нельзя. Вы можете перенести опубликованные тарифы в архив. Тарифы можно восстанавливать из архива.Тариф не может быть нулевым. Чтобы сделать бесплатное приложение требуется выбрать соответствующий тип оплаты на вкладке Тарифы.Технические детали и биллинг пользователей.Бесплатное приложениеВыбирайте Бесплатное приложение, если не хотите брать плату за своё приложение.Разовый платёжВыбирайте разовый платёж, если ваше приложение не требует взаимодействия со сторонними сервисами. Например, драйвера для подключаемого оборудования.Разовый платёж может зависеть от количества смарт-терминалов пользователя. Вы можете назначать скидку: чем больше смарт-терминалов у пользователя, тем дешевле обходится каждый их них.Пример:10 смарт-терминалов – 1000р30 смарт-терминалов – 2500рПодпискаВыбирайте подписку, если ваше приложение интегрирует Эвотор со сторонними сервисами, которые требуют поддержки и обслуживания.При выборе подписки вы можете:  использовать базовый тариф;  создать собственные тарифы.Базовый тарифПри выборе базового тарифа вы можете назначить цену за использование одного терминала, а так же выбрать периодичность оплаты.Подобно разовому платежу, вы можете назначить скидку на количество используемых терминалов.Базовый тариф имеет идентификатор \"tariffId\": \"&lt;предустановленный идентификатор&gt;\". Эвотор использует идентификатор тарифа при обмене данными с приложением и сторонним сервисом.Собственный тарифВ общем случае, собственный тариф предполагает периодическую плату за приложение, независимо от количества используемых терминалов.Подобно базовому тарифу, вы можете назначить собственному тарифу плату за использование одного терминала, а так же скидку на количество используемых терминаловВо время создания тарифа, вы присваиваете ему идентификатор \"tariffId\": \"&lt;ваш идентификатор&gt;\". Эвотор использует идентификатор тарифа при обмене данными с приложением и сторонним сервисом.Изменение условий подпискиПользователь в любой момент может изменить условия подписки.Когда пользователь изменяет подписку (событие SubscriptionTermsChanged) Эвотор удерживает разницу, которую пользователь должен доплатить, чтобы работать с приложением на новых условиях. В примере ниже описан алгоритм вычисления разницы.Первого апреля пользователь оплатил 90 рублей, за один месяц работы с приложением.Пятнадцатого апреля пользователь решил перейти на подписку, стоимостью 180 рублей в месяц.Стоимость одного дня до изменения подписки составляла три рубля. Пользователь работал со старой подпиской до 14го числа включительно, следовательно за период с 15го по 30е апреля, пользователь заплатил: 90 - 14*3 = 48 рублей.После смены тарифа стоимость одного дня подписки составила шесть рублей. Пользователю требуется оплатить по новой подписке 16 дней, при этом он уже оплатил этот период из расчёта три рубля в день.Таким образом, сумма, которую требуется доплатить пользователю равна: 16*6 - 48 = 48 рублей.Если пользователь изменил тариф с целью уменьшения стоимости подписки, Эвотор не возвращает оплаченный избыток.Отключение подпискиЗа пять дней до срока оплаты, пользователю приложения приходит смс-оповещение о скором окончании оплаченного периода. Если не удаётся оплатить подписку (недостаточно средств на счету Эвотор или на карте пользователя), Эвотор будет пытаться списать деньги в течение оставшихся пяти дней. Всё это время приложение функционирует в полном объёме, а пользователю приходит соответствующее оповещение.Если списать деньги к указанной дате не удаётся, Эвотор удаляет приложение из Личного кабинета и со смарт-терминала пользователя. При этом, Облако передаёт в сторонний сервис сообщение subscriptionTerminated.При повторной активации тарифа, передаётся сообщение о создании новой подписки. Примечание: О любых изменениях подписки вы можете узнать с помощью Событий биллинга, которые Облако Эвотор передаёт в сторонний сервис.",
        "url": "doc_tariffs.html",
        "product": ""
      }
      ,
      
    
          
      "rn-app-installation-html": {
        "title": "Установка приложения на смарт-терминал",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "Чтобы установить приложение на смарт-терминал:      Включите на смарт-терминале режим разработчика.    При включении режима разработчика выберите опцию Ввести ID пакета вручную и укажите packageName приложения, которое вы собираетесь устанавливать на смарт-терминал, например, com.ProjectName.        Подключитесь к смарт-терминалу с помощью команды    adb connect &lt;IP-адрес смарт-терминала&gt;:2111        Запустите командную строку от имени Администратора.  Перейдите в папку C:\\Program Files\\Java\\jdk1.8.0_121\\bin&gt;      Выполните команды:    keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000            В папке \\аndroid выполните команды:    gradlew assembleRelease        adb install -r &lt;ProjectName&gt;\\android\\app\\build\\outputs\\apk\\release\\app-release.apk      Ваше приложение будет установлено на смарт-терминал. Проверить это вы можете тут ещё&gt;память&gt;приложения (или как-то так).",
        "url": "rn_app_installation.html",
        "product": ""
      }
      ,
      
    
          
      "rn-errorshandling-html": {
        "title": "Обработка ошибок",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "Вы можете отслеживать ошибки в методах, которые возвращают обещание (Promise).Пример кода для отслеживания ошибок:NavigationAPI.startActivity(intent).catch((e)=&gt;{console.log(e.message)});ОшибкиIntegrationErrorexport class IntegrationError extends Error {    constructor(message: string) {}}ОписаниеМожет возникнуть при работе с интеграционной службой, интеграционной операцией, а также при при открытии чека и отправке электронного чека.NavigationErrorexport class NavigationError extends Error {    constructor(message: NavigationErrorMessage) {}}ОписаниеВозникает если при навигации, если вы указали неверные данные.Тип NavigationErrorMessageexport enum NavigationErrorMessage {    TARGET_CLASS_NOT_FOUND = \"TARGET_CLASS_NOT_FOUND\",    TARGET_PACKAGE_NOT_FOUND = \"TARGET_PACKAGE_NOT_FOUND\",    TARGET_CLASS_NOT_EXPORTED = \"TARGET_CLASS_NOT_EXPORTED\"}NoActivityErrorexport class NoActivityError extends Error {    constructor(message: string) {}}ОписаниеВозникает при обращении к операции закрытого приложения.DeviceErrorexport class DeviceError extends Error {    constructor(message: string) {}}ОписаниеВозникает при обращении к неподключённому устройству.",
        "url": "rn_errorshandling.html",
        "product": ""
      }
      ,
      
    
          
      "rn-examples-html": {
        "title": "Примеры реализации",
        "tags": "[&quot;publishing&quot;, &quot;stuff&quot;]",
        "content": "          Поиск товара      Пример показывает простой сценарий использования InventoryAPI                Поиск товара      Пример показывает простой сценарий использования InventoryAPI                Поиск товара      Пример показывает простой сценарий использования InventoryAPI                Поиск товара      Пример показывает простой сценарий использования InventoryAPI      ",
        "url": "rn_examples.html",
        "product": "React Native"
      }
      ,
      
    
          
      "rn-generatingsignedapk-html": {
        "title": "Создание и установка подписанного APK",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "Создание ключа для подписи apk-файла приложенияЧтобы пользователи могли установить ваше приложение на смарт-терминал вам необходимо создать подписанный apk-файл приложения. Для этого вам потребуется ключ, с помощью которого будет подписан apk-файл.Чтобы создать ключ:      Перейдите в папку с установленным JDK.    cd C:\\Program Files\\Java\\jdkX.X.X_X\\bin            Создайте ключ с помощью команды:    keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000        В процессе создания ключа ответьте на вопросы, которые будут появляться в командной строке.        Скопируйте ключ в папку YourAppName\\android\\app.  Создание apk-файлаЧтобы создать apk-файл приложения:      В файле YourAppName\\android\\app\\build.gradle измените следующие параметры:    compileSdkVersion 25buildToolsVersion \"25.0.3\"        minSdkVersion 22        compile \"com.android.support:appcompat-v7:25.3.1\"            В файле YourAppName\\android\\build.gradle, в разделе allprojects добавьте репозиторий maven { url 'https://jitpack.io' }:    allprojects {    repositories {        mavenLocal()        jcenter()        maven {            // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm            url \"$rootDir/../node_modules/react-native/android\"        }        maven { url 'https://jitpack.io' }        google()    }}            В Android Studio откройте манифест приложения, размещённый по адресу YourAppName\\android\\app\\src\\main\\AndroidManifest.xml.        В разделе &lt;uses-sdk&gt; измените параметр:    android:minSdkVersion=\"22\"            После раздела &lt;application&gt; добавьте следующий раздел:    &lt;meta-data    android:name=\"app_uuid\"    android:value=\"&lt;Идентификатор приложения&gt;\" /&gt;        Где требуется указать идентификатор приложения, который вы получили в процессе подготовки приложения на сайте разработчиков        В командной строке перейдите в папку YourAppName\\android и выполните команду:    gradlew AssembleRelease      Готовый apk-файл приложения будет размещён по адресу YourAppName\\android\\app\\build\\outputs\\apk\\release.Установка приложенияВы можете установить приложение вручную, с помощью командной строки или adb shell или из Магазина приложений.",
        "url": "rn_generatingsignedapk.html",
        "product": ""
      }
      ,
      
    
          
      "rn-gettingstarted-html": {
        "title": "Начало работы",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "Подготовка к разработкеУбедитесь, что у вас установлено следующее ПО:  Node.js;  Java SE Development Kit;  Android Studio.Создание проекта React NativeЧтобы создать проект React Native:      Перейдите в папку, где будет создан ваш проект:    cd devfolder            Выполните команду:    create-react-native-app YourAppName            Перейдите в корневую папку проекта:    cd YourAppName            Выполните следующую команду, чтобы получить возможность подключать к своему приложению нативный код:    npm run eject        Ответьте на вопросы, которые появятся в командной строке. В результате выполнения команды, в папке проекта появится папка android.   Примечание: Более подробную информацию смотрите в документации React Native.Установка библиотеки evotor-integration-libraryЧтобы установить библиотеку evotor-integration-library:      В файле YourAppName\\android\\app\\build.gradle измените следующие параметры:    compileSdkVersion 25buildToolsVersion \"25.0.3\"        minSdkVersion 22        compile \"com.android.support:appcompat-v7:25.3.1\"            Установите библиотеку, выполнив следующую команду в корневой папке проекта:    npm install evotor-integration-library --save            Свяжите библиотеку с вашим приложением:          В корневой папке проекта выполните команду:        react-native link evotor-integration-library              В файле YourAppName\\android\\build.gradle, в разделе allprojects добавьте репозиторий maven { url 'https://jitpack.io' }:        allprojects {    repositories {        mavenLocal()        jcenter()        maven {            // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm            url \"$rootDir/../node_modules/react-native/android\"        }        maven { url 'https://jitpack.io' }    }}      Решение возможных проблемПри привязывании библиотеки может возникнуть ошибка:   Command `link` unrecognized. Make sure that you have run `npm install` and that you are inside a react-native project.В этом случае:  Удалите из проекта папку node_modules.  Скачайте и установите менеджер пакетов Yarn.      Выполните команду:    yarn            Повторно выполните команду:    react-native link evotor-integration-library      Установка debug-версии приложения на смарт-терминалЧтобы установить debug-версию приложения на смарт-терминал:      В Android Studio откройте манифест приложения, размещённый по адресу YourAppName\\android\\app\\src\\main\\AndroidManifest.xml.        В разделе &lt;uses-sdk&gt; измените параметр:    android:minSdkVersion=\"22\"            После раздела &lt;application&gt; добавьте следующий раздел:    &lt;meta-data    android:name=\"app_uuid\"    android:value=\"&lt;Идентификатор приложения&gt;\" /&gt;        Где требуется указать идентификатор приложения, который вы получили в процессе подготовки приложения на сайте разработчиков        Подключитесь к смарт-терминалу в режиме разработчика.        Выполните следующую команду в корневой папке проекта:    react-native run-android            Запустите установленное приложение.    На экране терминала откроется окно с ошибкой:            Чтобы исправить ошибку, выполните команду, которая открывает Меню разработчика (Developer Menu):    adb shell input keyevent 82        В Меню разработчика выберите пункты Dev Settings → Debug server host &amp; port for device.      В открывшемся окне укажите:    &lt;IP-адрес вашего компьютера&gt;:8081        Повторно откройте Меню разработчика и выберите пункт Reload.",
        "url": "rn_gettingstarted.html",
        "product": ""
      }
      ,
      
    
          
      "rn-guide1-html": {
        "title": "Руководство 1",
        "tags": "[&quot;getting-started&quot;, &quot;formatting&quot;]",
        "content": "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry’s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.Why do we use it?It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal distribution of letters, as opposed to using ‘Content here, content here’, making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their default model text, and a search for ‘lorem ipsum’ will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on purpose (injected humour and the like).",
        "url": "rn_guide1.html",
        "product": "React Native"
      }
      ,
      
    
          
      "rn-interactiontypes-html": {
        "title": "Типы взаимодействия со смарт-терминалом",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "Получение данныхПриложения получают данные от смарт-терминала с помощью методов get*.Данные получаются асинхронно, поэтому все методы get* возвращают обещание (Promise).Пример использования метода, возвращающего обещание:let users, product;const workflow = async () =&gt; {    users = await UserAPI.getAllUsers();    product = await InventoryAPI.getProductByUuid(\"58e11d31-b2d8-40a0-a1b0-cbd44620a9ec\");};workflow();Методы этого типа представлены в классах:  UserAPI;  InventoryAPI;  ReceiptAPI;  Printer;  Scales.КомандыКоманды – методы, которые инициируют действия на смарт-терминале.Методы этого типа представлены в классах:  ReceiptAPI;  Printer.КоллбэкиКоллбэки – методы обратного вызова, с помощью которых вы можете изменять данные чека в процессе его формирования, например, применять к нему скидку.Методы этого типа представлены в классах:  IntegrationCallback;  NavigationAPI.Подписка на событияВы можете подписать приложение на прослушивание событий. Для этого добавьте один или несколько слушателей с помощью метода:static addEventListener(type: *тип события*, listener: *тип слушателя*, isGlobal: boolean = true): voidгде isGlobal указывает глобальную доступность слушателя: если true – приложение получает события независимо от того, запущено оно или нет; если false – слушатель выполняется только при открытом приложении. По умолчанию – true.Чтобы удалить слушатель, используйте метод:static removeEventListener(type: *тип события*, listener?: *тип слушателя*): booleanМетод возвращает true, если слушатель удалён успешно, или false, если удалить слушатель не удалось.Чтобы удалить все слушатели события и отменить подписку, не передавайте параметр listener.Пример добавления слушателя:const listener = (event) =&gt; {    console.log(\"Sell receipt opened \" + event.receiptUuid);};BroadcastReceiver.addEventListener(ReceiptEventType.SELL_RECEIPT_OPENED, listener);Методы этого типа представлены в классах:  IntegrationServices  BroadcastReceiver  DeviceServiceConnector  Scanner  NavigationAPI",
        "url": "rn_interactiontypes.html",
        "product": ""
      }
      ,
      
    
          
      "rn-introduction-html": {
        "title": "Введение",
        "tags": "[&quot;publishing&quot;, &quot;stuff&quot;]",
        "content": "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry’s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.Why do we use it?It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal distribution of letters, as opposed to using ‘Content here, content here’, making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their default model text, and a search for ‘lorem ipsum’ will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on purpose (injected humour and the like).",
        "url": "rn_introduction.html",
        "product": "React Native"
      }
      ,
      
    
          
      "rn-reference-html": {
        "title": "Справочник",
        "tags": "[&quot;getting-started&quot;, &quot;formatting&quot;]",
        "content": "This is the English Sample 1 page.blah blahpublic class EnhancedFor{\tpublic static void main(String[] args)\t{\tint[] list ={1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\t\tint sum = sumListEnhanced(list);\t\tSystem.out.println(\"Sum of elements in list: \" + sum);\t\tSystem.out.println(\"Original List\");\t\tprintList(list);\t\tSystem.out.println(\"Calling addOne\");\t\taddOne(list);\t\tSystem.out.println(\"List after call to addOne\");\t\tprintList(list);\t\tSystem.out.println(\"Calling addOneError\");\t\taddOneError(list);\t\tSystem.out.println(\"List after call to addOneError. Note elements of list did not change.\");\t\tprintList(list);\t}\t// pre: list != null\t// post: return sum of elements\t// uses enhanced for loop\tpublic static int sumListEnhanced(int[] list)\t{\tint total = 0;\t\tfor(int val : list)\t\t{\ttotal += val;\t\t}\t\treturn total;\t}\t// pre: list != null\t// post: return sum of elements\t// use traditional for loop\tpublic static int sumListOld(int[] list)\t{\tint total = 0;\t\tfor(int i = 0; i &lt; list.length; i++)\t\t{\ttotal += list[i];\t\t\tSystem.out.println( list[i] );\t\t}\t\treturn total;\t}\t// pre: list != null\t// post: none.\t// The code appears to add one to every element in the list, but does not\tpublic static void addOneError(int[] list)\t{\tfor(int val : list)\t\t{\tval = val + 1;\t\t}\t}\t// pre: list != null\t// post: adds one to every element of list\tpublic static void addOne(int[] list)\t{\tfor(int i = 0; i &lt; list.length; i++)\t\t{\tlist[i]++;\t\t}\t}\tpublic static void printList(int[] list)\t{\tSystem.out.println(\"index, value\");\t\tfor(int i = 0; i &lt; list.length; i++)\t\t{\tSystem.out.println(i + \", \" + list[i]);\t\t}\t}}here is some js:&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Simple Map&lt;/title&gt;    &lt;meta name=\"viewport\" content=\"initial-scale=1.0\"&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;style&gt;      /* Always set the map height explicitly to define the size of the div       * element that contains the map. */      #map {        height: 100%;      }      /* Optional: Makes the sample page fill the window. */      html, body {        height: 100%;        margin: 0;        padding: 0;      }    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"map\"&gt;&lt;/div&gt;    &lt;script&gt;      var map;      function initMap() {        map = new google.maps.Map(document.getElementById('map'), {          center: {lat: -34.397, lng: 150.644},          zoom: 8        });      }    &lt;/script&gt;    &lt;script src=\"https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&amp;callback=initMap\"    async defer&gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;this is the english version…Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry’s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.Why do we use it?It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal distribution of letters, as opposed to using ‘Content here, content here’, making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their default model text, and a search for ‘lorem ipsum’ will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on purpose (injected humour and the like).            sample      table                  row 1      row 1              row 2      row 2      ",
        "url": "rn_reference.html",
        "product": "React Native"
      }
      ,
      
    
          
      "rn-reference-broadcastreceivers-html": {
        "title": "BroadcastReceiver",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "ОписаниеКласс позволяет подписываться на широковещательные сообщения, которые рассылает смарт-терминал.МетодыaddEventListenerstatic addEventListener(type: BroadcastReceiverEventType, listener: BroadcastReceiveListener, isGlobal: boolean = true): voidОписаниеДобавляет слушатель и подписывает приложение на события.Параметры  type – событие типа BroadcastReceiverEventType.  listener – слушатель типа BroadcastReceiveListener.  isGlobal – глобальная доступность слушателя.removeEventListenerstatic removeEventListener(type: BroadcastReceiverEventType, listener?: BroadcastReceiveListener): booleanОписаниеУдаляет широковещательный слушатель и отменяет подписку на события.Параметры  type – событие типа BroadcastReceiverEventType.  listener – слушатель типа BroadcastReceiveListener. Не передавайте параметр если хотите удалить все слушатели.Возвращает  true – если слушатель удалён.  false – если слушатель не удалён.ПараметрыТип BroadcastEventTypeexport type BroadcastEventType =    ProductEventType |    ReceiptEventType |    PositionEventType |    CashDrawerEventType |    CashOperationEventType;Перечисление ProductEventTypeexport enum ProductEventType {    PRODUCT_CARD_OPEN = \"PRODUCT_CARD_OPEN\"}Перечисление ReceiptEventTypeexport enum ReceiptEventType {    SELL_RECEIPT_OPENED = \"SELL_RECEIPT_OPENED\",    PAYBACK_RECEIPT_OPENED = \"PAYBACK_RECEIPT_OPENED\",    SELL_RECEIPT_CLEARED = \"SELL_RECEIPT_CLEARED\",    PAYBACK_RECEIPT_CLEARED = \"PAYBACK_RECEIPT_CLEARED\",    SELL_RECEIPT_CLOSED = \"SELL_RECEIPT_CLOSED\",    PAYBACK_RECEIPT_CLOSED = \"PAYBACK_RECEIPT_CLOSED\"}Перечисление PositionEventTypeexport enum PositionEventType {    SELL_RECEIPT_POSITION_ADDED = \"SELL_RECEIPT_POSITION_ADDED\",    PAYBACK_RECEIPT_POSITION_ADDED = \"PAYBACK_RECEIPT_POSITION_ADDED\",    SELL_RECEIPT_POSITION_EDITED = \"SELL_RECEIPT_POSITION_EDITED\",    PAYBACK_RECEIPT_POSITION_EDITED = \"PAYBACK_RECEIPT_POSITION_EDITED\",    SELL_RECEIPT_POSITION_REMOVED = \"SELL_RECEIPT_POSITION_REMOVED\",    PAYBACK_RECEIPT_POSITION_REMOVED = \"PAYBACK_RECEIPT_POSITION_REMOVED\"}Перечисление CashDrawerEventTypeexport enum CashDrawerEventType {    CASH_DRAWER_OPEN = \"CASH_DRAWER_OPEN\"}Перечисление CashOperationEventTypeexport enum CashOperationEventType {    CASH_IN = \"CASH_IN\",    CASH_OUT = \"CASH_OUT\"}Тип BroadcastEventListenerexport type BroadcastEventListener =    ProductEventListener |    ReceiptEventListener |    PositionEventListener |    CashDrawerEventListener |    CashOperationEventListener;Тип ProductEventListenerexport type ProductEventListener = (event: ProductEvent) =&gt; void;Тип ReceiptEventListenerexport type ReceiptEventListener = (event: ReceiptEvent) =&gt; void;Тип PositionEventListenerexport type PositionEventListener = (event: PositionEvent) =&gt; void;Тип CashDrawerEventListenerexport type CashDrawerEventListener = (event: CashDrawerEvent) =&gt; void;Тип CashOperationEventListenerexport type CashOperationEventListener = (event: CashOperationEvent) =&gt; void;Класс ProductEventexport class ProductEvent extends BroadcastEvent {    constructor(action: string, productUuid: string) {}}Класс ReceiptEventexport class ReceiptEvent extends BroadcastEvent {    constructor(action: string, receiptUuid: string) {}}Класс PositionEventexport class PositionEvent extends BroadcastEvent {    constructor(action: string, receiptUuid: string, position: Position) {}}Класс CashDrawerEventexport class CashDrawerEvent extends BroadcastEvent {    constructor(action: string, cashDrawerId: number) {}}Класс CashOperationEventexport class CashOperationEvent extends BroadcastEvent {    constructor(action: string, total: number, documentUuid: string) {}}",
        "url": "rn_reference_broadcastreceivers.html",
        "product": ""
      }
      ,
      
    
          
      "rn-reference-devicescales-html": {
        "title": "Класс Scales",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "ОписаниеКласс позволяет работать с весами, подключёнными к смарт-терминалу.МетодыgetWeightstatic getWeight(): Promise&lt;Weight&gt;ОписаниеПолучает вес товара, установленного на весах.Возвращает  Promise, результат которого - вес товара.Возможные ошибки  DeviceErrorПараметрыWeightexport class Weight {    constructor(weightInGrams: number, supportStable: boolean, stable: boolean) {}}",
        "url": "rn_reference_devicescales.html",
        "product": ""
      }
      ,
      
    
          
      "rn-reference-devicescanner-html": {
        "title": "Класс Scaner",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "ОписаниеКласс позволяет работать со сканером, подключённым к смарт-терминалу.МетодыaddEventListenerstatic addEventListener(type: ScannerEventType, listener: ScannerEventListener, isGlobal: boolean = true): voidОписаниеРегистрирует слушатель и подписывает приложение на события.Параметры  type – событие типа  ScannerEventType.  listener – слушатель типа  ScannerEventListener.  isGlobal – глобальная доступность слушателя.removeEventListenerstatic removeEventListener(type: ScannerEventType, listener?: ScannerEventListener): booleanОписаниеУдаляет слушатель и отменяет подписку на события.Параметры  type – событие типа ScannerEventType.  listener – слушатель типа ScannerEventListener. Не передавайте параметр, если хотите удалить все слушатели.Возвращает  true – если слушатель удалён.  false – если слушатель не удалён.ПараметрыПеречисление ScannerEventTypeexport enum ScannerEventType {    BARCODE_RECEIVED = \"BARCODE_RECEIVED\"}Тип ScannerEventListenerexport type ScannerEventListener = BarcodeReceiveListener;Тип BarcodeReceiveListenerexport type BarcodeReceiveListener = (barcode: string) =&gt; void;",
        "url": "rn_reference_devicescanner.html",
        "product": ""
      }
      ,
      
    
          
      "rn-reference-devicesconnection-html": {
        "title": "Класс DeviceServiceConnector",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "ОписаниеКласс подключает устройства (принтер чеков и весы) к смарт-терминалу.МетодыstartInitConnectionsstatic startInitConnections(): voidОписаниеИнициализирует подключение устройств.addEventListenerstatic addEventListener(type: DeviceConnectionEventType, listener: DeviceConnectionEventListener, isGlobal: boolean = true): voidОписаниеРегистрирует слушатель и подписывает приложение на события.Параметры  type – событие типа DeviceConnectionEventType.  listener – слушатель типа DeviceConnectionEventListener.  isGlobal – глобальная доступность слушателя.removeEventListenerstatic removeEventListener(type: DeviceConnectionEventType, listener?: DeviceConnectionEventListener): booleanОписаниеУдаляет слушатель и отменяет подписку на события.Параметры  type – событие типа DeviceConnectionEventType.  listener – слушатель типа DeviceConnectionEventListener. Не передавайте параметр, если хотите удалить все слушатели.Возвращает  true – если слушатель удалён.  false – если слушатель не удалён.ПараметрыПеречисление DeviceConnectionEventTypeexport enum DeviceConnectionEventType {    PRINTER_CONNECTION_CHANGED = \"PRINTER_CONNECTION_CHANGED\",    SCALES_CONNECTION_CHANGED = \"SCALES_CONNECTION_CHANGED\"}Тип DeviceConnectionEventListenerexport type DeviceConnectionEventListener = (connected: boolean) =&gt; void;",
        "url": "rn_reference_devicesconnection.html",
        "product": ""
      }
      ,
      
    
          
      "rn-reference-devicesprinter-html": {
        "title": "Класс Printer",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "ОписаниеКласс позволяет работать с принтером смарт-терминала.Методыprintstatic print(printables: Printable[]): Promise&lt;void&gt;ОписаниеВызывает команду печати.Параметры  printables – массив  печатных элементов.Возвращает  PromiseВозможные ошибки  DeviceErrorgetAllowableSymbolsLineLengthstatic getAllowableSymbolsLineLength(): Promise&lt;number&gt;ОписаниеПозволяет получить длину печатной строки в символах.Возвращает  Promise, результат которого – число.Возможные ошибки  DeviceErrorgetAllowablePixelLineLengthstatic getAllowablePixelLineLength(): Promise&lt;number&gt;ОписаниеПозволяет получить длину печатной строки в пикселях.Возвращает  Promise, результат которого – число.Возможные ошибки  DeviceErrorПараметрыТип Printableexport type Printable = PrintableText | PrintableBarcode | PrintableImage;Класс PrintableTextexport class PrintableText {    constructor(text: string) {}}Класс PrintableImageexport class PrintableImage {    constructor(path: string) {}}Класс PrintableBarcodeexport class PrintableBarcode {    constructor(barcodeValue: string, barcodeType: BarcodeType) {}}Перечисление BarcodeTypeexport enum BarcodeType {    EAN8,    UPCA,    EAN13,    CODE39}",
        "url": "rn_reference_devicesprinter.html",
        "product": ""
      }
      ,
      
    
          
      "rn-reference-integrationapi-html": {
        "title": "Интеграционные службы",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "ОписаниеС помощью интеграционных служб вы можете подписываться на события при формировании чека и вносить свои изменения. Примечание: Информацию о регистрации интеграционных служб смотрите в разделе Инициализация служб.Изменения вносятся с помощью методов класса IntegrationCallback, экземпляр которого передаётся в каждый слушатель интеграционной службы.Методы класса IntegrationCallbackonResultonResult(result: IntegrationServiceEventResult): Promise&lt;void&gt;ОписаниеУстанавливает результат события интеграционной службы.Параметры  result – результат события интеграционной службы.Возвращает  PromiseВозможные ошибки  IntegrationErrorstartActivitystartActivity(intent: Intent): Promise&lt;void&gt;ОписаниеЗапускает интеграционную операцию.Параметры  intentВозвращает  PromiseВозможные ошибки  IntegrationErrorskipskip(): Promise&lt;void&gt;ОписаниеЗавершает событие интеграционной службы без применения результата.Возвращает  PromiseВозможные ошибки  IntegrationErrorПараметрыТип IntegrationServiceEventResultexport type IntegrationServiceEventResult =    BeforePositionsEditedEventResult |    ReceiptDiscountEventResult |    PaymentSelectedEventResult |    PrintGroupRequiredEventResult |    PrintExtraRequiredEventResult;Класс BeforePositionsEditedEventResultexport class BeforePositionsEditedEventResult {    constructor(changes: PositionChange[] | null, extra: SetExtra | null) {}}См. также  PositionChangeКласс ReceiptDiscountEventResultexport class ReceiptDiscountEventResult {    constructor(discount: number, extra: SetExtra | null, changes: PositionChange[]) {}}См. также  SetExtra  PositionChangeКласс PaymentSelectedEventResultexport class PaymentSelectedEventResult {    constructor(extra: SetExtra | null, paymentParts: PaymentPurpose[]) {}}См. также  SetExtra  PaymentPurposeКласс PrintGroupRequiredEventResultexport class PrintGroupRequiredEventResult {    constructor(extra: SetExtra | null, setPrintGroups: SetPrintGroup[]) {}}См. также  SetExtra  SetPrintGroupКласс PrintExtraRequiredEventResultexport class PrintExtraRequiredEventResult {    constructor(extra: SetPrintExtra[]) {}}См. также  SetPrintExtraТип PositionChangeexport type PositionChange = PositionAdd | PositionEdit | PositionRemove",
        "url": "rn_reference_integrationapi.html",
        "product": ""
      }
      ,
      
    
          
      "rn-reference-inventoryapi-html": {
        "title": "Класс InventoryAPI",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "ОписаниеС помощью методов класса приложения получают данные товаров, которые хранятся в базе смарт-терминала.МетодыgetAllBarcodesForProductstatic getAllBarcodesForProduct(productUuid: string): Promise&lt;string[]&gt;ОписаниеПолучает все штрихкоды товара.Параметры  productUuid – идентификатор товара в формате uuid4.Возвращает  Promise, результат которого – массив строк, штрихкодов товара.getProductByUuidstatic getProductByUuid(uuid: string): Promise&lt;ProductItem | null&gt;ОписаниеПолучает товар по идентификатору (uuid)Параметры  uuid – идентификатор товара в формате uuid4.Возвращает  Promise, результат которого – товар  или null.getFieldstatic getField(fieldUuid: string): Promise&lt;Field | null&gt;ОписаниеПолучает дополнительное поле товара.Параметры  fieldUuid – идентификатор поля в формате uuid4.Возвращает  Promise, результат которого – поле или null.getProductExtrasstatic getProductExtras(productUuid: string): Promise&lt;ProductExtra[]&gt;ОписаниеПолучает дополнительные данные товара.Параметры  productUuid – идентификатор товара в формате uuid4.Возвращает  Promise, результат которого – массив дополнительных полей.ПараметрыКласс ProductItemexport class ProductItem {    constructor(uuid: string,                parentUuid: string | null,                code: string | null,                name: string) {}}Класс Fieldexport class Field {    constructor(name: string | null,                fieldUUID: string,                title: string | null,                type: FieldType) {}}Перечисление FieldTypeexport enum FieldType {    TEXT_FIELD = \"TEXT_FIELD\",    DICTIONARY_FIELD = \"DICTIONARY_FIELD\"}Класс ProductExtraexport class ProductExtra {    constructor(uuid: string,                name: string | null,                commodityUUID: string,                fieldUUID: string,                fieldValue: string | null,                data: string | null) {}}Перечисление ProductTypeexport enum ProductType {    NORMAL = \"NORMAL\",    ALCOHOL_MARKED = \"ALCOHOL_MARKED\",    ALCOHOL_NOT_MARKED = \"ALCOHOL_NOT_MARKED\",    SERVICE = \"SERVICE\"}",
        "url": "rn_reference_inventoryapi.html",
        "product": ""
      }
      ,
      
    
          
      "rn-reference-navigationapi-html": {
        "title": "Класс NavigationAPI",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "ОписаниеКласс предоставляет собой обёртку нативной навигации андроида.С помощью методов класса приложения запускают службы и операции. Внутри своего приложения вы можете запускать любые экспортированные операции других приложений.МетодыcreateIntentForSellReceiptEditstatic createIntentForSellReceiptEdit(): IntentОписаниеСоздаёт намерение (Intent) для формы наполнения чека продажи.Возвращает  IntentcreateIntentForPaybackReceiptEditstatic createIntentForPaybackReceiptEdit(): IntentОписаниеСоздаёт намерение (Intent) для формы наполнения чека возврата.Возвращает  IntentcreateIntentForSellReceiptPaymentstatic createIntentForSellReceiptPayment(): IntentОписаниеСоздаёт намерение (Intent) для формы оплаты чека продажи.Возвращает  IntentcreateIntentForPaybackReceiptPaymentstatic createIntentForPaybackReceiptPayment(): IntentОписаниеСоздаёт намерение (Intent) для формы оплаты чека возврата.Возвращает  IntentcreateIntentForCashReceiptSettingsstatic createIntentForCashReceiptSettings(): IntentОписаниеСоздаёт намерение (Intent) для формы настроек кассового чека.Возвращает  IntentcreateIntentForCashRegisterReportstatic createIntentForCashRegisterReport(): IntentОписаниеСоздаёт намерение (Intent) для формы кассового отчёта.Возвращает  IntentgetIntentstatic getIntent(): Promise&lt;Intent&gt;ОписаниеПолучает намерение (Intent) для текущей операции.Возвращает  Promise – возвращает объект с намерением.Возможные ошибки  NavigationError.startActivitystatic startActivity(intent: Intent): Promise&lt;void&gt;ОписаниеЗапускает операцию (activity).Параметры  intentВозвращает  PromiseВозможные ошибки  NavigationError.startActivityForResultstatic startActivityForResult(intent: Intent, requestCode: number): Promise&lt;void&gt;ОписаниеЗапускает операцию для получения результата.Параметры  intent  requestCodeВозвращает  PromiseВозможные ошибки  NavigationError.startServicestatic startService(intent: Intent): Promise&lt;void&gt;ОписаниеЗапускает службу.Параметры  intentВозвращает  PromiseВозможные ошибки  NavigationError.setResultstatic setResult(resultCode: number, data?: Intent): Promise&lt;void&gt;ОписаниеУстанавливает результат текущей операции, если она была запущена методом startActivityForResult.Параметры  resultCode  dataВозвращает  PromiseВозможные ошибки  NavigationError.setIntegrationResultstatic setIntegrationResult(result: IntegrationServiceEventResult): Promise&lt;void&gt;ОписаниеУстанавливает интеграционный результат текущей операции, если она унаследована от интеграционной операции.Параметры  resultВозвращает  PromiseВозможные ошибки  NavigationError.finishstatic finish(): Promise&lt;void&gt;ОписаниеЗавершает текущую операцию.Возвращает  PromiseВозможные ошибки  NavigationError.addEventListenerstatic addEventListener(type: NavigationEventType, listener: NavigationEventListener, isGlobal: boolean = true): voidОписаниеРегистрирует слушатель и подписывает приложение на события.Параметры  type – событие типа NavigationEventType.  listener – слушатель типа NavigationEventListener.  isGlobal – глобальная доступность слушателяremoveEventListenerstatic removeEventListener(type: NavigationEventType, listener?: NavigationEventListener): booleanОписаниеУдаляет слушатель и отменяет подписку на события.Параметры  type – событие типа NavigationEventType.  listener – слушатель типа NavigationEventListener. Не передавайте параметр если хотите удалить все слушатели.Возвращает  true – если слушатель удалён.  false – если слушатель не удалён.ПараметрыТип NavigationEventTypeexport enum NavigationEventType {    ACTIVITY_RESULT = \"ACTIVITY_RESULT\",    BACK_PRESSED = \"BACK_PRESSED\"}",
        "url": "rn_reference_navigationapi.html",
        "product": ""
      }
      ,
      
    
          
      "rn-reference-receiptapi-html": {
        "title": "Класс ReceiptAPI",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "ОписаниеС помощью методов класса приложения получают данные чеков и передают их для обработки в смарт-терминал.МетодыgetPositionsByBarcodestatic getPositionsByBarcode(barcode: string): Promise&lt;Position[]&gt;ОписаниеПолучает массив позиций чека по значению штрихкода.Параметры  barcode– штрихкод товара.Возвращает  Promise, результат которого – массив позиций.openSellReceiptstatic openSellReceipt(positions?: Position[] | null, extra?: SetExtra): Promise&lt;OpenReceiptCommandResult&gt;ОписаниеФормирует чек продажи из полученных данных. Вы можете передать чек на оплату с помощью метода NavigationAPIПараметры  positions – массив позиций.  extra – указывает наличие дополнительных полей в чеке.Возвращает  PromiseopenPaybackReceiptstatic openPaybackReceipt(positions?: Position[] | null, extra?: SetExtra): Promise&lt;OpenReceiptCommandResult&gt;ОписаниеФормирует чек возврата из полученных данных. Вы можете передать чек на оплату с помощью метода NavigationAPIПараметры  positions – массив позиций.  extra – указывает наличие дополнительных полей в чеке.Возвращает  PromisesendElectronReceiptstatic sendElectronReceipt(printReceipts: PrintReceipt[],                           extra: SetExtra | null,                           phone: string | null,                           email: string | null,                           discount?: number): Promise&lt;SendElectronReceiptCommandResult&gt;ОписаниеФормирует чек из полученных данных и отправляет его на электронную почту и/или телефон.Параметры  printReceipts – массив печатных форм чека.  extra – дополнительные поля в чеке.  phone – телефонный номер покупателя.  email – адрес электронной почты покупателя.  discount – скидка на чек.Возвращает  Promise, результат которого – строка.getReceiptByTypestatic getReceiptByType(type: ReceiptType): Promise&lt;Receipt | null&gt;ОписаниеПолучает чек по типу: чек продажи (SELL) или чек возврата (PAYBACK).Параметры  type – тип чека.Возвращает  Promise, результат которого – чек или null.getReceiptByUuidstatic getReceiptByUuid(uuid: string): Promise&lt;Receipt | null&gt;ОписаниеПолучает чек по идентификатору (uuid).Параметры  uuid – идентификатор чека.Возвращает  Promise, результат которого – чек или null.getReceiptHeadersstatic getReceiptHeaders(type?: ReceiptType): Promise&lt;ReceiptHeader[] | null&gt;ОписаниеПолучает заголовки чека.Параметры  type – тип чека: чек продажи (SELL) или чек возврата (PAYBACK).Возвращает  Promise, результат которого –  массив заголовков чека.ПараметрыКласс PositionAddexport class PositionAdd extends AbstractBundlable {    constructor(position: Position) {}}См. также  PositionКласс PositionEditexport class PositionEdit extends AbstractBundlable {    constructor(position: Position) {}}См. также  PositionКласс PositionRemoveexport class PositionRemove extends AbstractBundlable {    constructor(positionUuid: string) {}}Класс SetExtraexport class SetExtra extends AbstractBundlable {    constructor(extra: Object) {}}Класс SetPrintGroupexport class SetPrintGroup extends AbstractBundlable {    constructor(printGroup: PrintGroup | null,                paymentPurposeIds: string[],                positionUuids: string[]) {}}См. также  PrintGroupКласс SetPrintExtraexport class SetPrintExtra extends AbstractBundlable {    constructor(printExtraPlace: PrintExtraPlace,                printables: Printable[]) {}}См. также  PrintableТип PrintExtraPlaceexport type PrintExtraPlace =    PrintExtraPlacePrintGroupTop |    PrintExtraPlacePrintGroupHeader |    PrintExtraPlacePrintGroupSummary |    PrintExtraPlacePositionFooter |    PrintExtraPlacePositionAllSubpositionsFooter;Класс PrintExtraPlacePrintGroupTopexport class PrintExtraPlacePrintGroupTop {    constructor(printGroupId?: string) {}}Класс PrintExtraPlacePrintGroupHeaderexport class PrintExtraPlacePrintGroupHeader {    constructor(printGroupId?: string) {}}Класс PrintExtraPlacePrintGroupSummaryexport class PrintExtraPlacePrintGroupSummary {    constructor(printGroupId?: string) {}}Класс PrintExtraPlacePositionFooterexport class PrintExtraPlacePositionFooter {    constructor(positionUuid?: string) {}}Класс PrintExtraPlacePositionAllSubpositionsFooterexport class PrintExtraPlacePositionAllSubpositionsFooter {    constructor(positionUuid?: string) {}}Класс ExtraKeyexport class ExtraKey {    constructor(identity: string | null, appId: string | null, description: string | null) {}}Класс Positionexport class Position {    constructor(uuid: string | null,                productUuid: string | null,                productCode: string | null,                productType: ProductType,                name: string,                measureName: string,                measurePrecision: number,                taxNumber: TaxNumber | null,                price: number,                priceWithDiscountPosition: number,                quantity: number,                barcode: string | null,                mark: string | null,                alcoholByVolume: number | null,                alcoholProductKindCode: number | null,                tareVolume: number | null,                extraKeys: ExtraKey[],                subPositions: Position[]) {}}См. также  ProductType  TaxNumber  ExtraKeyКласс ReceiptHeaderexport class ReceiptHeader {    constructor(uuid: string,                number: string | null,                type: ReceiptType,                date: string | null,                clientEmail: string | null,                clientPhone: string | null,                extra: string | null) {}}См. также  ReceiptTypeКласс PrintGroupexport class PrintGroup {    constructor(identifier: string | null,                type: PrintGroupType | null,                orgName: string | null,                orgInn: string | null,                orgAddress: string | null,                taxationSystem: TaxationSystem | null,                shouldPrintReceipt: boolean) {}}См. также  PrintGroupType  TaxationSystemКласс Paymentexport class Payment {    constructor(uuid: string,                value: number,                system: PaymentSystem | null,                purposeIdentifier: string | null,                accountId: string | null,                accountUserDescription: string | null) {}}См. также  PaymentSystemКласс PrintReceiptexport class PrintReceipt {    constructor(printGroup: PrintGroup | null,                positions: Position[],                payments: Map&lt;Payment, number&gt;,                changes: Map&lt;Payment, number&gt;) {}}См. также  PrintGroup  PositionКласс Receiptexport class Receipt {    constructor(header: ReceiptHeader,                printDocuments: PrintReceipt[]) {}}См. также  ReceiptHeader  PrintReceiptМетодыgetPositionsgetPositions(): Position[]ОписаниеПолучает позиции добавленные в чек.Возвращает  Массив позиций.getPaymentsgetPayments(): Payment[]ОписаниеПолучает платежи, с помощью которых оплачен чек.Возвращает  Массив платежейКласс PaymentPurposeexport class PaymentPurpose {    constructor(identifier: string | null,                paymentSystemId: string | null,                total: number,                accountId: string | null,                userMessage: string | null) {}}Класс PaymentSystemexport class PaymentSystem {    constructor(paymentType: PaymentType, userDescription: string, paymentSystemId: string) {}}См. также  PaymentTypeПеречисление ReceiptTypeexport enum ReceiptType {    SELL = \"SELL\",    PAYBACK = \"PAYBACK\"}Перечисление TaxNumberexport enum TaxNumber {    VAT_18 = \"VAT_18\",    VAT_10 = \"VAT_10\",    NO_VAT = \"NO_VAT\",    VAT_18_118 = \"VAT_18_118\",    VAT_10_110 = \"VAT_10_110\",    VAT_0 = \"VAT_0\"}Перечисление TaxationSystemexport enum TaxationSystem {    COMMON = \"COMMON\",    SIMPLIFIED_INCOME = \"SIMPLIFIED_INCOME\",    SIMPLIFIELD_INCOME_OUTCOME = \"SIMPLIFIELD_INCOME_OUTCOME\",    SINGLE_IMPUTED_INCOME = \"SINGLE_IMPUTED_INCOME\",    SINGLE_AGRICULTURE = \"SINGLE_AGRICULTURE\",    PATENT = \"PATENT\"}Перечисление PrintGroupTypeexport enum PrintGroupType {    CASH_RECEIPT = \"CASH_RECEIPT\",    INVOICE = \"INVOICE\",    string_UTII = \"string_UTII\"}Перечисление PaymentTypeexport enum PaymentType {    UNKNOWN = \"UNKNOWN\",    CASH = \"CASH\",    ELECTRON = \"ELECTRON\"}Перечисление PaymentSystemOperationTypeexport enum PaymentSystemOperationType {    SELL = \"SELL\",    SELL_CANCEL = \"SELL_CANCEL\",    PAYBACK = \"PAYBACK\",    PAYBACK_CANCEL = \"PAYBACK_CANCEL\"}",
        "url": "rn_reference_receiptapi.html",
        "product": ""
      }
      ,
      
    
          
      "rn-reference-seviceapi-html": {
        "title": "Класс ServiceAPI",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "ОписаниеС помощью методов класса вы можете создавать собственные службы, а также регистрировать интеграционные службы.МетодыaddEventListenerstatic addEventListener(type: ServiceEventType, listener: ServiceEventListener, isGlobal: boolean = true): voidОписаниеРегистрирует слушатель и подписывает приложение на события.Параметры  type – событие типа ServiceEventType.  listener – слушатель типа ServiceEventListener.  isGlobal – глобальная доступность слушателя.removeEventListenerstatic removeEventListener(type: ServiceEventType, listener?: ServiceEventListener): booleanОписаниеУдаляет слушатель и отменяет подписку на события.Параметры  type – событие типа ServiceEventType.  listener – слушатель типа ServiceEventListener. Не передавайте параметр, если хотите удалить все слушатели.Возвращает  true – если слушатель удалён.  false – если слушатель не удалён.ПараметрыТип ServiceEventTypeexport type ServiceEventType = CustomServiceEventType | IntegrationServiceEventType;Тип CustomServiceEventTypeexport type CustomServiceEventType = string;Перечисление IntegrationServiceEventTypeexport enum IntegrationServiceEventType {    BEFORE_POSITIONS_EDITED = \"BEFORE_POSITIONS_EDITED\",    RECEIPT_DISCOUNT = \"RECEIPT_DISCOUNT\",    PAYMENT_SELECTED = \"PAYMENT_SELECTED\",    PAYMENT_SYSTEM = \"PAYMENT_SYSTEM\",    PRINT_GROUP_REQUIRED = \"PRINT_GROUP_REQUIRED\",    PRINT_EXTRA_REQUIRED = \"PRINT_EXTRA_REQUIRED\"}Тип ServiceEventListenerexport type ServiceEventListener = CustomServiceEventListener | IntegrationServiceEventListener;Тип CustomServiceEventListenerexport type CustomServiceEventListener = (extras: Object) =&gt; void;Тип IntegrationServiceEventListenerexport type IntegrationServiceEventListener =    BeforePositionsEditedEventListener |    ReceiptDiscountEventListener |    PaymentSelectedEventListener |    PaymentSystemEventListener |    PrintGroupRequiredEventListener |    PrintExtraRequiredEventListener;Тип BeforePositionsEditedEventListenerexport type BeforePositionsEditedEventListener = (positionsChanges: PositionChange[], callback: IntegrationCallback) =&gt; voidСм. также  PositionChangeТип ReceiptDiscountEventListenerexport type ReceiptDiscountEventListener = (discount: number, receiptUuid: string, callback: IntegrationCallback) =&gt; voidТип PaymentSelectedEventListenerexport type PaymentSelectedEventListener = (paymentSystem: PaymentSystem, callback: IntegrationCallback) =&gt; voidСм. также  PaymentSystemТип PaymentSystemEventListenerexport type PaymentSystemEventListener = (operationType: PaymentSystemOperationType, event: PaymentSystemEvent, callback: IntegrationCallback) =&gt; voidСм. также  PaymentSystemOperationTypeТип PrintGroupRequiredEventListenerexport type PrintGroupRequiredEventListener = (paymentSystem: PaymentSystem, callback: IntegrationCallback) =&gt; voidСм. также  PaymentSystemТип PrintExtraRequiredEventListenerexport type PrintExtraRequiredEventListener = (callback: IntegrationCallback) =&gt; void",
        "url": "rn_reference_seviceapi.html",
        "product": ""
      }
      ,
      
    
          
      "rn-reference-sessionapi-html": {
        "title": "Класс SessionAPI",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "ОписаниеС помощью методов класса приложения работают с данными кассовой смены.МетодыprintZReportstatic printZReport(): Promise&lt;void&gt;ОписаниеПечатает Z-отчёт.Возвращает  Promise, результат которого – void",
        "url": "rn_reference_sessionapi.html",
        "product": ""
      }
      ,
      
    
          
      "rn-reference-userapi-html": {
        "title": "Класс UserAPI",
        "tags": "[&quot;terminal&quot;, &quot;react&quot;]",
        "content": "ОписаниеС помощью методов класса приложения получают данные пользователей смарт-терминала.МетодыgetAllUsersstatic getAllUsers(): Promise&lt;User[]&gt;ОписаниеПолучает список всех пользователей смарт-терминала.Возвращает  Promise, результат которого –  массив пользователейgetAuthenticatedUserstatic getAuthenticatedUser(): Promise&lt;User | null&gt;ОписаниеПолучает данные авторизованного пользователя смарт-терминала.Возвращает  Promise, результат которого – пользователь.getAllGrantsstatic getAllGrants(): Promise&lt;Grant[]&gt;ОписаниеПолучает все права.Возвращает  Promise, результат которого – массив прав.getGrantsOfAuthenticatedUserstatic getGrantsOfAuthenticatedUser(): Promise&lt;Grant[]&gt;ОписаниеПолучает права авторизованного пользователя.ПараметрыВозвращает  Promise, результат которого – массив прав.ПараметрыКласс Userexport class User {    constructor(uuid: string,                secondName: string | null,                firstName: string | null,                phone: string | null,                pin: string | null,                roleUuid: string,                roleTitle: string) {}}Класс Grantexport class Grant {    constructor(title: string, roleUuid: string) {}}",
        "url": "rn_reference_userapi.html",
        "product": ""
      }
      ,
      
    
          
      "rn-third-party-service-communication-html": {
        "title": "Обмен сообщениями со сторонним сервисом",
        "tags": "[]",
        "content": "Все запросы приложений к стороннему сервису проходят через Облако Эвотор:Для отправки запросов приложения могут использовать только 80 и 443 порт.Смарт-терминал не поддерживает протокол WebSocket. Важно: Установленные на смарт-терминале приложения могут обращаться только к сторонним сервисам. При этом, сторонние сервисы не должны быть в одной локальной сети со смарт-терминалом. Обращаться к REST API Облака Эвотор нельзя.Подготовка к отправке запросовДля отправки запросов требуется:  На портале dev.evotor.ru, указать список разрешённых URL, к которым может обращаться приложение.  Поддержать возможность обращения к сторонним сервисам в приложении.      Установить приложение в Магазине приложений.    В данном случае установка подразумевает активацию приложения в Личном кабинете и необходима, чтобы применились URL, которые вы указали на сайте разработчиков.   Примечание: Если вы разрабатываете Java-приложение, смотрите раздел “Обмен сообщениями Java-приложения и стороннего сервиса”.Настройка списка разрешённых URLЧтобы настроить список разрешённых URL:  На портале dev.evotor.ru выберите приложение, для которого требуется указать список разрешённых URL.  На вкладке Интеграция, установите флажок Проксирование запросов из приложения с терминала на ваш сервер (ver. 2) и укажите список URL, к которым может обращаться приложение.Примеры:  http://example\\.com/document.*\\.jsp\\?wildcard=\\*&amp;param=value.*;  https://another\\.host\\.com/document.*\\.jsp;  https://another\\.host\\.com/.*. Совет: Чтобы задавать маски веб-сайтов используйте регулярные выражения.После создания списка и установки приложения в Магазине приложений, обмен сообщениями происходит по описанному ниже процессу.Шаг 1. Приложение отправляет HTTP-сообщениеПриложение создаёт HTTP-сообщение и отправляет его в сторонний сервис. Вы можете воспользоваться любым удобным способом отправки сообщения.Независимо от версии проксирования SDK смарт-терминала и Облако Эвотор поддерживают следующие HTTP-методы:  GET;  POST;  PUT;  DELETE.Эвотор гарантирует поддержку следующих MIME-типов:  application/x-www-form-urlencoded  application/json  application/xml  text/*  image/*  multipart/form-dataПоддержка других MIME-типов не гарантируется.Шаг 2. Смарт-терминал передаёт сообщение в облакоТерминал перехватывает сообщение и передаёт его в облако Эвотор.Заголовки, которые терминал добавляет к запросу вашего приложения:  X-Device-ID  X-Device-IMEI  X-User-ID  X-Signed-Url  X-Shop-UUID  X-Device-Salt  X-Device-Algorithm  X-Device-Date  X-Secret-Device-ID  X-OAuth-Client-ID  X-Device-UUID  X-Evotor-*  Expect  Host  Transfer-Encoding Примечание: Убедитесь, что ваше приложение не использует перечисленные заголовки. В противном случае, смарт-терминал перезапишет их содержимое.Шаг 3. Облако передаёт сообщение адресатуОблако удаляет служебные заголовки, добавляет свои заголовки и передаёт сообщение адресату.Заголовки, которые добавляет облако:  X-Evotor-Store-Uuid – содержит идентификатор магазина в формате uuid4, к которому привязан терминал.  X-Evotor-Device-UUID – содержит идентификатор устройства в формате uuid4, полученный по запросу к /api/v1/inventories/devices.  X-Evotor-User-Id – содержит идентификатор пользователя в Облаке Эвотор.  Authorization – содержит токен пользователя приложения стороннего сервиса. Токен необходим для bearer-авторизации.Сторонний сервер получает сообщение от облака Эвотор и определяет отправителя с помощью заголовка Authorization.Шаг 4. Ответ стороннего сервисаОтвет стороннего сервиса передаётся приложению в обратном порядке.Если вы используете проксирование ver.2 требования к содержимому ответа отсутствуют.Если вы используете проксирование ver.1 ответы стороннего сервиса должны содержать объекты:  status – содержит HTTP-код состояния.  body – содержит тело запроса. Совет: За проксирование отвечает параметр Проксирование запросов из приложения с терминала на ваш сервер на вкладке Интеграция вашего приложения, на сайте dev.evotor.ru.",
        "url": "rn_third_party_service_communication.html",
        "product": ""
      }
      ,
      
    
          
      "index-html": {
        "title": "Домашняя страница",
        "tags": "[]",
        "content": "О платформеПлатформа Эвотор это:  Облако Эвотор. Облако хранит информацию о сотрудниках (например, кассирах), терминалах, магазинах и товарах пользователей платформы. Пользователи могут создавать, редактировать и удалять магазины, терминалы и сотрудников. Облако также содержит информацию о товарах пользователей.  Смарт-терминал. Смарт-терминал позволяет совершать товарно-денежные операции с товарами пользователей. Это могут быть как произвольные товары, так и товары, которые хранятся локально на терминале.Приобретая смарт-терминал пользователи платформы получают доступ к базовой функциональности:  Редактирование списка магазинов, сотрудников и смарт-терминалов.  Редактирование номенклатуры.  Просмотр базовых отчётов.  Установка приложений для интеграции со сторонними сервисами.С помощью интеграции сторонних приложений, которые распространяются в Магазине приложений, вы можете помочь пользователям:  взаимодействовать со сторонними товароучётными системами, как установленными на компьютере пользователя, так и доступными в облаке;  автоматически обновлять информацию о магазинах в картографических сервисах;  использовать различные системы лояльности для клиентов пользователей платформы;  и многое другое.Полезные ресурсыИзучите запросы к облаку Эвотор и к стороннему веб-сервису на сайте api.evotor.ru. Ознакомьтесь с порталом разработчиков, которые создают смарт-терминалы. Узнайте какие ошибки могут возникнуть при интеграции стороннего сервиса и платформы Эвотор.",
        "url": "index.html",
        "product": ""
      }
      
      
    
          
          
          
    
          
    
          
    
          
    
          
    
          
    
          
    
          
    
  };
</script>

<script src="assets/js/lunr.min.js"></script>
<script src="assets/js/lunr.stemmer.support.js"></script>
<script src="assets/js/lunr.ru.js"></script>
<script src="assets/js/lunr.multi.js"></script>
<script src="assets/js/search.js"></script>

                <div class="toc-main-column">
                

              </div>
                


            </div><!-- /.col-xs-12 main -->

            <div class="col-xs-12 col-sm-2 right-lane">
              <div class="inner">


</div>

              

        </div><!--/.row-->
    </div><!--/.container-->
</div><!--/.page-container-->



<!--scripts loaded here-->
<script src="assets/js/jquery.magnific-popup.js"></script>
<script>
$('.no_icon').magnificPopup({
type: 'image',
closeBtnInside: false,
closeOnContentClick: false,

callbacks: {
  open: function() {
    var self = this;
    self.wrap.on('click.pinhandler', 'img', function() {
      self.wrap.toggleClass('mfp-force-scrollbars');
    });
  },
  beforeClose: function() {
        this.wrap.off('click.pinhandler');
    this.wrap.removeClass('mfp-force-scrollbars');
  }
},

image: {
  verticalFit: false
}

});
</script>
<script src="assets/js/bootstrap.min.js"></script>
<script src="assets/js/toc.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script>
    $( document ).ready(function() {
        $("#docnavsidebar").navgoco({
            caretHtml: '',
            accordion: false,
            openClass: 'open', // open
            save: false, // leave false or nav highlighting doesn't work right
            cookie: {
                name: 'navgoco',
                expires: false,
                path: '/'
            },
            slide: {
                duration: 300,
                easing: 'swing'
            }
        });

    });

</script>
<script src="assets/js/customscripts.js"></script>

<script>
    $(document).ready(function() {
        $('[data-toggle=offcanvas]').click(function() {
            $('.row-offcanvas').toggleClass('active');
        });
    });
</script>
<script src="assets/js/tabs.js"></script>
<!-- Add copy to clipboard button -->
<script>
var allCodeBlocksElements = $( "pre.highlight" );

allCodeBlocksElements.each(function(i) {
  // add different id for each code block

  // target
  var currentId = "codeblock" + (i + 1);
  $(this).attr('id', currentId);

  //trigger
  var clipButton = '<button class="btn" data-clipboard-target="#' + currentId + '"><img src="https://clipboardjs.com/assets/images/clippy.svg" width="13" alt="Copy to clipboard"></button>';
  $(this).after(clipButton);
  });

new Clipboard('.btn');
</script>

</body>

<!-- the google_analytics_id gets auto inserted from the config file -->



<script>
(function(i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function() {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o), m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-84163503-7', 'auto');
ga('require', 'displayfeatures');
ga('send', 'pageview');
</script>




</html>

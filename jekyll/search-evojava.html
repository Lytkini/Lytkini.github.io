<!DOCTYPE html>
<html>
<head>
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],     j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= 'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-W4CBFKS');
  </script>
    <meta charset="utf-8">
    <title> | Документация Эвотор</title>
    <base target="_self">
    <meta name="description" content="            <div... " />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google" value="notranslate">
    <link rel="icon"  type="image/x-icon" href="favicon.ico">



    <!--stylesheets / link tags loaded here-->
    <link rel="stylesheet" type="text/css" href="assets/css/font-awesome.min.css">
    <link rel="stylesheet" href="assets/css/sidebar.css" />
    <link rel="stylesheet" href="assets/css/bootstrap.min.css" />
    <link rel="stylesheet" href="assets/css/monokai.css" />
    <link rel="stylesheet" href="assets/css/lighttheme-evoblue.css" />
    <link rel="stylesheet" href="assets/css/customstyles.css" />
    <link rel="stylesheet" href="assets/css/magnific-popup.css">

    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/navgoco.jquery.min.js"></script>

</head>
<body data-spy="scroll" data-target="nav#toc" data-offset="20">
<div class="page-container">


    <!-- Navigation -->

<nav class="navbar navbar-default navbar-fixed-top">
    <div class="container topnavlinks">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle topnav</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <button type="button" class="navbar-toggle toggle-sidebar-button"  data-toggle="offcanvas" data-target=".sidebar-nav">
                <span class="sr-only">Toggle sidebar</span>
                <span class="sidebarToggle fa fa-columns fa-2x"></span>
            </button>
                <a class="navbar-brand" href="index.html">
                <img class="navbar-logo" src="images/logo_white.png"/>
            </a>
        </div>

        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-left">
                <!-- entries without drop-downs appear here -->
                
                
                
                
                <li><a href="https://api.evotor.ru/" class="noCrossRef">REST API Облака</a></li>
                
                
                
                <!-- entries with drop-downs appear here -->

                
                
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">SDK cмарт-терминала<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        
                        
                        <li><a href="java_introduction.html">Java SDK</a></li>
                        
                        
                        
                        <li><a href="rn_reference.html">React Native SDK</a></li>
                        
                        
                    </ul>
                </li>
                
                

</ul>


<ul class="nav navbar-nav navbar-right">

                    <li>
                        <!--start search-->
                        <div id="search-demo-container">
                 <form action="search.html" method="get">
                <input type="text" id="search-input" placeholder="Поиск по сайту ..." name="query">
                </form>
                </div>
                        <!--end search-->
                    </li>
                </ul>
            </div>
            </div>
            <!-- /.container -->
    </nav>
    <div class="container">
        <div class="row row-offcanvas row-offcanvas-left">

            <!-- sidebar -->
            <div class="col-xs-6 col-sm-3 sidebar-offcanvas" id="sidebar" role="navigation">
                <!--<ul class="nav">-->
                    <!--<li class="active"><a href="#">Home</a></li>-->
                    <!--<li><a href="#">Link 1</a></li>-->
                    <!--<li><a href="#">Link 2</a></li>-->
                    <!--<li><a href="#">Link 3</a></li>-->
                <!--</ul>-->
                

<div class="mydocsidebar">
<div class="sidebar-inner">
<div class="productTitle">Java SDK</div>
<!-- search bar -->

<div class="sidebarSearchBar">
<form action="search-evojava.html" method="get">
  <div class="input-group search">
    <input type="text" id="search-box" name="query" class="form-control" placeholder="Поиск по разделу ...">
    <div class="input-group-btn">
      <button class="btn btn-default" type="submit" value="search">
        <i class="glyphicon glyphicon-search"></i>
      </button>
    </div>
  </div>
</form>
</div>

<!-- end search bar -->
<ul id="docnavsidebar" class="docnav">
    

    
    <li class="level1items"><a class="noCrossRef" href="java_introduction.html">Введение</a>
    
        <ul style="display:none">
            
        </ul>

        

    
    <li class="level1items"><a class="noCrossRef" href="doc_java_app_manifest.html">Манифест Java-приложения</a>
    
        <ul style="display:none">
            
        </ul>

        

    
    <li class="level1"><a href="#">Руководства</a>
    
        <ul style="display:none">
            

            
            
            <li class="level1items"><a href="/doc_java_integration_library_connection.html">Подключение библиотеки integration library</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/doc_java_app_icon.html">Вызов приложения из интерфейса смарт-терминала</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/doc_java_navigation.html">Вызов окон смарт-терминала</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/doc_java_third_party_service_communication.html">Обмен сообщениями приложения и стороннего сервиса</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/doc_java_st_events.html">Обработка событий смарт-терминала</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/doc_java_app_users.html">Работа с пользователями смарт-терминала</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/java_query_api.html">Получение данных из базы данных смарт-терминала</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/doc_java_inventory.html">Товароучёт</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/doc_java_receipt_api.html">Поиск товара по штрихкоду</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/doc_java_online_store_receipt.html">Передача электронных чеков</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/doc_java_payment_systems.html">Использование различных способов оплаты</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/doc_java_session.html">Получение информации о кассовых сменах</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/doc_java_pushnotifications.html">Оповещение пользователей с помощью push-уведомлений</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/doc_java_z_report.html">Печать Z-отчёта</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="/doc_java_logging.html">Доступ к логам</a></li>
            
            

            

            <li class="level2"><a class="subfoldersTitle" href="#">Чеки</a>
                <ul style="display:none;">
                    

                    
                    
                    <li class="level2items"><a href="doc_java_receipt_creation.html">Открытие чека в приложении</a></li>
                    
                    

                    

                    

                    
                    
                    <li class="level2items"><a href="doc_java_receipt_division.html">Разделение чека</a></li>
                    
                    

                    

                    

                    
                    
                    <li class="level2items"><a href=" doc_java_discounts.html">Начисление скидок</a></li>
                    
                    

                    

                    

                    
                    
                    <li class="level2items"><a href=" doc_java_receipt_interactions.html">Работа с позициями чека</a></li>
                    
                    

                    

                    

                    
                    
                    <li class="level2items"><a href="doc_java_receipt_extras.html">Создание дополнительных полей в чеке</a></li>
                    
                    

                    

                    

                    
                    
                    <li class="level2items"><a href="doc_java_get_receipt.html">Получить данные сформированного чека</a></li>
                    
                    

                    

                    

                    
                    
                    <li class="level2items"><a href="doc_java_receipt_print.html">Печать внутри кассового чека</a></li>
                    
                    

                    

                    
                </ul>
            </li>

            

            <li class="level2"><a class="subfoldersTitle" href="#">Оборудование</a>
                <ul style="display:none;">
                    

                    
                    
                    <li class="level2items"><a href="doc_java_scales.html">Работа с весами</a></li>
                    
                    

                    

                    

                    
                    
                    <li class="level2items"><a href="doc_java_barcode_scanner.html">Работа со сканером штрихкодов</a></li>
                    
                    

                    

                    

                    
                    
                    <li class="level2items"><a href="doc_java_bill_printer.html">Работа с принтером чеков</a></li>
                    
                    

                    

                    
                </ul>
            </li>

            

            
        </ul>

        

    
    <li class="level1"><a href="#">Справочники</a>
    
        <ul style="display:none">
            

            
            
            <li class="level1items"><a href="integration-library/index.html">Integration-library</a></li>
            
            

            

            

            
            
            <li class="level1items"><a href="egais-api/index.html">egais-api</a></li>
            
            

            

            
        </ul>

        

    
    <li class="level1items"><a class="noCrossRef" href="java_examples.html">Примеры реализации</a>
    
        <ul style="display:none">
            
        </ul>

        

    </li>
</ul>

<hr class="resourceSeparator"></hr>
<div class="relatedResources"></div>
<ul id="entrypages">
        
    </li>
</ul>
</div>
</div>
<script>$("li.open").parents('li').toggleClass("open");</script>

            </div>

            <!-- main area -->
            <div class="col-xs-12 col-sm-7">
                
                <h1> Результаты поиска</h1>
                  
                 <div class="toc-main-column">
                 

               </div>
                <div style="display:none">
<form action="search-evojava.html" method="get">
  <div class="input-group search">
    <input type="text" id="search-box" name="query" class="form-control" placeholder="">
    <div class="input-group-btn">
      <button class="btn btn-default" type="submit" value="search">
        <i class="glyphicon glyphicon-search"></i>
      </button>
    </div>
  </div>
</form>
</div>

<div id="search-results"></div>

<script>
  window.store = {
      
          
            
          

      "doc-egais-data-reading-access-html": {
        "title": "Получение данных из ЕГАИС",
        "tags": "[]",
        "content": "С помощью egais-api ваше приложение может получать данные из ЕГАИС.Получение необходимых данных осуществляется с помощью запросов к базе данных смарт-терминала.В таблице ниже представленны классы запросов к egais-api, а также соответствующие им классы данных, поля которых вы можете использовать для фильтрации выдачи запросов.            Класс запроса      Класс данных      Описание                  ActChargeOnShopPositionQuery.kt      ActChargeOnShopPosition      Позиция в акте постановки на баланс              ActChargeOnShopQuery.kt      ActChargeOnShop      Акт постановки на баланс              ActWriteOffPositionQuery.kt      ActWriteOffPosition      Позиция в акте списания со склада              ActWriteOffQuery.kt      ActWriteOff      Акт списания со склада              ActWriteOffShopPositionQuery.kt      ActWriteOffShopPosition      Позиция в акте списания из магазина              ActWriteOffShopQuery.kt      ActWriteOffShop      Акт списания из магазина              OrgInfoQuery.kt      OrgInfo      Информация о магазине              ProductInfoQuery.kt      ProductInfo      Информация о товаре              ShopCommodityQuery.kt      ShopCommodity      Остатки товара в магазине              StockCommodityQuery.kt      StockCommodity      Остатки товара на складе              WayBillActPositionQuery.kt      WayBillActPosition      Позиция акта расхождения с товарно-транспортной накладной              WayBillActQuery.kt      WayBillAct      Акт расхождения с товарно-транспортной накладной              WayBillPositionQuery.kt      WayBillPosition      Позиция в товарно-транспортной накладной (ТТН)              WayBillQuery.kt      WayBill      Товарно-транспортные накладные      ПримерПример приложения, которое получает данные ЕГАИС с помощью запросов к базе данных смарт-терминала.",
        "url": "doc_egais_data_reading_access.html",
        "product": ""
      }
      ,
      
      
    
            
          

      "doc-egais-project-creation-html": {
        "title": "Подготовка проекта для работы с egais-api",
        "tags": "[]",
        "content": "Чтобы подготовить проект для работы с egais-api:      Создайте проект в Android Studio.    Минимальная версия SDK проекта должна быть 22. При создании проекта выберите No Activitty.     Совет: Подробную информацию о том, как создать новый проект в Android Studio смотрите на сайте developer.android.com        В файле build.gradle проекта:    allprojects { repositories {     google()     jcenter()     maven { url 'https://jitpack.io' }    }}            В файле build.gradle приложения (папка app), в зависимости подключите библиотеку egais-api:    implementation 'com.github.evotor:egais-api:ebe58e1a79'            В файле AndroidManifest.xml, в секции application укажите элемент meta-data, содержащий идентификатор приложения:    &lt;meta-data         android:name=\"app_uuid\"         android:value=\"&lt;Идентификатор приложения&gt;\" /&gt;         Примечание: Идентификатор приложения вы можете скопировать на странице приложения на сайте разработчиков.        Убедитесь, что PackageName приложения совпадает с указанным на сайте разработчиков, это необходимо для установки приложения на смарт-терминал.  ",
        "url": "doc_egais_project_creation.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-app-icon-html": {
        "title": "Вызов приложения из интерфейса смарт-терминала",
        "tags": "[]",
        "content": "Вы можете запустить своё приложение по иконке, расположенной на одном из экранов смарт-терминала:  на главном экране;  на экране продажи;  на экране возврата.Вы можете запускать приложение с помощью иконки на главном экране смарт-терминала или с помощью иконок на экране продажи и/или возврата товараВы можете интегрировать своё приложение в существующий процесс смарт-терминала, например, продажу или работу с оборудованием, или добавить иконку приложения на главный экран. Плиток может быть несколько, если приложение реализует независимые действия, например, иконки “Продать товар” и “Вернуть товар”.Рекомендации по добавлению иконкиДобавляйте иконку если:  у приложения есть свой интерфейс;  приложение реализует полезное действие и / или предоставляет сотруднику магазина доступ к аналитической информации.Вы можете изменять следующие параметры иконки:      Цвет. Может быть любым, пока на его фоне отчётливо отображаются символы и иконка.     Совет: Как правило цвет иконки делают таким же как и цвет основных кнопок в интерфейсе приложения.        Название. Может быть названием приложения или полезного действия, например, “Продажи за неделю”. Плитка отображает до 20 символов. Остальные символы скрываются многоточием.        Иконка. Иконка должна быть квадратной – 64 dp. Требуется обеспечить набор иконок в трёх разрешениях: 96, 192, 256px.  Иконка приложения на главном экране смарт-терминалаЧтобы добавить иконку приложения на главный экран смарт-терминала:В манифесте приложения, измените секцию требуемой операции следующим образом:&lt;activity  android:name=\".&lt;НазваниеОперации&gt;\"  android:icon=\"@mipmap/ic_launcher\"  android:label=\"Example tile\"  &gt;  &lt;meta-data      android:name=\"ru.evotor.launcher.BACKGROUND_COLOR\"      android:value=\"#133788\" /&gt;  &lt;intent-filter&gt;      &lt;action android:name=\"android.intent.action.MAIN\" /&gt;      &lt;category android:name=\"android.intent.category.EVOTOR\" /&gt;  &lt;/intent-filter&gt;&lt;/activity&gt;Где:Атрибут android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\" задаёт фон, на котором отображается иконка приложения.Элемент &lt;action android:name=\"android.intent.action.MAIN\" /&gt; указывает, что иконка приложения будет отображаться на главном экране смарт-терминала.Приложение на главном экране смарт-терминалаИконка приложения на экране оплатыЧтобы добавить иконку приложения на экран оплаты смарт-терминала:      В созданном приложении создайте службу (service).    Для этого, в Android Studio, в проекте выберите app и выполните следующие действия: File → New → Service → Service (IntentService).    Добавленная служба автоматически объявится в манифесте приложения:    &lt;service    android:name=\".&lt;Имя службы&gt;\"    android:exported=\"false\"&gt;&lt;/service&gt;            В манифесте приложения, измените секцию добавленной службы следующим образом:    &lt;service android:name=\".&lt;Имя службы&gt;\" android:icon=\"@mipmap/ic_launcher_round\" android:label=\"Hello world\"&gt; &lt;meta-data     android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\"     android:value=\"#133788\" /&gt; &lt;intent-filter android:priority=\"20\"&gt;     &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;     &lt;action android:name=\"evo.v2.receipt.sell.receiptDiscount\" /&gt; &lt;/intent-filter&gt; &lt;/service&gt;        Где:    Атрибут android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\" задаёт фон, на котором отображается иконка приложения.    Элемент &lt;action android:name=\"evo.v2.receipt.sell.receiptDiscount\" /&gt; сообщает приложению где отображать иконку.     Совет: Чтобы добавить иконку приложения на экран возврата товара, используйте элемент &lt;action android:name=\"evo.v2.receipt.payback.receiptDiscount\" /&gt;.  Итоговый манифест приложения, иконки которого отображаются как на главном экране, так и на экране оплаты выглядит так:&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"com.example.yourprojectname\"&gt;    &lt;application        android:allowBackup=\"true\"        android:icon=\"@mipmap/ic_launcher\"        android:label=\"@string/app_name\"        android:roundIcon=\"@mipmap/ic_launcher_round\"        android:supportsRtl=\"true\"        android:theme=\"@style/AppTheme\"&gt;        &lt;activity            android:name=\".&lt;Имя операции&gt;\"            android:icon=\"@mipmap/ic_launcher_round\"            android:label=\"Hello world\"            android:theme=\"@style/AppTheme.NoActionBar\"&gt;            &lt;meta-data                android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\"                android:value=\"#133788\" /&gt;            &lt;intent-filter&gt;                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;                &lt;category android:name=\"android.intent.category.EVOTOR\" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;service            android:name=\".&lt;Имя службы&gt;\"            android:icon=\"@mipmap/ic_launcher_round\"            android:label=\"Hello world\"&gt;            &lt;meta-data                android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\"                android:value=\"#133788\" /&gt;            &lt;intent-filter android:priority=\"20\"&gt;                &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;                &lt;action android:name=\"evo.v2.receipt.sell.receiptDiscount\" /&gt;            &lt;/intent-filter&gt;        &lt;/service&gt;    &lt;/application&gt;&lt;/manifest&gt;Приложение на экране оплаты смарт-терминалаЗамена кнопки Продажа на главном экране смарт-терминалаВы можете заменить кнопку Продажа, расположенную на главном экране смарт-терминала, на кнопку своего приложения:Изменение кнопки **Продажа**Чтобы заменить кнопку Продажа:В манифесте приложения, измените секцию соответствующей операции следующим образом: &lt;activity   android:name=\".&lt;НазваниеОперации&gt;\"   android:icon=\"@mipmap/ic_launcher\"   android:label=\"Example tile\"   &gt;   &lt;meta-data       android:name=\"ru.evotor.launcher.BACKGROUND_COLOR\"       android:value=\"#133788\" /&gt;   &lt;intent-filter&gt;       &lt;action android:name=\"ru.evotor.intent.action.SELL_MAIN\" /&gt;       &lt;category android:name=\"android.intent.category.EVOTOR\" /&gt;       &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;    &lt;/intent-filter&gt; &lt;/activity&gt;Где:Атрибут android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\" задаёт фон, на котором отображается иконка приложения.Элемент &lt;action android:name=\"ru.evotor.intent.action.SELL_MAIN\" /&gt; указывает, что иконка приложения заменит кнопку Продажа на главном экране смарт-терминала.Теперь вы можете собрать apk своего приложения и установить его на терминал.",
        "url": "doc_java_app_icon.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-app-manifest-html": {
        "title": "Манифест Java-приложения",
        "tags": "[]",
        "content": "Ниже приведён пример манифеста java-приложения, которое добавляет две иконки на экран оплаты.Изменяйте манифест соответствующим образом, чтобы настроить взаимодействие приложения со смарт-терминалом с помощью точек интеграции.При разработке драйвера для устройств нужно учитывать дополнительные параметры (см. SDK для денежных ящиков и другие разделы, посвящённые разработке драйверов). Примечание: В секции application, требуется указать элемент meta-data, который содержит идентификатор приложения – строка в формате uuid4. Идентификатор отображается в поле Идентификатор приложениия на вкладке APK вашего приложения, на сайте dev.evotor.ru.Идентификатор приложенияПример манифеста приложения&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"com.example.mythirdjavaapplication\"&gt;  &lt;application      android:allowBackup=\"true\"      android:icon=\"@mipmap/ic_launcher\"      android:label=\"@string/app_name\"      android:roundIcon=\"@mipmap/ic_launcher_round\"      android:supportsRtl=\"true\"      android:theme=\"@style/AppTheme\"&gt;      &lt;meta-data android:name=\"app_uuid\" android:value=\"&lt;Идентификатор приложения&gt;\"/&gt;      &lt;activity          android:name=\".MainActivity\"          android:label=\"@string/title_activity_main\"          android:theme=\"@style/AppTheme.NoActionBar\"&gt;          &lt;meta-data              android:name=\"ru.evotor.launcher.BACKGROUND_COLOR\"              android:value=\"#133788\" /&gt;          &lt;intent-filter&gt;              &lt;action android:name=\"android.intent.action.MAIN\" /&gt;              &lt;category android:name=\"android.intent.category.EVOTOR\" /&gt;          &lt;/intent-filter&gt;      &lt;/activity&gt;    &lt;service        android:name=\".MyLittleService\"        android:enabled=\"true\"        android:exported=\"true\"&gt;        &lt;intent-filter&gt;            &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;            &lt;action android:name=\"evo.v2.receipt.sell.beforePositionsEdited\" /&gt;        &lt;/intent-filter&gt;    &lt;/service&gt;    &lt;activity android:name=\".SugarSuggestionActivity\" /&gt;    &lt;receiver        android:name=\".MyLittleReceiver\"        android:enabled=\"true\"        android:exported=\"true\"&gt;        &lt;intent-filter&gt;            &lt;action android:name=\"evotor.intent.action.receipt.sell.POSITION_ADDED\" /&gt;            &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;        &lt;/intent-filter&gt;    &lt;/receiver&gt;  &lt;/application&gt;&lt;/manifest&gt;",
        "url": "doc_java_app_manifest.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-app-users-html": {
        "title": "Работа с пользователями смарт-терминала",
        "tags": "[]",
        "content": "С помощью User API вы можете узнать данные всех пользователей или пользователя, который авторизован на смарт-терминале в данный момент. Например, список прав авторизованного пользователя.Для работы используйте класс UserAPI.МетодыКласс UserAPI содержит следующие методы:Получить данные всех пользователейfun getAllUsers(context: Context): List&lt;User&gt;Где:  context – контекст приложения.  List&lt;User&gt; – список всех пользователей смарт-терминала.Получить данные авторизованного пользователяfun getAuthenticatedUser(context: Context): UserГде:  context – контекст приложения.  User – пользователь авторизованный на смарт-терминале. Если пользователь не авторизован, возвращается null.Получить список всех доступных правfun getAllGrants(context: Context): List&lt;Grant&gt;Где:  context – контекст приложения.  List&lt;Grant&gt; – список всех возможных прав.Получить список прав авторизованного пользователяfun getGrantsOfAuthenticatedUser(context: Context): List&lt;Grant&gt;Где:  context – контекст приложения.  List&lt;Grant&gt; – список всех прав авторизованного пользователя.ПримерПример использования User API в демонстрационном приложении.",
        "url": "doc_java_app_users.html",
        "product": ""
      }
      ,
      
      
    
            
          

      "doc-java-barcode-scanner-html": {
        "title": "Работа со сканером штрихкодов",
        "tags": "[]",
        "content": "Чтобы приложение получало данные от сканера штрихкодов:      В манифесте приложения добавьте разрешение на использование сканера штрихкодов: &lt;uses-permission android:name=\"ru.evotor.devices.SCANNER_RECEIVER\" /&gt;        Объявите класс BarcodeBroadcastReceiver:    BarcodeBroadcastReceiver mBarcodeBroadcastReceiver = new BarcodeBroadcastReceiver() {    @Override    public void onBarcodeReceived(String barcode, Context context) {        // Переменная barcode содержит считанный штрихкод.    }};            В операции (Activity) или фрагменте (Fragment) запускайте и останавливайте подписку BarcodeBroadcastReceiver :        @Override    protected void onPause() {        super.onPause();        unregisterReceiver(mBarcodeBroadcastReceiver);    }    @Override    protected void onResume() {        super.onResume();        registerReceiver(mBarcodeBroadcastReceiver, BarcodeBroadcastReceiver.BARCODE_INTENT_FILTER, BarcodeBroadcastReceiver.SENDER_PERMISSION, null);    }}      ПримерПример получения штрихкода в демонстрационном приложении.",
        "url": "doc_java_barcode_scanner.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-bill-printer-html": {
        "title": "Работа с принтером чеков",
        "tags": "[]",
        "content": "Работа с принтером чековЧтобы приложение печатало свои данные на чеке, выполните следующие действия:      В манифесте приложения укажите следующий элемент:    &lt;uses-permission android:name=\"ru.evotor.permission.receipt.printExtra.SET\" /&gt;            В колбэке onCreate() или при запуске операции (activity) инициализируйте класс ru.evotor.devices.commons.DeviceServiceConnector:    DeviceServiceConnector.startInitConnections(getApplicationContext());        Класс инициализируется асинхронно, чтобы не препятствовать вызывающему потоку.     Совет: Воспользуйтесь методом addConnectionWrapper, чтобы получить событие об успешном подключении. Используйте это событие, если необходимо выполнить какой-либо код сразу после установки соединения.        Вызовите метод DeviceServiceConnector.getPrinterService().    Метод возвращает объект ru.evotor.devices.commons.IPrinterServiceWrapper. Не может быть null    Метод может вернуть следующие исключения (exception):          ru.evotor.devices.commons.exception.ServiceNotConnectedException возвращается в результате серии неудачных попыток подключиться к принтеру.      ru.evotor.devices.commons.exception.DeviceServiceException – наследованое исключение.            Вы можете вызвать следующие методы объекта ru.evotor.devices.commons.IPrinterService:          int getAllowableSymbolsLineLength(int deviceId) – возвращает количество символов, которые помещаются на одной строке чека.      int getAllowablePixelLineLength(int deviceId) – возвращает доступную для печати ширину бумаги в пикселях.              void printDocument(int deviceId, in PrinterDocument printerDocument) – печатает указанный массив объектов: текст, штрихкоды, изображения.        Аргумент deviceId указывает устройство, для которого вызывается метод.         Важно: В настоящий момент печать возможна только на ККМ, встроенной в смарт-терминал, поэтому вместо номера устройства всегда следует передавать константу ru.evotor.devices.commons.Constants.DEFAULT_DEVICE_INDEX.        Каждый из методов может вернуть наследованное исключение ru.evotor.devices.commons.exception.DeviceServiceException.                  Передайте данные в печать с помощью метода printDocument(int deviceId, in PrinterDocument printerDocument).    Аргумент PrinterDocument содержит список элементов печати IPrintable:          Тексты – ru.evotor.devices.commons.printer.printable.PrintableText;      Штрихкоды – ru.evotor.devices.commons.printer.printable.PrintableBarcode;      Картинки – ru.evotor.devices.commons.printer.printable.PrintableImage.       Важно: Работа с удалённым сервисом может занимать длительное время, поэтому не вызывайте перечисленные методы в главном потоке приложения.Вызов методов из главного потока приложения вернёт исключение DeviceServiceOperationOnMainThreadException.ПримерыКод для печати сообщения на чеке:try {  DeviceServiceConnector.getPrinterService().printDocument(    DEFAULT_DEVICE_INDEX_UNSET,    new PrinterDocument(              new PrintableText(\"Первая строка\"),              new PrintableText(\"Довольно длинный текст, помещающийся лишь на несколько строк\"),              new PrintableBarcode(\"1234567890\", PrintableBarcode.BarcodeType.CODE39),              new PrintableImage(bitmap1)));} catch (DeviceServiceException exc) {}Пример работы с принтером чеков в демонстрационном приложении.",
        "url": "doc_java_bill_printer.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-discounts-html": {
        "title": "Начисление скидок",
        "tags": "[]",
        "content": "Вы можете добавлять скидку как на каждую позицию отдельно, так и на весь чек (см. ниже).Назначение скидки на чекПриложение не может автоматически применять скидку, перед этим его требуется вручную вызвать с помощью иконки на экране оплаты смарт-терминала.Для расчёта и назначения скидки:  Подпишитесь на событие ReceiptDiscountEvent, которое сообщает о возможности начислить скидку.  Получите результат, который сообщает о возможности начисления скидки.Чтобы добавить скидку на весь чек:      Подпишитесь на событие:          Создайте службу, которая наследует класс IntegrationService, например MyDiscountService.              Переопределите метод createProcessors службы MyDiscountService и создайте в нём процессор ReceiptDiscountEventProcessor .           public class MyDiscountService extends IntegrationService { @Nullable @Override protected Map&lt;String, ActionProcessor&gt; createProcessors() {     Map&lt;String, ActionProcessor&gt; map = new HashMap&lt;&gt;();     map.put(ReceiptDiscountEvent.NAME_SELL_RECEIPT, new ReceiptDiscountEventProcessor() {         @Override         public void call(@NonNull String action, @NonNull ReceiptDiscountEvent event, @NonNull Callback callback){         }     });     return map; } }                где:                  call – метод получения событий и объектов.          action – действие при событии.          event –  событие.          callback– объект возврата результата.                            Объявите службу в манифесте приложения:        &lt;service        android:name=\"MyDiscountService\"        android:enabled=\"true\"        android:exported=\"true\"&gt;        &lt;intent-filter&gt;            &lt;action android:name=\"evo.v2.receipt.sell.receiptDiscount\" /&gt;        &lt;/intent-filter&gt;&lt;/service&gt;                          Запросите результат ReceiptDiscountEventResult.    try {callback.onResult(  new ReceiptDiscountEventResult(      discount,      new SetExtra(extra),      changes));    }        catch (RemoteException exc) {                exc.printStackTrace();            }        Где:          discount – значение скидки в валюте.      new SetExtra(extra) – команда для создания дополнительных полей в чеке. Если дополнительные поля создавать не требуется вы можете передать null.      changes – список изменений по позициям.      Назначение скидки на позициюЧтобы добавить скидку на позицию, вам потребуется передать значение цены с учётом скидки в поле priceWithDiscountPosition. Если скидки на позицию нет, передавайте null. Список полей позиции описан в классе position.java.Передать поле можно в любой момент, когда доступно редактирование существующих или добавление новых позиций в чек:  При создании чека в приложении.  В списке изменений changes, при работе с чеком.  В списке изменений по позициям (см. выше)Пример скидки на позициюList&lt;PositionAdd&gt; positionAddList = new ArrayList&lt;&gt;();        positionAddList.add(                new PositionAdd(                        Position.Builder.newInstance(                                //идентификатор (uuid) позиции                                UUID.randomUUID().toString(),                                //идентификатор (uuid) товара                                null,                                //Наименование товара                                \"Зубочистки\",                                //Наименование единицы измерения                                \"кг\",                                //Точность единицы измерения                                0,                                //Цена без скидок                                new BigDecimal(200),                                //Количество                                new BigDecimal(1)                                //Добавление цены с учетом скидки на позицию. Итог = price - priceWithDiscountPosition                        ).setPriceWithDiscountPosition(new BigDecimal(100))                                .setExtraKeys(set).build()                )        ); Примечание: Вы можете найти пример начисления скидок в демонстрационном приложении.Получение скидокПолучение скидки потребуется вам чтобы точно определить сумму уплаченную по чеку. Вы можете узнавать скидку начисленную как на открытый, так и на ранее сохранённые чеки.Узнать значение скидки вы можете с помощью методов:fun getDiscount(): BigDecimalГде BigDecimal – абсолютное значение скидки в рублях.Методы принадлежат классу Receipt.ktСкидка на чекМетод getDiscount(), вызванный в классе Receipt возвращает абсолютное значение скидки на чек.Сумма скидок для текущей группыМетод getDiscount(), вызванный в классе Receipt.PrintReceipt возвращает абсолютное значение скидки на текущую печатную группу, без учёта скидки на чек.Пример получения скидок Примечание: Приведённую в примере службу требуется объявить в манифесте приложения.package com.example.dfabrichnyi.integration_lib_testimport ru.evotor.framework.core.IntegrationServiceimport ru.evotor.framework.core.action.event.receipt.print_extra.PrintExtraRequiredEventimport ru.evotor.framework.core.action.event.receipt.print_extra.PrintExtraRequiredEventProcessorimport ru.evotor.framework.core.action.processor.ActionProcessorimport ru.evotor.framework.receipt.Receiptimport ru.evotor.framework.receipt.ReceiptApiimport java.math.BigDecimalclass TestIntegrationService : IntegrationService() {    override fun createProcessors(): MutableMap&lt;String, ActionProcessor&gt; {        return hashMapOf(                Pair(PrintExtraRequiredEvent.NAME_SELL_RECEIPT, object : PrintExtraRequiredEventProcessor() {                    override fun call(action: String, event: PrintExtraRequiredEvent, callback: Callback) {                        //Возвращает текущий открытый чек.                        val receipt = ReceiptApi.getReceipt(this@TestIntegrationService, Receipt.Type.SELL)!!                        val receiptDiscount = receipt.getDiscount()                        println(\"Скидка на чек. Без учета скидок на позиции: $receiptDiscount\")                        var sum = BigDecimal.ZERO                        for (document in receipt.printDocuments) {                            sum += document.getDiscount()                        }                        println(\"Сумма скидок для текущей группы: $sum\")                        callback.skip()                    }                })        )    }}",
        "url": "doc_java_discounts.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-get-receipt-html": {
        "title": "Получить данные сформированного чека",
        "tags": "[]",
        "content": "МетодыКлассы ReceiptApi и Receipt содержат описанные ниже методы.Получить текущий открытый чекfun getReceipt(context: Context, type: Receipt.Type): Receipt?Где:  context – контекст приложения.  type – тип чека:          SELL – продажа товара;      BUY – покупка товара;      PAYBACK – возврат проданного товара;      BUYBACK – возврат купленного товара.        Receipt – текущий открытый чек.Метод возвращает чек или null, если чек закрыт.Получить чек по идентификаторуfun getReceipt(context: Context, uuid: String): Receipt?Где:  context – контекст приложения.  uuid – идентификатор чека в формате uuid4.  Receipt – чек.Метод возвращает чек или null, если чек не найден.Получить по штрихкоду позицию для добавления в чек:fun getPositionsByBarcode(context: Context, barcode: String): List&lt;Position&gt;Где:  context – контекст приложения.  barcode – штрихкод товара.  List&lt;Position&gt; – список позицийПолучить позиции чекаfun getPositions(): List&lt;Position&gt; {    return printDocuments            .flatMap { it.positions }            .toList()}Где:  List&lt;Position&gt; – список позиций чекаПолучить список платежей чекаfun getPayments(): List&lt;Payment&gt; {    return printDocuments            .map { it.payments }            .flatMap { it.keys }            .distinct()}Где:  List&lt;Payment&gt; – список платежей чекаПолучить список заголовков чекаfun getReceiptHeaders(context: Context, type: Receipt.Type? = null): ru.evotor.framework.Cursor&lt;Receipt.Header?&gt;?Где:  context – контекст приложения.  type – тип чека:          SELL – продажа товара;      BUY – покупка товара;      PAYBACK – возврат проданного товара;      BUYBACK – возврат купленного товара.        ru.evotor.framework.Cursor&lt;Receipt.Header?&gt; – курсор с заголовками чека.Метод возвращает заголовки созданных чеков, которые хранятся на терминале.ПримерПолучить список позиций открытого чека продажи:List&lt;Position&gt; positions = ReceiptApi.getReceipt(context, Receipt.Type.SELL).getPositions();",
        "url": "doc_java_get_receipt.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-integration-library-connection-html": {
        "title": "Подключение библиотеки integration library",
        "tags": "[]",
        "content": "ТребованияДля разработки java-приложения, вам потребуется:  Android Studio версии 3.0 или выше;  библиотека integration-library версии 0.4+.Подключение библиотекиЧтобы подключить библиотеку integration-library:      В Android Studio создайте новый проект: &lt;YourProjectName&gt;.    При создании проекта убедитесь, что в раскрывающемся списке Minimum SDK выбран API версии 22 или выше.    В качестве примера, используйте операцию Empty Activity. Вы можете не добавлять операцию или использовать любую из предложенных.    На скриншоте представлена структура полученного проекта:    Структура проекта    Манифест созданного проекта выглядит так:    &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.&lt;yourprojectname&gt;\"&gt;   &lt;application       android:allowBackup=\"true\"       android:icon=\"@mipmap/ic_launcher\"       android:label=\"@string/app_name\"       android:roundIcon=\"@mipmap/ic_launcher_round\"       android:supportsRtl=\"true\"       android:theme=\"@style/AppTheme\"&gt;       &lt;activity android:name=\".&lt;НазваниеОперации&gt;\"&gt;           &lt;intent-filter&gt;               &lt;action android:name=\"android.intent.action.MAIN\" /&gt;               &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;           &lt;/intent-filter&gt;       &lt;/activity&gt;   &lt;/application&gt; &lt;/manifest&gt;         Примечание: Работы с приложением, манифест должен содержать элемент &lt;meta-data/&gt; с идентификатором приложения (см. раздел “Манифест приложения”).        В файле проекта build.gradle (Project: &lt;YourProjectName&gt;) укажите:    allprojects {    repositories {        jcenter()        maven { url 'https://jitpack.io' }    }}            В файле приложения build.gradle (Module: app), добавьте библиотеку integration-library в зависимости:    dependencies {compile group: 'com.github.evotor', name: 'integration-library', version: 'v0.4.+'}        Убедитесь, что вы используете актуальную версию библиотеки.        В проекте укажите параметр minSdkVersion:    defaultConfig {     minSdkVersion 22...}      Библиотека подключена к проекту. Теперь вы можете собрать APK-файл своего приложения.Также вы можете:  добавить иконку приложения на главный экран или экран оплаты;  установить приложение на смарт-терминал.",
        "url": "doc_java_integration_library_connection.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-inventory-html": {
        "title": "Товароучёт",
        "tags": "[]",
        "content": "МетодыКласс InventoryApi содержит методы, описанные ниже.Получить все штрихкоды товара:fun getAllBarcodesForProduct(context: Context, productUuid: String): List&lt;String&gt;Где:  context – контекст приложения.  productUuid – идентификатор товара в формате uuid4.  List&lt;String&gt; – список всех штрихкодов товара.Поиск товара по идентификатору:fun getProductByUuid(context: Context, uuid: String): ProductItem?Где:  context – контекст приложения.  productUuid – идентификатор товара в формате uuid4  ProductItem – абстракция над товарами и товарными группами.Поля, одинаковые для товара и группы:  uuid – идентификатор товара или группы в формате uuid4.  parentUuid – идентификатор родительской группы в формате uuid4.  code – код товара из 1С, если нет, то null.  name – наименование товара или группы.  taxNumber – налоговая ставка.Поля, уникальные для товаров:  type – тип товара. Допустимые значения: NORMAL (обычный товар), ALCOHOL_MARKED (маркированный алкоголь) и ALKOHOL_NOT_MARKED (не маркированный алкоголь).  price – цена товара.  quantity – количество товара.  description – описание товара.  measureName – единицы измерения товара.  measurePrecision – точность измерения.  alcoholByVolume – крепость алкоголя. Если указан обычный товар, используется значение null.  alcoholProductKindCode – идентификатор алкогольной продукции в формате uuid4.  tareVolume – объём тары алкогольной продукции.Получить возможные дополнительные поля:fun getField(context: Context, fieldUuid: String): Field?Где:  context - контекст приложения  productUuid - uuid товара      Field – результат. Может быть одного из двух типов: TextField и DictionaryField.    Независимо от типа, содержит поля: name – имя поля. fieldUUID – идентификатор поля в формате uuid4. title – заголовок, который отображается в интерфейсе смарт-терминала. type – тип поля: TEXT_FIELD или DICTIONARY_FIELD.    Поля, уникальные для типа TEXT_FIELD:          data – Валидный JSON-объект, который содержит данные, отображаемые с помощью JavaScript в интерфейсе смарт-терминала.        Поля, уникальные для типа DICTIONARY_FIELD:          multiple –\tвключает или выключает возможность выбора нескольких значений.      items – массив возможных значений. Массив содержит поля title – заголовок элемента управления, который отображается пользователю и value – идентификатор элемента управления.      Получить значения дополнительных полей товара:fun getProductExtras(context: Context, productUuid: String): List&lt;ProductExtra&gt;Где:  context - контекст приложения  productUuid - uuid товара  List&lt;ProductExtra&gt; – в качестве результата будет возвращен список значений дополнительных полей товараОбъект ProductExtra содержит в себе следующие данные:  uuid – uuid значения дополнительного поля товара.  name – имя дополнительного поля товара.  fieldUUID – uuid дополнительного поля товара.      fieldValue – строка содержащая значение дополнительного поля в определенном формате:          для текстового поля – строка обрамленная кавычками (“785af1da-4053-4214-abd6-71c9cd4b5800”).      для поля из словаря – массив uuid элементов ([“61bff019-5040-40cd-bedf-d854ac935f6c”,”b993bd2a-8f6a-4fbc-b916-2d9786cd5def”]).        data - дополнительные данные от приложения.ПримерПример работы с Inventory API в демонстрационном приложении.",
        "url": "doc_java_inventory.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-logging-html": {
        "title": "Доступ к логам",
        "tags": "[]",
        "content": "Для записи событий Java-приложений используйте методы класса Log:  Log.v(String, String) – Verbose;  Log.d(String, String) – Debug;  Log.i(String, String) – Info;  Log.w(String, String) – Warn;  Log.e(String, String) – Error.Смарт-терминал фильтрует логи по имени пакета (packagename) приложения.Чтобы ваши логи отображались в logcat необходимо добавить имя пакета приложения в тэг или в текст сообщения:private static final String TAG = \"packagename\";Log.v(TAG, String);Подробное описание класса и используемых методов смотрите в документации для ОС Android.",
        "url": "doc_java_logging.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-navigation-html": {
        "title": "Вызов окон смарт-терминала",
        "tags": "[]",
        "content": "ОписаниеС помощью методов класса NavigationApi приложения вызывают различные окна смарт-терминала.МетодыcreateIntentForSellReceiptEditfun createIntentForSellReceiptEdit(): IntentОписаниеОткрывает окно редактирования чека продажи.Возвращает  IntentcreateIntentForPaybackReceiptEditfun createIntentForPaybackReceiptEdit(): IntentОписаниеОткрывает окно редактирования чека возврата проданного товара.Возвращает  IntentcreateIntentForBuyReceiptEditfun createIntentForBuyReceiptEdit(): IntentОписаниеОткрывает окно редактирования чека покупки.Возвращает  IntentcreateIntentForBuybackReceiptEditfun createIntentForBuybackReceiptEdit(): IntentОписаниеОткрывает окно редактирования чека возврата купленного товара.Возвращает  IntentcreateIntentForSellReceiptPaymentfun createIntentForSellReceiptPayment(): IntentОписаниеОткрывает окно оплаты чека продажи.Возвращает  IntentcreateIntentForPaybackReceiptPaymentfun createIntentForPaybackReceiptPayment(): IntentОписаниеОткрывает окно оплаты чека возврата проданного товара.Возвращает  IntentcreateIntentForBuyReceiptPaymentfun createIntentForBuyReceiptPayment(): IntentОписаниеОткрывает окно оплаты чека покупки.Возвращает  IntentcreateIntentForBuybackReceiptPaymentfun createIntentForBuybackReceiptPayment(): IntentОписаниеОткрывает окно оплаты чека возврата купленного товара.Возвращает  IntentcreateIntentForCashReceiptSettingsfun createIntentForCashReceiptSettings(): IntentОписаниеОткрывает окно редактирования клише чека (Настройки → Кассовый чек).Возвращает  IntentcreateIntentForCashRegisterReportfun createIntentForCashRegisterReport(): IntentОписаниеОткрывает окно доступа к кассовым отчётам (Отчёты → Кассовый отчёт).Возвращает  IntentcreateIntentForChangeUserfun createIntentForChangeUser(): IntentОписаниеОткрывает окно смены пользователей.Возвращает  IntentcreateIntentForNewProductfun createIntentForNewProduct(productBuilder: NewProductIntentBuilder): IntentОписаниеОткрывает окно создания нового товара.Параметры  productBuilder   class NewProductIntentBuilder {       private var barcode: String? = null       fun setBarcode(barcode: String?): NewProductIntentBuilder {           this.barcode = barcode           return this       }       @JvmSynthetic       internal fun build() = Intent(ACTION_EDIT_PRODUCT).apply {           barcode?.let {               putExtra(EXTRA_BARCODE, it)           }       }   }Возвращает  IntentcreateIntentForEditProductfun createIntentForEditProduct(productBuilder: EditProductIntentBuilder): IntentОписаниеОткрывает окно редактирования товара.Параметры  productBuilder   class EditProductIntentBuilder {       private lateinit var uuid: String       fun setUuid(uuid: String): EditProductIntentBuilder {           this.uuid = uuid           return this       }       @JvmSynthetic       internal fun build() = Intent(ACTION_EDIT_PRODUCT).apply {           putExtra(EXTRA_PRODUCT_UUID, uuid)       }   }Возвращает  IntentgetProductUuidfun getProductUuid(intent: Intent): String?ОписаниеПолучает идентификатор товара при успешном добавлении.Параметры  intentВозвращает  StringПримерПример вызова окон добавления и редактирования товара.package evotor.ru.pushsample;import android.content.Intent;import android.os.Bundle;import android.support.annotation.Nullable;import android.widget.Toast;import ru.evotor.framework.core.IntegrationAppCompatActivity;import ru.evotor.framework.navigation.NavigationApi;public class SampleActivity extends IntegrationAppCompatActivity {    public static final int REQUEST_CODE_FOR_NEW_PRODUCT = 10;    public static final int REQUEST_CODE_FOR_EDIT_PRODUCT = 11;    @Override    public void onCreate(@Nullable Bundle savedInstanceState) {        //Вызов суперкласса onCreate, создающего операцию.        super.onCreate(savedInstanceState);        //NavigationApi.createIntentForNewProduct() создает намерение (Intent) на создание товара с указанным штрихкодом.        startActivityForResult(NavigationApi.createIntentForNewProduct(                new NavigationApi.NewProductIntentBuilder().setBarcode(\"111\")), REQUEST_CODE_FOR_NEW_PRODUCT);    }    @Override    protected void onActivityResult(int requestCode, int resultCode, Intent data) {        if (requestCode == REQUEST_CODE_FOR_NEW_PRODUCT &amp;&amp; resultCode == RESULT_OK) {            //Toast.makeText() выводит на экран смарт-терминала сообщение            //с идентификатором нового товара.            //getProductUuid(data) получает идентификатор (uuid)            //нового товара.            Toast.makeText(this, \"UUID of new product: \" + getProductUuid(data)                    , Toast.LENGTH_SHORT).show();            //NavigationApi.createIntentForEditProduct() создает намерение (Intent) на редактирование товара.            //.setUuid(getProductUuid(data)) задаёт идентификатор редактируемого товара.            startActivityForResult(NavigationApi.createIntentForEditProduct(                    new NavigationApi.EditProductIntentBuilder()                            .setUuid(getProductUuid(data))), REQUEST_CODE_FOR_EDIT_PRODUCT);        } else if (requestCode == REQUEST_CODE_FOR_EDIT_PRODUCT &amp;&amp; resultCode == RESULT_OK) {            //Toast.makeText() выводит на экран смарт-терминала сообщение            //об успешном редактировании товара.            Toast.makeText(this, \"Товар отредактирован пользователем\", Toast.LENGTH_SHORT).show();        } else if (resultCode == RESULT_CANCELED) {            //Toast.makeText() выводит на экран смарт-терминала сообщение            //об отмене создания нового товара.            Toast.makeText(this, \"Отменено пользователем\", Toast.LENGTH_SHORT).show();        }        super.onActivityResult(requestCode, resultCode, data);    }}",
        "url": "doc_java_navigation.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-online-store-receipt-html": {
        "title": "Передача электронных чеков",
        "tags": "[]",
        "content": "Приложение может создавать чеки и передавать их для оформления в смарт-терминал. Такие чеки являются фискальными.С помощью команд PrintSellReceiptCommand и PrintPaybackReceiptCommand смарт-терминал может автоматически передавать созданные чеки на указанный адрес электронной почты (email) и / или номер телефона. Передача чеков актуальна, например, для интернет-магазинов.Передача чека на email и номер телефонаСмарт-терминал передаёт чеки если указан email и / или номер телефона. Касса не печатает чек, если указаны поля email и / или номер телефона. Примечание: Только кассы нового образца могут не печатать чеки. Кассы старого образца печатают чек независимо от того указан email или номер телефона.Чтобы передавать чек на email и номер телефона:      В манифесте укажите права приложения:    &lt;uses-permission android:name=\"ru.evotor.permission.receipt.print.INTERNET_RECEIPT\" /&gt;            Составьте список позиций, который требуется добавить в чек, наполните список    public void openReceipt() {        List&lt;positions&gt; positionAddList = new ArrayList&lt;&gt;();        JSONObject extra = new JSONObject();      }        Где:    List&lt;PositionAdd&gt; positionAddList = new ArrayList&lt;&gt;()– список позиций. Как добавить позицию в чек смотрите в разделе Добавление, изменение и удаление позиций.    JSONObject extra = new JSONObject();– добавляет дополнительные данные к чеку. Данные доступны только вашему приложению. Не создавайте этот объект, если приложение не добавляет дополнительные поля к чеку.        Укажите способ оплаты:    List&lt;Payment&gt; payments = new ArrayList&lt;&gt;();Payment payment = new Payment(        UUID.randomUUID().toString(),        new BigDecimal(9000),        new PaymentSystem(PaymentType.ELECTRON, \"Card\", \"Cashless\"),        null,        null,        null);        Где:          PaymentType – задаёт способ оплаты.            Создайте команду для передачи чека и вызовите метод .process:    PrintSellReceiptCommand command = new PrintSellReceiptCommand(positions, payments, null, \"example@example.com\");command.process(MainActivity.this, new IntegrationManagerCallback() {    @Override    public void run(IntegrationManagerFuture future) {        IntegrationManagerFuture.Result result = null;        try {            result = future.getResult();            switch (result.getType()) {                case OK:                    PrintReceiptCommandResult printSellReceiptResult = PrintReceiptCommandResult.create(result.getData());                    Toast.makeText(MainActivity.this, \"OK\", Toast.LENGTH_LONG).show();                    break;                case ERROR:                    Error error = result.getError();                    Toast.makeText(MainActivity.this, error.getMessage(), Toast.LENGTH_LONG).show();                    break;            }        } catch (IntegrationException e) {            e.printStackTrace();        }    }});        Где:          positions – список позиций чека.      payments – информация о способе оплаты.      clientPhone – номер телефона клиента в формате строки. Может быть null. Смарт-терминал передаёт чек на указанный номер телефона. Если поле не указано, смарт-терминал вернёт ошибку.      clientEmail – email клиента в формате строки. Может быть null. Смарт-терминал передаёт чек на указанный адрес электронной почты. Если поле не указано, смарт-терминал вернёт ошибку.         Совет: Чтобы передать чек возврата, вместо команды PrintSellReceiptCommand используйте команду PrintPaybackReceiptCommand.  Команда возвращает результат, описанный в классе PrintReceiptCommandResult.ПримерПример печати электронных чеков в демонстрационном приложении.Существует также более детальный способ создания и передачи чека:List&lt;Position&gt; list = new ArrayList&lt;&gt;();list.add(        Position.Builder.newInstance(                UUID.randomUUID().toString(),                null,                \"1234\",                \"12\",                0,                new BigDecimal(1000),                BigDecimal.TEN        ).build());list.add(        Position.Builder.newInstance(                UUID.randomUUID().toString(),                null,                \"1234\",                \"12\",                0,                new BigDecimal(500),                BigDecimal.ONE        ).setPriceWithDiscountPosition(new BigDecimal(300)).build());HashMap payments = new HashMap&lt;Payment, BigDecimal&gt;();payments.put(new Payment(                    UUID.randomUUID().toString(),                    new BigDecimal(9300),                    new PaymentSystem(PaymentType.ELECTRON, \"Internet\", \"12424\"),                    null,                    null,                    null            ), new BigDecimal(9300));PrintGroup printGroup = new PrintGroup(UUID.randomUUID().toString(),                PrintGroup.Type.CASH_RECEIPT, null, null, null, null, false);final Receipt.PrintReceipt printReceipt = new Receipt.PrintReceipt(        printGroup,        list,        payments,        new HashMap&lt;Payment, BigDecimal&gt;());ArrayList&lt;Receipt.PrintReceipt&gt; listDocs = new ArrayList&lt;&gt;();listDocs.add(printReceipt);BigDecimal receiptDiscount = new BigDecimal(1000);new PrintSellReceiptCommand(listDocs, null, null, \"example@example.com\", receiptDiscount).process(MainActivity.this, new IntegrationManagerCallback() {    @Override    public void run(IntegrationManagerFuture integrationManagerFuture) {        try {            IntegrationManagerFuture.Result result = integrationManagerFuture.getResult();            switch (result.getType()) {                       case OK:                           PrintReceiptCommandResult printSellReceiptResult = PrintReceiptCommandResult.create(result.getData());                           Toast.makeText(MainActivity.this, \"OK\", Toast.LENGTH_LONG).show();                           break;                       case ERROR:                           Error error = result.getError();                           Toast.makeText(MainActivity.this, error.getMessage(), Toast.LENGTH_LONG).show();                           break;                   }        } catch (IntegrationException e) {            e.printStackTrace();        }    }});",
        "url": "doc_java_online_store_receipt.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-payment-systems-html": {
        "title": "Использование различных способов оплаты",
        "tags": "[]",
        "content": "Пользователи Эвотор могут установить на смарт-терминал приложения для работы с различными платёжными системами. После установки приложения платёжной системы, на экране оплаты/возврата товара, помимо кнопок Наличные и Банковская карта, добавляется кнопка платёжной системы.Служба для взаимодействия со сторонними платёжными системамиЧтобы добавить поддержку сторонней платёжной системы:      В манифесте приложения, добавьте разрешение:    &lt;uses-permission android:name=\"ru.evotor.permission.PAYMENT_SYSTEM\" /&gt;            Создайте службу и назовите её, например .PaymentService.    Служба будет обрабатывать событие evo.v2.receipt.paymentSystem.    Событие содержит поле OperationType, которое указывает тип операции:          OperationType.SELL – продажа;      OperationType.SELL_CANCEL – отмена продажи;      OperationType.PAYBACK – возврат;      OperationType.PAYBACK_CANCEL – отмена возврата.        Каждому типу операции соответствует событие и метод, который его обрабатывает. Методы представлены в классе PaymentSystemProcessor.kt:    abstract class PaymentSystemProcessor : ActionProcessor() {    override fun process(action: String, bundle: Bundle?, callback: ActionProcessor.Callback) {        val event = PaymentSystemEvent.create(bundle) ?: return        when (event.operationType) {            PaymentSystemEvent.OperationType.SELL -&gt; sell(action, event as PaymentSystemSellEvent, callback)            PaymentSystemEvent.OperationType.SELL_CANCEL -&gt; sellCancel(action, event as PaymentSystemSellCancelEvent, callback)            PaymentSystemEvent.OperationType.PAYBACK -&gt; payback(action, event as PaymentSystemPaybackEvent, callback)            PaymentSystemEvent.OperationType.PAYBACK_CANCEL -&gt; paybackCancel(action, event as PaymentSystemPaybackCancelEvent, callback)            else -&gt; null        }    }        Ваша служба должна реализовывать все методы, описанные в классе.        Измените раздел службы .PaymentService в манифесте приложения:    &lt;service    android:name=\".PaymentService\"    android:exported=\"true\"    android:icon=\"@android:drawable/ic_dialog_map\"    android:label=\"Текст на кнопке\"&gt;    &lt;meta-data        android:name=\"ru.evotor.sales_screen.BACKGROUND_COLOR\"        android:value=\"@android:color/holo_green_light\" /&gt;    &lt;meta-data        android:name=\"ru.evotor.paymentSystem.PAYMENT_SYSTEM_ID\"        android:value=\"ru.test.testapplication.paymentSystem.packageName\" /&gt;    &lt;intent-filter&gt;        &lt;action android:name=\"evo.v2.receipt.paymentSystem\" /&gt;    &lt;/intent-filter&gt;&lt;/service&gt;        Где:          Элемент ru.evotor.sales_screen.BACKGROUND_COLOR задаёт цвет кнопки платёжной системы.      Элемент ru.evotor.paymentSystem.PAYMENT_SYSTEM_ID задаёт уникальный идентификатор приложения. Уникальность идентификатора необходима, чтобы смарт-терминал всегда мог определить с какой платёжной системой он взаимодействует. Идентификатор остаётся неизменным даже, если название службы изменилось при обновлении приложения.         Совет: Хорошей практикой является использование packageName приложения в идентификаторе.          В intent-filter подпишите службу на получение события evo.v2.receipt.paymentSystem.            После обработки события evo.v2.receipt.paymentSystem, служба .PaymentService должна возвращать соответствующий результат.    В случае удачной обработки события служба возвращает результат PaymentSystemPaymentOkResult.    В случае неудачной обработки события служба возвращает результат PaymentSystemPaymentErrorResult.  СобытияВ зависимости от операции на смарт-терминале в службу могут поступать четыре типа событий.ПродажаПри продаже товара приходит событие PaymentSystemSellEvent.kt:class PaymentSystemSellEvent(        val receiptUuid: String,        val accountId: String?,        val sum: BigDecimal,        val description: String?)Где:  receiptUuid – идентификатор чека.  accountId – счёт (учётная запись) в платёжной системе. Поле указывать необязательно.  sum – сумма платежа.  description – текстовое описание. Поле может быть указано любым приложением, например, при разделении чека. В приложении требуется предусмотреть возможность отображения этого поля.Отмена продажиПри отмене продажи приходит событие PaymentSystemSellCancelEvent.kt:class PaymentSystemSellCancelEvent(        val receiptUuid: String,        val accountId: String?,        val sum: BigDecimal,        val rrn: String?,        val description: String?)Где:  receiptUuid – идентификатор чека.  accoundId – счёт (учётная запись) в платёжной системе.  sum – сумма платежа.  rrn – уникальный идентификатор платежа, который будет отменён.  description – текстовое описание. Поле может быть указано любым приложением, например, при разделении чека. В приложении требуется предусмотреть возможность отображения этого поля.ВозвратПри возврате товара приходит событие PaymentSystemPaybackEvent.kt:class PaymentSystemPaybackEvent(        val receiptUuid: String,        val accountId: String?,        val sum: BigDecimal,        val rrn: String?,        val description: String?)Где:  receiptUuid – идентификатор чека.  accoundId – счёт (учётная запись) в платёжной системе.  sum – сумма платежа.  rrn – уникальный идентификатор платежа, по которому будет проведён возврат.  description – текстовое описание. Поле может быть указано любым приложением, например, при разделении чека. В приложении требуется предусмотреть возможность отображения этого поля.Отмена возвратаПри отмене возврата приходит событие PaymentSystemPaybackCancelEvent.kt:class PaymentSystemPaybackCancelEvent(        val receiptUuid: String,        val accountId: String?,        val sum: BigDecimal,        val rrn: String?,        val description: String?)Где:  receiptUuid – идентификатор чека.  accoundId – счёт (учётная запись) в платёжной системе.  sum – сумма платежа.  rrn – уникальный идентификатор платежа, который будет отменён.  description – текстовое описание. Поле может быть указано любым приложением, например, при разделении чека. В приложении требуется предусмотреть возможность отображения этого поля.РезультатыУспешная обработка событияВ случае успешной обработки события служба должна возвращать результат PaymentSystemPaymentOkResult:class PaymentSystemPaymentOkResult(        val rrn: String,        val slip: List&lt;String&gt;,        val paymentInfo: String?,        val paymentType: PaymentType = PaymentType.ELECTRON)Где:  rrn – уникальный идентификатор платежа, который понадобится при отмене транзакции.  slip – текст, который будет напечатан на чеке в двух экземплярах.  paymentInfo – поле для хранения статистической информации. Приложение не заполняет это поле.  paymentType – тип оплаты. По умолчанию ELECTRON.Ошибка обработки событияВ случае ошибки служба должна возвращать результат PaymentSystemPaymentErrorResult.kt:class PaymentSystemPaymentErrorResult(        val errorDescription: String?)Где:  errorDescription – описание ошибки.Пример службы PaymentServiceПример работы с PaymentSystem API в демонстрационном приложении.Пример службы PaymentService, которая поддерживает все методы класса PaymentSystemProcessor.kt:public class PaymentService extends IntegrationService {    public static final String TAG = \"PaymentService\";    @Nullable    @Override    protected Map&lt;String, ActionProcessor&gt; createProcessors() {        Map&lt;String, ActionProcessor&gt; processorMap = new HashMap&lt;&gt;();        processorMap.put(                PaymentSystemEvent.NAME_ACTION,                new PaymentSystemProcessor() {                    @Override                    public void sell(String s, PaymentSystemSellEvent paymentSystemSellEvent, Callback callback) {                        Log.e(TAG, \"sell \" + paymentSystemSellEvent);                        Intent intent = new Intent(PaymentService.this, PaymentActivity.class);                        intent.putExtra(EXTRA_NAME_OPERATION, \"sell\");                        try {                            callback.startActivity(intent);                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                    @Override                    public void sellCancel(String s, PaymentSystemSellCancelEvent paymentSystemSellCancelEvent, Callback callback) {                        Log.e(TAG, \"sellCancel \" + paymentSystemSellCancelEvent);                        Intent intent = new Intent(PaymentService.this, PaymentActivity.class);                        intent.putExtra(EXTRA_NAME_OPERATION, \"sellCancel\");                        try {                            callback.startActivity(intent);                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                    @Override                    public void payback(String s, PaymentSystemPaybackEvent paymentSystemPaybackEvent, Callback callback) {                        Log.e(TAG, \"payback \" + paymentSystemPaybackEvent);                        Intent intent = new Intent(PaymentService.this, PaymentActivity.class);                        intent.putExtra(EXTRA_NAME_OPERATION, \"payback\");                        try {                            callback.startActivity(intent);                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                    @Override                    public void paybackCancel(String s, PaymentSystemPaybackCancelEvent paymentSystemPaybackCancelEvent, Callback callback) {                        Log.e(TAG, \"paybackCancel \" + paymentSystemPaybackCancelEvent);                        Intent intent = new Intent(PaymentService.this, PaymentActivity.class);                        intent.putExtra(EXTRA_NAME_OPERATION, \"paybackCancel\");                        try {                            callback.startActivity(intent);                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                }            }        );}Пример операции PaymentActivitypackage ru.apptest.test.testapplication;import android.os.Bundle;import android.view.View;import android.widget.TextView;import java.util.ArrayList;import java.util.List;import java.util.Random;import ru.evotor.framework.core.IntegrationActivity;import ru.evotor.framework.core.action.event.receipt.payment.system.result.PaymentSystemPaymentErrorResult;import ru.evotor.framework.core.action.event.receipt.payment.system.result.PaymentSystemPaymentOkResult;import ru.evotor.framework.payment.PaymentType;public class PaymentActivity extends IntegrationActivity {    public static final String EXTRA_NAME_OPERATION = \"EXTRA_NAME_OPERATION\";    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_payment);        findViewById(R.id.button_ok).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                String rrn = \"\";                Random random = new Random();                for (int i = 0; i &lt; 10; i++) {                    rrn += random.nextInt(10);                }                List&lt;String&gt; slip = new ArrayList&lt;String&gt;();                slip.add(\"SLIP START\");                slip.add(\"RRN:\");                slip.add(rrn);                slip.add(\"SLIP EMD\");                setIntegrationResult(new PaymentSystemPaymentOkResult(rrn, slip, \"123qwe\", PaymentType.ELECTRON));                finish();            }        });        findViewById(R.id.button_error).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                setIntegrationResult(new PaymentSystemPaymentErrorResult(\"beda was happened\"));                finish();            }        });        if (getIntent().hasExtra(EXTRA_NAME_OPERATION)) {            ((TextView) findViewById(R.id.textView_operation)).setText(getIntent().getStringExtra(EXTRA_NAME_OPERATION));        }    }    @Override    public void onBackPressed() {        setIntegrationResult(new PaymentSystemPaymentErrorResult(\"onBackPressed was happened\"));        finish();    }}",
        "url": "doc_java_payment_systems.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-pushnotifications-html": {
        "title": "Оповещение пользователей с помощью push-уведомлений",
        "tags": "[]",
        "content": "Приложения могут принимать и отображать push-уведомления.В качестве примера, рассмотрим класс, который отображет простое всплывающее сообщение.Чтобы реализовать поддержку push-уведомлений в приложении:      Создайте класс-приёмник push-уведомлений PushReceiver, который наследует класс PushNotificationReceiver.    public class PushReceiver extends PushNotificationReceiver { @Override public void onReceivePushNotification(Context context, Bundle data, long messageId) {     //...получение push-уведомления.     Toast.makeText(context, data.getString(\"header\") + \" \" + data.getString(\"description\")             + \" \" + messageId, Toast.LENGTH_SHORT).show();    }}            Добавьте необходимые права.    Для приложения:    &lt;uses-permission android:name=\"ru.evotor.pushnotifications.PUSH_RECEIVE\" /&gt;         Совет: Обратите внимание, как указаны права у демонстрационного приложения.    И для класса PushReceiver:    &lt;receiver   android:name=\".PushReceiver\"   android:permission=\"ru.evotor.pushnotifications.PUSH_SENDER\"&gt;   &lt;intent-filter&gt;       &lt;action android:name=\"ru.evotor.pushnotifications.PUSH_RECEIVED_EVENT\" /&gt;   &lt;/intent-filter&gt;&lt;/receiver&gt;        Укажите в классе intent-фильтр &lt;action android:name=\"ru.evotor.pushnotifications.PUSH_RECEIVED_EVENT\" /&gt;.  ПримерПример реализованной службы вы найдёте в нашем демонстрационном приложении, в ветке push_sample.См. также  Сборка и установка демонстрационного приложения",
        "url": "doc_java_pushnotifications.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-receipt-api-html": {
        "title": "Поиск товара по штрихкоду",
        "tags": "[]",
        "content": "КлассДля работы используйте класс ReceiptApi.МетодыПолучить по штрихкоду позицию для добавления в чек:fun getPositionsByBarcode(context: Context, barcode: String): List&lt;Position&gt;Где:  context – контекст приложения.  barcode – штрихкод товара.  List&lt;Position&gt; – список позицийПримерПример поиска товара по штрихкоду в демонстрационном приложении.",
        "url": "doc_java_receipt_api.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-receipt-creation-html": {
        "title": "Открытие чека в приложении",
        "tags": "[]",
        "content": "Чтобы открыть чек продажи в смарт-терминале:      Составьте список позиций, который требуется добавить в чек, и наполните его:    public void openReceipt() {        List&lt;PositionAdd&gt; positionAddList = new ArrayList&lt;&gt;();        JSONObject extra = new JSONObject();      }        Где:    List&lt;PositionAdd&gt; positionAddList = new ArrayList&lt;&gt;()– список позиций. Как добавить позицию в чек смотрите в разделе Добавление, изменение и удаление позиций.    JSONObject extra = new JSONObject();– добавляет дополнительные данные к чеку. Данные доступны только вашему приложению. Не создавайте этот объект, если приложение не добавляет дополнительные поля к чеку.        Создайте команду открытия чека и вызовите метод .process    new OpenSellReceiptCommand(positionAddList, null).process(                        activity,                        new IntegrationManagerCallback() {                            @Override                            public void run(IntegrationManagerFuture integrationManagerFuture) {                                try {                                    IntegrationManagerFuture.Result result = integrationManagerFuture.getResult();                                    if (result.getType() == IntegrationManagerFuture.Result.Type.OK) {                                        //Чтобы открыть другие документы используйте методы NavigationApi.                                        startActivity(NavigationApi.createIntentForSellReceiptPayment());                                    }                                } catch (IOException e) {                                    e.printStackTrace();                                } catch (IntegrationException e) {                                    e.printStackTrace();                                }                            }                        });        Где вместо null вы можете передать new SetExtra(extra), команду для создания дополнительных полей в чеке.    Чтобы открыть чек другого типа используйте соответствующую команду. Возможные команды:          OpenSellReceiptCommand – команда открытия чека продажи.      OpenPaybackReceiptCommand – команда открытия чека возврата проданного товара.      OpenBuyReceiptCommand – команда открытия чека покупки.      OpenBuybackReceiptCommand – команда открытия чека возврата купленного товара.         Совет: Замените SELL на PAYBACK, если хотите открыть чек возврата.     Примечание: При создании нового чека, происходит автоматическая очистка существующего открытого чека.  ПримерПример открытия чека продажи или возврата в демонстрационном приложении.",
        "url": "doc_java_receipt_creation.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-receipt-division-html": {
        "title": "Разделение чека",
        "tags": "[]",
        "content": "ТребованияЧтобы служба получала необходимые сообщения, в манифесте приложения требуется задать intent-filter для соответствующей службы:&lt;intent-filter&gt;  &lt;action android:name=\"evo.v2.receipt.sell.payment.SELECTED\" /&gt;  &lt;action android:name=\"evo.v2.receipt.sell.printGroup.REQUIRED\" /&gt;&lt;/intent-filter&gt;Где:  evo.v2.receipt.sell.payment.SELECTED – сообщает о разделении платежей.  evo.v2.receipt.sell.printGroup.REQUIRED – сообщает о разделении чека на несколько печатных групп.Разделение чекаСхема разделения чека выглядит следующим образом:Процесс разделения чека:  Пользователь выбирает тип оплаты Банковская карта.      Смарт-терминал передаёт событие PaymentSelectedEvent и ожидает ответа от приложений.     Примечание: Событие возникает только если пользователь выбрал безналичный расчёт.        Приложение может разделить чек на несколько платежей в счёт одного или нескольких юридических лиц.    Приложение возвращает данные о соответствии счетов и платежей в объекте PaymentSelectedEventResult и указывает разделение платежей в объекте PaymentPurpose.    Каждый из платежей, указанных в PaymentPurpose содержит:          собственный идентификатор объекта PaymentPurpose, который можно использовать для сопоставления платежа и печатной группы;      сумму платежа;      идентификаторы платёжной системы и счёта в ней;      текст, который отображается пользователю при проведении данного платежа.        В данный момент поддерживается разделение только в рамках той системы оплаты, которую выбрал пользователь. Разделение на различные системы оплаты (комбинированная оплата) не поддерживается.    Чтобы получить список счетов, доступных на данном смарт-терминале, воспользуйтесь методом getPaymentSystems, класса PaymentSystemApi.    Используйте команду SetExtra, чтобы добавить к чеку дополнительные поля.        На основе данных, полученных от приложения, смарт-терминал совершает платежи и начинает печать чека. Перед печатью чека EvoPOS передаёт событие PrintGroupRequiredEvent и ожидает ответа от приложений.        Приложение может напечатать несколько разных печатных документов и разделить платежи между ними.    Приложение передаёт данные о печатных документах, закреплённых за ними позициях и соответствующих платежах в объекте PrintGroupRequiredEventResult, которому соответствует список объектов SetPrintGroup.    Для каждого объекта SetPrintGroup приложение указывает:          печатную группу (PrintGroup);      список идентификаторов платежей (paymentPurposeIds);      список иденификаторов позиций в формате uuid4 (positionUuids)        В печатной группе приложение указывает:          идентификатор печатной группы;              тип чека:                  фискальный – CASH_RECEIPT          квитанция (нефискальный чек) – INVOICE                      ЕНВД (нефискальный чек) – STRING_UTII            Квитанция и ЕНВД чек задаются в виде строк, в отличие от фискального чека, который набирается с помощью команд ККМ. ЕНВД чек отличается от квитанции тем, что квитанция не содержит информации о способе оплаты и на распечатанном чеке явно указывается, что это квитанция.                                      систему налогообложения;        Систему налогообложения можно указывать как для фискальных, так и для нефискальных чеков. Смарт-терминал печатает чеки с указанной системой налогообложения, если она попадает в список разрешённых систем. В противном случае смарт-терминал выбирает систему налогообложения, заданную по умолчанию.            реквизиты организации (название, ИНН, адрес).      Поле true или false, которое задаёт необходимость печати чека.        Используйте команду SetExtra, чтобы добавить к чеку дополнительные поля.    EvoPOS печатает чек в соответствии с полученными печатными группами.Методы PaymentSystem APIИспользуйте класс PaymentSystemApi.Получить список платёжных систем, а также их учётных записей, доступных на смарт-терминале:fun getPaymentSystems(context: Context): List&lt;Pair&lt;PaymentSystem, List&lt;PaymentAccount&gt;&gt;&gt;Метод возвращает список доступных на терминале платёжных систем (PaymentSystem) и соответствующих им счетов (PaymentAccount). Счета можно получить у приложений, которые реализуют различные способы оплаты.Объекты PaymentSystem содержат:  тип платёжной системы (наличные, электронные платежи, другие);  название, которое можно отобразить пользователю;  постоянный идентификатор платёжной системы в терминале.Объекты PaymentAccount содержат:  идентификатор счёта в рамках платёжной системы;  название счёта, которое можно отобразить пользователю.ПримерыРазделение платежей в чекеПример разделения чека на несколько платежей в демонстрационном приложении.        processorMap.put(                PaymentSelectedEvent.NAME_SELL_RECEIPT,                new PaymentSelectedEventProcessor() {                    @Override                    public void call(@NonNull String s, @NonNull PaymentSelectedEvent                            paymentSelectedEvent, @NonNull Callback callback) {                        List&lt;PaymentPurpose&gt; paymentParts = new ArrayList&lt;PaymentPurpose&gt;();                        String psId = paymentSelectedEvent.getPaymentSystem().getPaymentSystemId();                        paymentParts.add(new PaymentPurpose(\"-1-\", psId, new BigDecimal(3), \"0\", \"платёж клиента 1\"));                        paymentParts.add(new PaymentPurpose(\"-2-\", psId, new BigDecimal(5), \"0\", \"платёж клиента 2\"));                        paymentParts.add(new PaymentPurpose(\"-3-\", psId, new BigDecimal(2), \"0\", \"платёж клиента 3\"));                        paymentParts.add(new PaymentPurpose(\"-4-\", psId, new BigDecimal(10), \"0\", \"платёж клиента 4\"));                        try {                            callback.onResult(                                    new PaymentSelectedEventResult(                                            null,                                            paymentParts                                    ).toBundle()                            );                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                }        );Разделение чека на несколько печатных группПример разделения чека на несколько печатных групп в демонстрационном приложении.Пример печати квитанции (INVOICE)processorMap.put(                PrintGroupRequiredEvent.NAME_SELL_RECEIPT,                new PrintGroupRequiredEventProcessor() {                    @Override                    public void call(@NonNull String s, @NonNull PrintGroupRequiredEvent printGroupRequiredEvent, @NonNull Callback callback) {                        List&lt;SetPrintGroup&gt; setPrintGroups = new ArrayList&lt;SetPrintGroup&gt;();                        PrintGroup printGroup = new PrintGroup(                                UUID.randomUUID().toString(),                                PrintGroup.Type.INVOICE,                                \"ООО \\\"Пример\\\"\",                                \"012345678901\",                                \"г. Москва\",                                TaxationSystem.PATENT,                                true                        );                        List&lt;String&gt; paymentPurposeIds = new ArrayList&lt;String&gt;();                        paymentPurposeIds.add(\"-1-\");                        paymentPurposeIds.add(\"-3-\");                        List&lt;String&gt; positionUuids = new ArrayList&lt;String&gt;();                        if (lastPosition != null) {                            positionUuids.add(lastPosition.getUuid());                        }                        setPrintGroups.add(new SetPrintGroup(                                printGroup,                                paymentPurposeIds,                                positionUuids                        ));                        try {                            callback.onResult(                                    new PrintGroupRequiredEventResult(                                            null,                                            setPrintGroups                                    )                            );                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                }        ); Примечание: Поле true печатной группы printGroup указывает, что чек будет напечатан. ",
        "url": "doc_java_receipt_division.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-receipt-extras-html": {
        "title": "Создание дополнительных полей в чеке",
        "tags": "[]",
        "content": "Приложения могут записывать дополнительные поля в чеки продажи и возврата.Дополнительные поля помогут вам хранить и отображать информацию, которая не предусмотрена стандартной моделью чека продажи или возврата.Например, системы лояльности могут хранить в дополнительных полях информацию о карте лояльности пользователя.Дополнительные поля должны представлять валидный JSON-объект:JSONObject object = new JSONObject();                object.put(\"key\", \"value\");                SetExtra extra = new SetExtra(object);Вы можете создавать дополнительные поля в чеках в следующих случаях:  при открытии чека;  при применении скидки;  при изменении позиций в чеке.",
        "url": "doc_java_receipt_extras.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-receipt-interactions-html": {
        "title": "Работа с позициями чека",
        "tags": "[]",
        "content": "Использование службы и получение событий о намерении изменения чека      Создайте службу, например MyIntegrationService, которая наследует класс IntegrationService. В колбэке onCreate службы, зарегистрируйте процессор BeforePositionsEditedEventProcessor (процессор наследует класс ActionProcessor).    public class MyIntegrationService extends IntegrationService { @Nullable @Override protected Map&lt;String, ActionProcessor&gt; createProcessors() {     Map&lt;String, ActionProcessor&gt; map = new HashMap&lt;&gt;();     map.put(BeforePositionsEditedEvent.NAME_SELL_RECEIPT, new BeforePositionsEditedEventProcessor() {         @Override         public void call(@NonNull String action, @NonNull BeforePositionsEditedEvent event, @NonNull Callback callback){         }     });     return map;    }}            Объявите службу в манифесте приложения:    &lt;service        android:name=\".MyIntegrationService\"        android:enabled=\"true\"        android:exported=\"true\"&gt;        &lt;intent-filter&gt;            &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;            &lt;action android:name=\"evo.v2.receipt.sell.beforePositionsEdited\" /&gt;        &lt;/intent-filter&gt;&lt;/service&gt;      В метод call процессора приходит событие beforePositionsEditedEvent и объект для возврата результата callback.В ответ приложение возвращает результат со списком возможных изменений:public BeforePositionsEditedEventResult(        @Nullable List&lt;IPositionChange&gt; changes,        @Nullable SetExtra extra)Чтобы вернуть результат, используйте метод:callback.onResult(beforePositionsEditedEventResult)Если приложению для возврата результата необходимо взаимодействие с пользователем, запустите операцию (Activity), которая наследует класс IntegrationActivity:callback.startActivity(new Intent(context, MainActivity.class));Ваша операция должна вызвать метод setIntegrationResult.Например:setIntegrationResult(new BeforePositionsEditedEventResult(changes, null));Где вместо null вы можете передать new SetExtra(extra), команду для создания дополнительных полей в чеке.Описание события BeforePositionsEditedEventО намерении изменения чека сообщает событие beforePositionsEditedEvent:Описание позицииВы можете добавить в чек как позицию соответствующую товару в базе терминала, так и задать свободную позицию.Конструкторы позиций описаны  в классе Position.java.Пример конструктора позиции чека, соответствующей товару в терминале (у позиции есть uuid товара):public Position(        String uuid,        String productUuid,        String productCode,        ProductType productType,        String name,        String measureName,        int measurePrecision,        TaxNumber taxNumber,        BigDecimal price,        BigDecimal priceWithDiscountPosition,        BigDecimal quantity,        String barcode,        String mark,        BigDecimal alcoholByVolume,        Long alcoholProductKindCode,        BigDecimal tareVolume,        Set&lt;ExtraKey&gt; extraKeys,        List&lt;Position&gt; subPositions)Где:  uuid – идентификатор позиции в формате uuid4.  productUuid – идентификатор товара в формате uuid4, полученный из локальной базы товаров смарт-терминала.  productCode – Код товара. Может быть null.  productType – Вид товара.  name – наименование товара из локальной базы товаров смарт-терминала.  measureName – единицы измерения товара, полученные из локальной базы товаров смарт-терминала.  measurePrecision – точность измерения единиц товара, выраженная в количестве знаков после запятой.  taxNumber – налоговая ставка. Может быть null. Доступные значения описаны в классе TaxNumber.java. Если поле не задано, смарт-терминал обращается за налоговой ставкой в Облако. Если в Облаке нет информации о налоговой ставке для позиции, смарт-терминал использует значение, заданное в настройках.  price – цена продукта, полученная из локальной базы товаров смарт-терминала.  priceWithDiscountPosition – цена позиции с учётом скидки.  quantity – количество добавленного товара.  barcode – штрихкод, по которому найден товар. Может быть null.  mark – алкогольная марка.  alcoholByVolume – крепость алкогольной продукции. Может быть null.  alcoholProductKindCode – код вида продукции ФСРАР. Может быть null.  tareVolume – объём тары. Может быть null.      extraKeys – дополнительные ключи (идентификаторы). Каждый ключ имеет описание (description), которое отображается в интерфейсе и печатается на чеке (можно передавать null), идентификатор (identity) и хранит данные о приложении, создавшем ключ (appId).     Примечание: Приложение записывает дополнительные ключи в чек только под своим идентификатором.    subPositions – список подпозиций.Позиция с подпозициейПример позиции чека с подпозицией (у позиции и подпозиции есть uuid товара):val positionFromProduct = Position.Builder.newInstance(                UUID.randomUUID().toString(),                product.uuid,                product.name,                product.measureName,                product.measurePrecision,                product.price,                BigDecimal.ONE        ).build()        positionFromProduct.subPosition.add(                Position.Builder.newInstance(                                UUID.randomUUID().toString(),                                product.uuid,                                product.name,                                product.measureName,                                product.measurePrecision,                                product.price,                                BigDecimal.ONE                        ).build()                )Вы можете использовать подпозиции subPosition для добавления опций к товару.Например, к товару “Кофе” можно добавить подпозицию “Молоко”. Подпозиция удаляется вместе с основной позицией товара.Свободно заданная позицияПример свободно заданной позиции (uuid товара – null):val freeProductPosition = Position.Builder.newInstance(                UUID.randomUUID().toString(),                null,                \"Товар\",                \"шт\",                0,                BigDecimal(100),                BigDecimal(100)        ).build()Добавление, изменение и удаление позицийЧтобы добавить позицию:      В Java-приложении используйте метод:    data class PositionAdd(val position: Position) : IPositionChange {    override fun toBundle(): Bundle {        return Bundle().apply {            putBundle(                    PositionMapper.KEY_POSITION,                    PositionMapper.toBundle(position)            )        }    }    override fun getPositionUuid(): String? {        return position.uuid    }    override fun getType(): IChange.Type {        return IChange.Type.POSITION_ADD    }    companion object {        @JvmStatic        fun from(bundle: Bundle?): PositionAdd? {            bundle ?: return null            return PositionAdd(                    PositionMapper.from(                            bundle.getBundle(PositionMapper.KEY_POSITION)                    ) ?: return null            )        }    }}            В JS-приложении используйте метод:    function processBeforePositionsEdited(actionData) {var position = {    \"uuid\" : \"8e0ffg-lk3e-e93bnk-v0p41\",    \"productUuid\" : \"trb44-i32lev-9833jf\",    \"productCode\" : \"1024\",    \"productType\" : \"NORMAL\",    \"name\" : \"myLittlePosition\",    \"measureName\" : \"kg\",    \"measurePrecision\" : 0,    \"price\" : \"100\",    \"quantity\" : \"1\"}    receipt.addPosition(JSON.stringify(position));}      Чтобы изменить позицию, используйте следующий метод:data class PositionEdit(val position: Position) : IPositionChange {    override fun toBundle(): Bundle {        return Bundle().apply {            putBundle(                    PositionMapper.KEY_POSITION,                    PositionMapper.toBundle(position)            )        }    }    override fun getPositionUuid(): String? {        return position.uuid    }    override fun getType(): IChange.Type {        return IChange.Type.POSITION_EDIT    }    companion object {        @JvmStatic        fun from(bundle: Bundle?): PositionEdit? {            bundle ?: return null            return PositionEdit(                    PositionMapper.from(bundle.getBundle(PositionMapper.KEY_POSITION)) ?: return null            )        }    }}Чтобы удалить позицию, используйте следующий метод:data class PositionRemove(        private val positionUuid: String) : IPositionChange {    override fun toBundle(): Bundle {        return Bundle().apply {            putString(                    KEY_POSITION_UUID,                    positionUuid            )        }    }    override fun getPositionUuid(): String? {        return positionUuid    }    override fun getType(): IChange.Type {        return IChange.Type.POSITION_REMOVE    }    companion object {        const val KEY_POSITION_UUID = \"positionUuid\"        @JvmStatic        fun from(bundle: Bundle?): PositionRemove? {            bundle ?: return null            return PositionRemove(                    bundle.getString(KEY_POSITION_UUID) ?: return null            )        }    }}",
        "url": "doc_java_receipt_interactions.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-receipt-print-html": {
        "title": "Печать внутри кассового чека",
        "tags": "[&quot;java&quot;, &quot;terminal&quot;, &quot;equipment&quot;]",
        "content": "Смарт-терминал позволяет приложениям печатать свои данные внутри кассового чека: тексты, штрихкоды или изображения.Следующие методы определяют, где печатаются переданные данные:  PrintExtraPlacePrintGroupTop – данные печатаются после клише и до текста “Кассовый чек”;  PrintExtraPlacePrintGroupHeader – данные печатаются после текста “Кассовый чек”, до имени пользователя;  PrintExtraPlacePrintGroupSummary – данные печатаются после итога и списка оплат, до текста “всего оплачено”;  PrintExtraPlacePositionFooter – данные печатаются в позиции в чеке, до подпозиций;  PrintExtraPlacePositionAllSubpositionsFooter – данные печатаются в позиции в чеке, после всех подпозиций.Печать данных внутри кассового чекаЧтобы приложение печатало данные внутри кассового чека:      В манифесте приложения, укажите права приложения:    &lt;uses-permission android:name=\"ru.evotor.permission.receipt.printExtra.SET\" /&gt;        Создайте службу, которая отвечает за передачу данных для печати.      Объявите службу в манифесте приложения и укажите intent-filter:    &lt;action android:name=\"&lt;Событие&gt;\" /&gt;        где необходимо указать событие, при которое определяет тип чека, в котором будут напечатаны данные. Возможны следующие события:          evo.v2.receipt.sell.printExtra.REQUIRED – печать внутри кассового чека продажи товара.      evo.v2.receipt.buy.printExtra.REQUIRED  – печать внутри кассового чека покупки товара.      evo.v2.receipt.payback.printExtra.REQUIRED – печать внутри кассового чека возврата проданного товара.      evo.v2.receipt.buyback.printExtra.REQUIRED – печать внутри кассового чека возврата купленного товара.            В службе, подпишите процессор PrintExtraRequiredEventProcessor на событие:    processorMap.put(                //NAME_SELL_RECEIPT – имя события, которое указывает тип чека, где будут напечатаны данные.                PrintExtraRequiredEvent.NAME_SELL_RECEIPT,                new PrintExtraRequiredEventProcessor() {                }                )            В службе, в методе PrintExtraRequiredEventProcessor укажите место и массив данных, которые требуется распечатать:    new PrintExtraRequiredEventProcessor() {    @Override    public void call(String s, PrintExtraRequiredEvent printExtraRequiredEvent, Callback callback) {        List&lt;SetPrintExtra&gt; setPrintExtras = new ArrayList&lt;SetPrintExtra&gt;();        setPrintExtras.add(new SetPrintExtra(                //Метод, который указывает место, где будут распечатаны данные.                new PrintExtraPlacePrintGroupTop(null),                //Массив данных, которые требуется распечатать.                new IPrintable[]{                        new PrintableText(\"&lt;Текст&gt;\"),                        new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39),                        new PrintableImage(BitmapFactory.decodeFile(\"&lt;путь к файлу изображения&gt;\"))                }        ));      }    }         Примечание: Наполняйте массив IPrintable только теми элементами, которые требуется распечатать. Например, если на чеке необходимо распечатать только штрихкод, в массив следует добавить только элемент new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39). Пустые элементы в массиве IPrintable приведут к исключению.  ПримерПечать внутри кассового чека продажи и возврата в демонстрационном приложении.Ниже приведена служба, которая передаёт данные для печати с помощью всех доступных методов:processorMap.put(                PrintExtraRequiredEvent.NAME_SELL_RECEIPT,                new PrintExtraRequiredEventProcessor() {                    @Override                    public void call(String s, PrintExtraRequiredEvent printExtraRequiredEvent, Callback callback) {                        List&lt;SetPrintExtra&gt; setPrintExtras = new ArrayList&lt;SetPrintExtra&gt;();                        setPrintExtras.add(new SetPrintExtra(                                new PrintExtraPlacePrintGroupTop(null),                                new IPrintable[]{                                        new PrintableText(\"&lt;Текст&gt;\"),                                        new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39),                                        new PrintableImage(BitmapFactory.decodeFile(\"&lt;путь к файлу изображения&gt;\"))                                }                        ));                        setPrintExtras.add(new SetPrintExtra(                                new PrintExtraPlacePrintGroupHeader(null),                                new IPrintable[]{                                        new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39),                                        new PrintableText(\"&lt;Текст&gt;\")                                }                        ));                        setPrintExtras.add(new SetPrintExtra(                                new PrintExtraPlacePrintGroupSummary(null),                                new IPrintable[]{                                        new PrintableText(\"&lt;Текст&gt;\"),                                        new PrintableImage(BitmapFactory.decodeFile(\"&lt;путь к файлу изображения&gt;\")),                                        new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39),                                        new PrintableText(\"&lt;Текст&gt;\")                                }                        ));                        Receipt r = ReceiptApi.getReceipt(DiscountService.this, Receipt.Type.SELL);                        if (r != null) {                            for (Position p : r.getPositions()) {                                setPrintExtras.add(new SetPrintExtra(                                        new PrintExtraPlacePositionFooter(p.getUuid()),                                        new IPrintable[]{                                                new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39),                                                new PrintableText(\"&lt;Текст&gt;\\n\" + p.getUuid() + \"\\n&lt;Текст&gt;\")                                        }                                ));                                setPrintExtras.add(new SetPrintExtra(                                        new PrintExtraPlacePositionAllSubpositionsFooter(p.getUuid()),                                        new IPrintable[]{                                                new PrintableBarcode(\"&lt;Штрихкод&gt;\", PrintableBarcode.BarcodeType.CODE39),                                                new PrintableText(\"&lt;Текст&gt;\\n\" + p.getUuid() + \"\\n&lt;Текст&gt;\")                                        }                                ));                            }                        }                        try {                            callback.onResult(new PrintExtraRequiredEventResult(setPrintExtras).toBundle());                        } catch (RemoteException exc) {                            exc.printStackTrace();                        }                    }                }        );",
        "url": "doc_java_receipt_print.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-scales-html": {
        "title": "Работа с весами",
        "tags": "[]",
        "content": "Чтобы получить данные от весов:      В колбэке onCreate() или при запуске операции (activity) инициализируйте класс ru.evotor.devices.commons.DeviceServiceConnector:    DeviceServiceConnector.startInitConnections(getApplicationContext());    Класс инициализируется асинхронно, чтобы не препятствовать вызывающему потоку     Совет: Воспользуйтесь методом addConnectionWrapper, чтобы получить событие об успешном подключении. Используйте это событие, если необходимо выполнить какой-либо код сразу после установки соединения.        Вызовите метод DeviceServiceConnector.getScalesService().    Метод не может быть null и в случае успеха возвращает объект ru.evotor.devices.commons.IScalesServiceWrapper.    Метод может вернуть следующие исключения (exception):          ru.evotor.devices.commons.exception.ServiceNotConnectedException возвращается в результате серии неудачных попыток подключиться к весам.      ru.evotor.devices.commons.exception.DeviceServiceException – наследованое исключение.            С помощью метода Weight getWeight(int deviceId), объекта ru.evotor.devices.commons.IScalesService, вы можете получить вес товара Weight.    Где:    deviceId – указывает устройство, для которого вызывается метод.     Важно: В настоящий момент приложения не могут получить список номеров подключённых устройств, поэтому вместо номера устройства всегда следует передавать константу ru.evotor.devices.commons.Constants.DEFAULT_DEVICE_INDEX. Будет использовано устройство, заданное по умолчанию.    Weight – вес товара, заданный в виде:    private final BigDecimal weightInGrams;//вес товара в граммах, возвращённый весами.// поддерживали ли весы флаг стабильности при последнем взвешиванииprivate final boolean supportStable;//Указывает был установлен флаг стабильности при последнем взвешивании или нет.private final boolean stable;//Указывает стабильность последнего взвешивания.      Метод может вернуть наследованное исключение ru.evotor.devices.commons.exception.DeviceServiceException.",
        "url": "doc_java_scales.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-session-html": {
        "title": "Получение информации о кассовых сменах",
        "tags": "[]",
        "content": "ОписаниеС помощью методов класса SystemStateApi.kt приложения получают информацию о кассовой смене.МетодыgetLastSessionNumberfun getLastSessionNumber(context: Context): Long?ОписаниеПолучает номер последней кассовой смены.Параметры  context – контекст приложения.Возвращает  Long – номер кассовой смены.isSessionOpenedfun isSessionOpened(context: Context): Boolean?ОписаниеВозвращает информацию о состоянии кассовой смены.Параметры  context – контекст приложения.Возвращает  true – смена открыта.  false – смена закрыта.ПримерПример использования методов SystemStateApi.kt. Примечание: Соответствующие кнопки требуется зарегистрировать в манифесте приложения.package &lt;Ваш packagename&gt;import android.os.Bundleimport android.support.v7.app.AppCompatActivityimport android.widget.Buttonimport ru.evotor.framework.system.SystemStateApiclass IntegrationLibraryApiTestActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        //Вызов суперкласса onCreate, создающего операцию.        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_integration_library_api_test)        //Кнопка, нажатиже на которую возвращает номер последней кассовой смены.        findViewById&lt;Button&gt;(R.id.get_last_session_number).setOnClickListener {            getLastSessionNumber()        }        //Кнопка, нажатиже на которую возвращает информацию состоянии кассовой смены.        findViewById&lt;Button&gt;(R.id.get_is_session_opened).setOnClickListener {            getIsSessionOpened()        }    }    //Функция, реализующая метод получения номера последней кассовой смены    //SystemStateApi.getLastSessionNumber()    private fun getLastSessionNumber() {        val lastSessionNumber = SystemStateApi.getLastSessionNumber(this)        if (lastSessionNumber != null) {            //Выводит на экран номер последней кассовой смены.            println(\"lastSessionNumber = $lastSessionNumber\")        } else {            //Выводит на экран сообщение, если номер кассовой смены получить не удалось.            println(\"Не удалось получить номер последней кассовой смены.\")        }    }    //Функция, реализующая метод получения информации о состоянии кассовой смены    //SystemStateApi.isSessionOpened()    private fun getIsSessionOpened() {        val isSessionOpened = SystemStateApi.isSessionOpened(this)        if (isSessionOpened != null) {            //Выводит на экран состояние текущей кассовой смены.            println(\"isSessionOpened = $isSessionOpened\")        } else {            //Выводит на экран сообщение, если состояние кассовой смены получить не удалось.            println(\"Не удалось определить состояние текущей кассовой смены.\")        }    }}",
        "url": "doc_java_session.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-st-events-html": {
        "title": "Обработка событий смарт-терминала",
        "tags": "[]",
        "content": "Получение событий об открытии чека, обновлении базы товаров или результате изменения чекаСмарт-терминал не ждёт ответ от приложения на широковещательные сообщения. Чтобы получать сообщения о результате изменения позиций в чеке, зарегистрируйте приёмник широковещательных сообщений:package ru.evotor.consumer.consumer;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.widget.Toast;import ru.evotor.framework.core.action.event.receipt.position_edited.PositionAddedEvent;public class AddPositionBroadcastReceiver extends BroadcastReceiver {    @Override    public void onReceive(Context context, Intent intent)        { Toast.makeText(context, \"UUID: \" + PositionAddedEvent.create(intent.getExtras()).getReceiptUuid(), Toast.LENGTH_LONG).show(); }    }}Объявите приёмник в манифесте приложения:&lt;receiver        android:name=\".AddPositionBroadcastReceiver\"        android:enabled=\"true\"        android:exported=\"true\"&gt;        &lt;intent-filter&gt;            &lt;action android:name=\"evotor.intent.action.receipt.sell.POSITION_ADDED\" /&gt;            &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;        &lt;/intent-filter&gt;    &lt;/receiver&gt;Сообщения о результатах изменения чекаСобытие открытия чекаПри открытии чека (продажи или возврата) приходит сообщение:public interface ReceiptOpenedEvent {    String BROADCAST_ACTION_SELL_RECEIPT = \"evotor.intent.action.receipt.sell.OPENED\";    String BROADCAST_ACTION_PAYBACK_RECEIPT = \"evotor.intent.action.receipt.payback.OPENED\";    String KEY_UUID = \"uuid\";}Событие добавления позиции в чекПри добавлении позиции приходит сообщение:public class PositionAddedEvent extends PositionEvent {    public static final String BROADCAST_ACTION_SELL_RECEIPT = \"evotor.intent.action.receipt.sell.POSITION_ADDED\";    public static final String BROADCAST_ACTION_PAYBACK_RECEIPT = \"evotor.intent.action.receipt.payback.POSITION_ADDED\";    public PositionAddedEvent(Bundle extras) {        super(extras);    }    public PositionAddedEvent(String receiptUuid, Position position) {        super(receiptUuid, position);    }}Событие изменения позиции в чекеПри изменении позиции приходит сообщение:public class PositionEditedEvent extends PositionEvent {    public static final String BROADCAST_ACTION_SELL_RECEIPT = \"evotor.intent.action.receipt.sell.POSITION_EDITED\";    public static final String BROADCAST_ACTION_PAYBACK_RECEIPT = \"evotor.intent.action.receipt.payback.POSITION_EDITED\";    public PositionEditedEvent(Bundle extras) {        super(extras);    }    public PositionEditedEvent(String receiptUuid, Position position) {        super(receiptUuid, position);    }}Событие удаления позиции из чекаПри удалении позиции приходит сообщение:public class PositionRemovedEvent extends PositionEvent {    public static final String BROADCAST_ACTION_SELL_RECEIPT = \"evotor.intent.action.receipt.sell.POSITION_REMOVED\";    public static final String BROADCAST_ACTION_PAYBACK_RECEIPT = \"evotor.intent.action.receipt.payback.POSITION_REMOVED\";    public PositionRemovedEvent(Bundle extras) {        super(extras);    }    public PositionRemovedEvent(String receiptUuid, Position position) {        super(receiptUuid, position);    }}Событие обновления базы товаровПри обновлении базы товаров приходит сообщение:public class PositionRemovedEvent extends PositionEvent {    public static final String BROADCAST_ACTION_PRODUCTS_UPDATED = \"evotor.intent.action.inventory.PRODUCTS_UPDATED\";    public ProductsUpdatedEvent(Bundle extras) {        super(extras);    }    public ProductsUpdatedEvent(String receiptUuid, Position position) {        super(receiptUuid, position);    }}Событие очистки чекаПри очистке чека приходит сообщение:public class ReceiptClearedEvent extends ReceiptEvent {    public static final String BROADCAST_ACTION_SELL_RECEIPT_CLEARED = \"evotor.intent.action.receipt.sell.CLEARED\";    public static final String BROADCAST_ACTION_PAYBACK_RECEIPT_CLEARED = \"evotor.intent.action.receipt.payback.CLEARED\";    public ReceiptClearedEvent(@NonNull String receiptUuid) {        super(receiptUuid);    }    @Nullable    public static ReceiptClearedEvent create(@Nullable Bundle bundle) {        if (bundle == null) {            return null;        }        String receiptUuid = getReceiptUuid(bundle);        if (receiptUuid == null) {            return null;        }        return new ReceiptClearedEvent(receiptUuid);    }}Логирование различных событий смарт-терминалаНиже представлен пример логирования событий, которые может распространять смарт-терминал. Для обработки таких событий также требуется создавать приёмник широковещательных сообщений.public class MyReceiver extends BroadcastReceiver {    @Override    public void onReceive(Context context, Intent intent) {        String action = intent.getAction();        Bundle bundle = intent.getExtras();        Log.e(\"TAG\", action);        if (action.equals(\"evotor.intent.action.cashDrawer.OPEN\")) {            CashDrawerOpenEvent.create(bundle);//Открытие денежного ящика.        } else if (action.equals(\"evotor.intent.action.cashOperation.CASH_IN\")) {            Log.e(\"TAG\", \"total\" + CashInEvent.create(bundle).getTotal().toPlainString());//Внесение наличных.            Log.e(\"TAG\", \"uuid\" + CashInEvent.create(bundle).getDocumentUuid());        } else if (action.equals(\"evotor.intent.action.cashOperation.CASH_OUT\")) {            Log.e(\"TAG\", \"total\" + CashOutEvent.create(bundle).getTotal().toPlainString());//Изъятие наличных.            Log.e(\"TAG\", \"uuid\" + CashOutEvent.create(bundle).getDocumentUuid());        } else if (action.equals(\"evotor.intent.action.inventory.CARD_OPEN\")) {            Log.e(\"TAG\", \"uuid\" + ProductCardOpenedEvent.create(bundle).getProductUuid());//Открытие карточки товара.        } else if (action.equals(\"evotor.intent.action.receipt.sell.CLEARED\")) {            Log.e(\"TAG\", \"uuid\" + ReceiptClearedEvent.create(bundle).getReceiptUuid());//Очистка чека продажи (создание нового чека).        } else if (action.equals(\"evotor.intent.action.receipt.payback.CLEARED\")) {            Log.e(\"TAG\", \"uuid\" + ReceiptClearedEvent.create(bundle).getReceiptUuid());//Очистка чека возврата (создание нового чека).        } else if (action.equals(\"evotor.intent.action.receipt.sell.RECEIPT_CLOSED\")) {            Log.e(\"TAG\", \"uuid\" + ReceiptClosedEvent.create(bundle).getReceiptUuid());//Закрытие чека продажи.        } else if (action.equals(\"evotor.intent.action.receipt.payback.RECEIPT_CLOSED\")) {            Log.e(\"TAG\", \"uuid\" + ReceiptClosedEvent.create(bundle).getReceiptUuid());//Закрытие чека возврата.        } else if (action.equals(\"evotor.intent.action.receipt.sell.OPENED\")) {            Log.e(\"TAG\", \"uuid\" + ReceiptOpenedEvent.create(bundle).getReceiptUuid());//Открытие чека продажи.        } else if (action.equals(\"evotor.intent.action.receipt.payback.OPENED\")) {            Log.e(\"TAG\", \"uuid\" + ReceiptOpenedEvent.create(bundle).getReceiptUuid());//Открытие чека возврата.        }    }}",
        "url": "doc_java_st_events.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-third-party-service-communication-html": {
        "title": "Обмен сообщениями приложения и стороннего сервиса",
        "tags": "[]",
        "content": "Все запросы приложений к стороннему сервису проходят через Облако Эвотор:Для отправки запросов приложения могут использовать только 80 и 443 порт.Смарт-терминал не поддерживает протокол WebSocket. Важно: Установленные на смарт-терминале приложения могут обращаться только к сторонним сервисам. При этом, если сторонние сервисы находятся в одной локальной сети со смарт-терминалом, облако не проксирует запросы. Обращаться к REST API Облака Эвотор нельзя.Подготовка к отправке запросовДля отправки запросов требуется:  На портале dev.evotor.ru, указать список разрешённых URL, к которым может обращаться приложение.  Поддержать возможность обращения к сторонним сервисам в приложении.      Установить приложение в Магазине приложений.    В данном случае установка подразумевает активацию приложения в Личном кабинете и необходима, чтобы применились URL, которые вы указали на сайте разработчиков.   Примечание: Если вы разрабатываете JS-приложение, смотрите раздел “Обмен сообщениями JS-приложения и стороннего сервиса”.Настройка списка разрешённых URLЧтобы настроить список разрешённых URL:  На портале dev.evotor.ru выберите приложение, для которого требуется указать список разрешённых URL.  На вкладке Интеграция, установите флажок Проксирование запросов из приложения с терминала на ваш сервер (ver. 2) и укажите список URL, к которым может обращаться приложение.Примеры:  http://example\\.com/document.*\\.jsp\\?wildcard=\\*&amp;param=value.*;  https://another\\.host\\.com/document.*\\.jsp;  https://another\\.host\\.com/.*. Совет: Чтобы задавать маски веб-сайтов используйте регулярные выражения.После создания списка и установки приложения в Магазине приложений, обмен сообщениями происходит по описанному ниже процессу.Шаг 1. Приложение отправляет HTTP-сообщение в сторонний сервисПриложение создаёт HTTP-сообщение и отправляет его в сторонний сервис. Вы можете воспользоваться любым удобным способом отправки сообщения.Например, для отправки HTTP-сообщения из Java-приложения вы можете, использовать библиотеку OkHttp или способ, описанный на сайте developer.android.com.Независимо от версии проксирования, SDK смарт-терминала и Облако Эвотор поддерживают следующие HTTP-методы:  GET;  POST;  PUT;  DELETE.Эвотор гарантирует поддержку следующих MIME-типов:  application/x-www-form-urlencoded  application/json  application/xml  text/*  image/*  multipart/form-dataПоддержка других MIME-типов не гарантируется.Шаг 2. Смарт-терминал передаёт сообщение в облакоТерминал перехватывает сообщение и передаёт его в облако Эвотор.Заголовки, которые терминал добавляет к запросу вашего приложения:  X-Device-ID  X-Device-IMEI  X-User-ID  X-Signed-Url  X-Shop-UUID  X-Device-Salt  X-Device-Algorithm  X-Device-Date  X-Secret-Device-ID  X-OAuth-Client-ID  X-Device-UUID  X-Evotor-*  Expect  Host  Transfer-Encoding Примечание: Убедитесь, что ваше приложение не использует перечисленные заголовки. В противном случае, смарт-терминал перезапишет их содержимое.Шаг 3. Облако передаёт сообщение адресатуОблако удаляет служебные заголовки, добавляет свои заголовки и передаёт сообщение адресату.Заголовки, которые добавляет облако:  X-Evotor-Store-Uuid – содержит идентификатор магазина в формате uuid4, к которому привязан терминал.  X-Evotor-Device-UUID – содержит идентификатор устройства в формате uuid4, полученный по запросу к /api/v1/inventories/devices.  X-Evotor-User-Id – содержит идентификатор пользователя в Облаке Эвотор.  Authorization – содержит токен пользователя приложения стороннего сервиса. Токен необходим для bearer-авторизации.Сторонний сервер получает сообщение от облака Эвотор и определяет отправителя с помощью заголовка Authorization.Шаг 4. Ответ стороннего сервисаОтвет стороннего сервиса передаётся приложению в обратном порядке.Требования к содержимому ответа отсутствуют. Совет: За проксирование отвечает параметр Проксирование запросов из приложения с терминала на ваш сервер на вкладке Интеграция вашего приложения, на сайте dev.evotor.ru.",
        "url": "doc_java_third_party_service_communication.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "doc-java-z-report-html": {
        "title": "Печать Z-отчёта",
        "tags": "[]",
        "content": "Чтобы напечатать z-отчёт:      В манифесте укажите права приложения:    &lt;uses-permission android:name=\"ru.evotor.permission.PRINT_Z_REPORT\" /&gt;            Создайте команду для снятия чека и вызовите метод .process:    new PrintZReportCommand().process(context, callback);        Результатом выполнения команды будет печать z-отчёта.  ",
        "url": "doc_java_z_report.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "java-examples-html": {
        "title": "Примеры реализации",
        "tags": "[&quot;publishing&quot;, &quot;stuff&quot;]",
        "content": "integration-library          Поиск товара      Пример показывает простой сценарий использования InventoryAPI                Поиск товара      Пример показывает простой сценарий использования InventoryAPI      egais-api          Чтение данных об организации                      Чтение данных о товарах                      Работа с ТТН                      Работа с актами списания                      Работа с актами приёмки в магазин            ",
        "url": "java_examples.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "java-introduction-html": {
        "title": "Введение",
        "tags": "[]",
        "content": "Информация, представленная в этом разделе, поможет вам при разработке Java-приложения.В разделе представлены Javadoc-справочники наших библиотек integration",
        "url": "java_introduction.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          

      "java-query-api-html": {
        "title": "Обращение к базе данных смарт-терминала",
        "tags": "[]",
        "content": "С помощью запросов к базе данных смарт-терминала приложения могут получать необходимую информацию, например, данные товаров (класс ProductQuery.kt).Построение запросаПример запроса для получения данных товара:const products = await new ProductQuery()        .alcoholByVolume.between(40, 70)        .intersection(new ProductQuery()            .price.greater(100, true)            .or().tareVolume.greater(10)            .union(new ProductQuery()                .price.lower(5)                .and().name.like(\"Водка\")            )        ).sortOrder(new ProductSortOrder()            .price.asc()            .alcoholByVolume.desc()            .tareVolume.asc()        ).limit(1000)        .execute();ОператорыОператоры сравненияДля построения запросов доступны следующие операторы сравнения:  fun equal(value: V) – аналогичен оператору “равно” =.  fun notEqual(value: V) – аналогичен оператору “равно” !=.  fun greater(value: V, including: Boolean = false) – аналогичен оператору “больше” &gt;.  fun lower(value: V, including: Boolean = false) – аналогичен оператору “меньше” &lt;.  fun like(text: String, useEscape: Boolean = false) – определяет совпадает ли символьная строка с заданным шаблоном.  fun between(leftValue: V, rightValue: V) – задаёт диапазон для проверки.  fun notBetween(leftValue: V, rightValue: V) – задаёт диапазон, за пределами которого находится удовлетворяющий условию результат.  fun inside(values: List&lt;V&gt;) – определяет находится ли значение в заданном списке.  fun inside(values: Array&lt;V&gt;) – определяет находится ли значение в заданном массиве.  fun notInside(values: List&lt;V&gt;) – определяет находится ли значение за пределами заданного списка.  fun notInside(values: Array&lt;V&gt;) – определяет находится ли значение за пределами заданного массива.Логические операторыДля построения запросов доступны следующие логические операторы:  and(intersection: Executor&lt;Q, S, R&gt;) – логическое “И” (пересечение).  or(union: Executor&lt;Q, S, R&gt;) – логическое “ИЛИ” (объединение).  and(): Q – логическое “И”.  or(): Q – логическое “ИЛИ”.ПримерПример приложения, которое получает данные товара.",
        "url": "java_query_api.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          

      "doc-dev-site-introduction-html": {
        "title": "Введение",
        "tags": "[]",
        "content": "",
        "url": "doc_dev_site_introduction.html",
        "product": "Java SDK"
      }
      ,
      
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
            
          
      
    
          
          
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
  };
</script>

<script src="assets/js/lunr.min.js"></script>
<script src="assets/js/lunr.stemmer.support.js"></script>
<script src="assets/js/lunr.ru.js"></script>
<script src="assets/js/lunr.multi.js"></script>
<script src="assets/js/search.js"></script>

                <div class="toc-main-column">
                

              </div>
                


            </div><!-- /.col-xs-12 main -->

            <div class="col-xs-12 col-sm-2 right-lane">
              <div class="inner">


</div>

              

        </div><!--/.row-->
    </div><!--/.container-->
</div><!--/.page-container-->



<!--scripts loaded here-->
<script src="assets/js/jquery.magnific-popup.js"></script>
<script>
$('.no_icon').magnificPopup({
type: 'image',
closeBtnInside: false,
closeOnContentClick: false,

callbacks: {
  open: function() {
    var self = this;
    self.wrap.on('click.pinhandler', 'img', function() {
      self.wrap.toggleClass('mfp-force-scrollbars');
    });
  },
  beforeClose: function() {
        this.wrap.off('click.pinhandler');
    this.wrap.removeClass('mfp-force-scrollbars');
  }
},

image: {
  verticalFit: false
}

});
</script>
<script src="assets/js/bootstrap.min.js"></script>
<script src="assets/js/toc.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script>
    $( document ).ready(function() {
        $("#docnavsidebar").navgoco({
            caretHtml: '',
            accordion: false,
            openClass: 'open', // open
            save: false, // leave false or nav highlighting doesn't work right
            cookie: {
                name: 'navgoco',
                expires: false,
                path: '/'
            },
            slide: {
                duration: 300,
                easing: 'swing'
            }
        });

    });

</script>
<script src="assets/js/customscripts.js"></script>

<script>
    $(document).ready(function() {
        $('[data-toggle=offcanvas]').click(function() {
            $('.row-offcanvas').toggleClass('active');
        });
    });
</script>
<script src="assets/js/tabs.js"></script>

</body>

<!-- the google_analytics_id gets auto inserted from the config file -->



<script>
(function(i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function() {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o), m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-84163503-7', 'auto');
ga('require', 'displayfeatures');
ga('send', 'pageview');
</script>




</html>
